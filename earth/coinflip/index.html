<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="icon" type="image/x-icon" href="./favicon.ico">
  <title>Jeu de Pile ou Face</title>
  <style>
    :root {
      --bg: linear-gradient(180deg, #f8fbff, #ffffff);
      --text: #0f172a;
      --muted: #64748b;
      --accent: #0ea5e9;
      --accent-2: #22c55e;
      --card: #ffffff;
      --border: rgba(2, 6, 23, 0.08);
      --shadow: 0 10px 30px rgba(2, 6, 23, 0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .container {
      max-width: 960px;
      margin: 0 auto;
      padding: 24px 16px 80px;
    }
    header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .title { font-size: 28px; font-weight: 800; }
    .subtitle { color: var(--muted); margin-top: 4px; }
    .status { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid var(--border); background: var(--card); font-size: 13px; color: var(--muted); }
    .status.live { border-color: rgba(34,197,94,0.25); color:#166534; background: #ecfdf5; }
    .status.practice { border-color: rgba(14,165,233,0.25); color:#075985; background: #f0f9ff; }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 20px;
      margin-top: 16px;
    }

    #arena { display:grid; grid-template-columns: 1fr 320px; gap: 16px; align-items: center; }
    @media (max-width: 860px) { #arena { grid-template-columns: 1fr; } }

    #coin {
      width: 140px;
      height: 140px;
      cursor: pointer;
      transition: transform 0.6s ease-out, filter .2s ease;
      filter: drop-shadow(0 6px 16px rgba(2,6,23,0.15));
    }
    #coin:hover { transform: scale(1.03); }

    #countdown {
      display: flex; justify-content: center; align-items: center;
      color: #0e2c4c; font-size: 40px; width: 220px; height: 220px;
      background: radial-gradient(70% 70% at 50% 35%, #e7f3ff, #dbeafe);
      border-radius: 50%; margin: 0 auto;
    }

    .panel h3 { margin: 0 0 8px; }
    .panel p { margin: 6px 0; color: var(--muted); }
    .stat { font-weight: 700; }
    .actions { display:flex; gap:8px; align-items:center; margin-top: 10px; flex-wrap: wrap; }
    .btn { padding:10px 14px; border-radius: 12px; border:1px solid var(--border); background: var(--card); cursor: pointer; font-weight:600; }
    .btn.primary { background: var(--accent); color: white; border-color: transparent; }
    .btn.pay { background: var(--accent-2); color: white; border-color: transparent; }
    .muted { color: var(--muted); font-size: 14px; }
    /* Profile mini card */
    .p-card { border:1px solid var(--border); border-radius:12px; background: var(--card); margin-top:10px; overflow:hidden; }
    .p-banner { width:100%; height:90px; background: linear-gradient(45deg,#06b6d4,#8b5cf6); background-size:cover; background-position:center; }
    .p-body { display:flex; gap:10px; padding:10px; align-items:center; }
    .p-pic { width:48px; height:48px; border-radius:50%; object-fit:cover; border:1px solid var(--border); }
    .p-name { font-weight:700; }
    .p-about { color: var(--muted); font-size: 13px; margin-top:4px; }
    .p-fields { display:flex; gap:8px; flex-wrap:wrap; margin:8px 10px 10px; }
    .p-chip { background:#f1f5f9; color:#0f172a; border:1px solid var(--border); padding:4px 8px; border-radius:999px; font-size:12px; }
    
    /* Bet section styling */
    #betSection { display: none; align-items: center; gap: 8px; margin-top: 8px; }
    #betSection input[type="number"] { 
      font-family: inherit; 
      font-size: 14px;
      background: var(--card);
      color: var(--text);
    }
    #betSection input[type="number"]:focus { 
      outline: none; 
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.1);
    }
    
    /* Gain display styling */
    .gain-display {
      text-align: center;
      padding: 20px;
      background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
      border-radius: 16px;
      border: 2px solid #0ea5e9;
      box-shadow: 0 8px 32px rgba(14, 165, 233, 0.15);
      animation: gainPulse 0.6s ease-out;
    }
    
    .gain-amount {
      font-size: 48px;
      font-weight: 900;
      color: #0ea5e9;
      text-shadow: 0 2px 8px rgba(14, 165, 233, 0.3);
      margin-bottom: 8px;
    }
    
    .gain-currency {
      font-size: 24px;
      font-weight: 700;
      color: #0369a1;
      margin-bottom: 12px;
    }
    
    .gain-streak {
      font-size: 16px;
      color: #64748b;
      font-weight: 600;
      margin-bottom: 8px;
    }
    
    .gain-label {
      font-size: 18px;
      font-weight: 700;
      color: #0c4a6e;
      margin-bottom: 12px;
    }
    
    .gain-next {
      font-size: 14px;
      color: #94a3b8;
      font-weight: 500;
      font-style: italic;
      margin-bottom: 16px;
    }
    
    .cashout-btn {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 16px rgba(34, 197, 94, 0.3);
      transition: all 0.3s ease;
      animation: cashoutPulse 2s ease-in-out infinite;
    }
    
    .cashout-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
      background: linear-gradient(135deg, #16a34a, #15803d);
    }
    
    .cashout-btn:active {
      transform: translateY(0);
    }
    
    /* Win display styling */
    .win-display {
      text-align: center;
      padding: 24px;
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border-radius: 20px;
      border: 3px solid #f59e0b;
      box-shadow: 0 12px 40px rgba(245, 158, 11, 0.25);
      animation: winCelebration 0.8s ease-out;
    }
    
    .win-label {
      font-size: 20px;
      font-weight: 800;
      color: #92400e;
      margin-bottom: 16px;
      text-shadow: 0 2px 4px rgba(146, 64, 14, 0.2);
    }
    
    .win-amount {
      font-size: 56px;
      font-weight: 900;
      color: #d97706;
      text-shadow: 0 4px 12px rgba(217, 119, 6, 0.4);
      margin-bottom: 8px;
    }
    
    .win-currency {
      font-size: 28px;
      font-weight: 700;
      color: #b45309;
      margin-bottom: 16px;
    }
    
    .win-status {
      font-size: 18px;
      font-weight: 600;
      color: #92400e;
    }
    
    .win-status.success {
      color: #059669;
    }
    
    .win-status.error {
      color: #dc2626;
    }
    
    /* Flipping display styling */
    .flipping-display {
      text-align: center;
      padding: 16px;
      background: linear-gradient(135deg, #f8fafc, #e2e8f0);
      border-radius: 12px;
      border: 1px solid #cbd5e1;
      animation: flippingPulse 1s ease-in-out infinite;
    }
    
    .flipping-icon {
      font-size: 32px;
      margin-bottom: 8px;
      animation: coinSpin 0.6s linear infinite;
    }
    
    .flipping-text {
      font-size: 16px;
      font-weight: 600;
      color: #475569;
    }
    
    /* Animations */
    @keyframes gainPulse {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); opacity: 1; }
    }
    
    @keyframes winCelebration {
      0% { transform: scale(0.5) rotate(-5deg); opacity: 0; }
      50% { transform: scale(1.1) rotate(2deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    
    @keyframes flippingPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    
    @keyframes coinSpin {
      0% { transform: rotateY(0deg); }
      100% { transform: rotateY(360deg); }
    }
    
    @keyframes cashoutPulse {
      0%, 100% { 
        box-shadow: 0 4px 16px rgba(34, 197, 94, 0.3);
        transform: scale(1);
      }
      50% { 
        box-shadow: 0 6px 20px rgba(34, 197, 94, 0.5);
        transform: scale(1.02);
      }
    }
    
    .practice-info {
      font-size: 0.85em;
      color: #6b7280;
      text-align: center;
      margin-top: 8px;
      padding: 6px 12px;
      background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-style: italic;
    }
    
    .captain-balance-accordion {
      background: linear-gradient(135deg, #1e293b, #334155);
      border: 2px solid #475569;
      border-radius: 12px;
      margin: 16px auto;
      max-width: 800px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      color: white;
      overflow: hidden;
    }
    
    .captain-accordion-header {
      background: linear-gradient(135deg, #475569, #64748b);
      padding: 16px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.3s ease;
    }
    
    .captain-accordion-header:hover {
      background: linear-gradient(135deg, #64748b, #94a3b8);
    }
    
    .captain-accordion-title {
      font-size: 1.1em;
      font-weight: 700;
      color: #fbbf24;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    .captain-accordion-icon {
      font-size: 1.2em;
      color: #fbbf24;
      transition: transform 0.3s ease;
    }
    
    .captain-accordion-content {
      padding: 16px;
      display: block;
    }
    
    .balance-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #475569;
    }
    
    .balance-item:last-child {
      border-bottom: none;
    }
    
    .balance-label {
      font-weight: 600;
      color: #94a3b8;
      min-width: 80px;
    }
    
    .balance-amount {
      font-weight: 700;
      color: #22c55e;
      font-size: 1.1em;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    }
    
    .balance-g1 {
      font-size: 0.85em;
      color: #cbd5e1;
      font-style: italic;
    }
    
    .captain-message {
      margin-top: 16px;
      padding: 12px;
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.05));
      border-radius: 8px;
      border: 1px solid rgba(59, 130, 246, 0.3);
    }
    
    .message-label {
      font-size: 0.9em;
      font-weight: 600;
      color: #3b82f6;
      margin-bottom: 8px;
      text-align: center;
    }
    
    .message-content {
      font-size: 0.95em;
      color: white;
      font-style: italic;
      text-align: center;
      margin-bottom: 6px;
      line-height: 1.4;
      word-wrap: break-word;
    }
    
    .message-date {
      font-size: 0.8em;
      color: #64748b;
      text-align: center;
      font-style: italic;
    }
    
    .balance-info {
      font-size: 0.9em;
      color: #fbbf24;
      text-align: center;
      margin-top: 12px;
      padding: 8px 12px;
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(251, 191, 36, 0.05));
      border-radius: 8px;
      border: 1px solid rgba(251, 191, 36, 0.3);
      font-style: italic;
    }
    
    /* IPFS Media styling */
    .ipfs-media-container {
      display: inline-block;
      margin: 4px;
      vertical-align: top;
    }
    
    .ipfs-media-container img,
    .ipfs-media-container video,
    .ipfs-media-container audio {
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .ipfs-media-container img:hover,
    .ipfs-media-container video:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }
    
    .ipfs-media-container a {
      display: block;
      margin-top: 4px;
      font-size: 0.8em;
      word-break: break-all;
      max-width: 150px;
    }
    
    /* Responsive design improvements */
    @media (max-width: 768px) {
      .gain-amount {
        font-size: 36px;
      }
      
      .gain-currency {
        font-size: 20px;
      }
      
      .win-amount {
        font-size: 42px;
      }
      
      .win-currency {
        font-size: 24px;
      }
      
      .gain-display,
      .win-display {
        padding: 16px;
        margin: 8px;
      }
      
      .cashout-btn {
        padding: 10px 20px;
        font-size: 14px;
      }
      
      .captain-balance-accordion {
        margin: 12px;
        max-width: 100%;
      }
      
      .captain-accordion-header {
        padding: 12px;
      }
      
      .captain-accordion-title {
        font-size: 1em;
      }
      
      .captain-accordion-content {
        padding: 12px;
      }
      
      .balance-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
      }
      
      .balance-label {
        min-width: auto;
      }
      
      .balance-info {
        font-size: 0.8em;
        padding: 6px 8px;
      }
      
      .captain-message {
        padding: 8px;
        margin-top: 12px;
      }
      
      .message-content {
        font-size: 0.9em;
      }
    }
  </style>
  <script src="../astro.js"></script>
  <script src="../nostr.bundle.js"></script>
</head>
<body>

  <div class="container">
    <header>
      <div>
        <div class="title">Pile ou Face</div>
        <div class="subtitle">Paradoxe de Saint-Pétersbourg — lancez jusqu'à obtenir face. Les gains doublent à chaque pile. Quand vous obtenez FACE (défaite), vous envoyez 1 ẐEN au CAPITAINE via like. Voir les soldes du CAPITAINE ci-dessous !</div>
      </div>
      <div id="modeBadge" class="status practice">Mode entraînement • pas de gains</div>
    </header>
    <div id="arena" class="card">
      <div>
        <div id="countdown">
          <img id="coin" src="/ipfs/QmYCKyYnYDGq6U7WuMmUoF7v5okvzoEThgYyKj9AzJPeP2" alt="Pièce">
        </div>
      </div>
      <div class="panel">
        <h3>État du jeu</h3>
        <div id="ainfo" style="margin-top:8px">
          <div id="message"><p>Cliquez sur la pièce pour la lancer.</p></div>
        </div>
      </div>
    </div>
    
    <div class="card" id="auth">
      <div class="actions">
        <button id="loginBtn" class="btn primary">Se connecter avec Nostr</button>
        <span id="authStatus" class="muted"></span>
      </div>
      <div id="profileCard" class="p-card" style="display:none">
        <div id="pBanner" class="p-banner"></div>
        <div class="p-body">
          <img id="pPic" class="p-pic" alt="profil"/>
          <div>
            <div id="pName" class="p-name"></div>
            <div id="pAbout" class="p-about"></div>
          </div>
        </div>
        <div id="pFields" class="p-fields"></div>
      </div>

    </div>


  </div>


 

  <script>
    // Nostr and uSPOT integration (NIP-42 auth + uSPOT API detection)
    let upassportUrl = '';
    let DEFAULT_RELAYS = [ 'wss://relay.copylaradio.com', 'ws://127.0.0.1:7777', 'wss://relay.damus.io', 'wss://nos.lol' ];
    let NOSTRws = '';
    let nostrRelay = null;
    let isNostrConnected = false;
    let authCompleted = false;
    let userPubkey = null;
    let authEventPublished = false;
    const DEFAULT_PROFILE_RELAYS = ['wss://relay.copylaradio.com'];


    // Function to fetch CAPTAIN data from ASTROPORT station
    async function fetchCaptainData() {
      try {
        const sruUrl = window.__ASTROPORT_STATION_URL__;
        if (!sruUrl) {
          console.warn('[CAPTAIN] ASTROPORT station URL not available');
          return null;
        }
        
        console.log('[CAPTAIN] Fetching data from ASTROPORT station:', sruUrl);
        const response = await fetch(sruUrl);
        
        if (!response.ok) {
          console.warn('[CAPTAIN] Failed to fetch ASTROPORT data:', response.status);
          return null;
        }
        
        const data = await response.json();
        console.log('[CAPTAIN] ASTROPORT data received:', data);
        
        // Extract captainHEX and balances from the JSON
        const captainHex = data.captainHEX;
        const captainG1pub = data.CAPTAING1PUB;
        const captainZencardG1pub = data.CAPTAINZENCARDG1PUB;
        
        if (!captainHex) {
          console.warn('[CAPTAIN] No captainHEX found in ASTROPORT data');
          return null;
        }
        
        // Try to get CAPTAIN's first message from relay
        const firstMessage = await getCaptainFirstMessage(captainHex);
        
        // Fetch CAPTAIN balances
        const captainBalances = await fetchCaptainBalances(captainG1pub, captainZencardG1pub);
        
        // Try to get CAPTAIN profile from relay
        const captainProfile = await getCaptainProfile(captainHex);
        
        // Display CAPTAIN balances in the UI
        displayCaptainBalances(captainBalances, firstMessage, captainProfile);
        
        // Store CAPTAIN data globally for use in game
        window.captainData = { 
          captainHex, 
          firstMessage, 
          captainG1pub, 
          captainZencardG1pub, 
          captainBalances,
          captainProfile,
          sruUrl 
        };
        
        return window.captainData;
      } catch (error) {
        console.error('[CAPTAIN] Error fetching ASTROPORT data:', error);
        return null;
      }
    }
    
    // Function to get CAPTAIN profile from relay
    async function getCaptainProfile(captainHex) {
      try {
        const relayUrl = sanitizeRelayUrl(NOSTRws || DEFAULT_RELAYS[0]);
        console.log('[CAPTAIN] Fetching profile from relay:', relayUrl);
        
        return new Promise((resolve) => {
          const ws = new WebSocket(relayUrl);
          let timeout;
          
          ws.onopen = () => {
            // Request CAPTAIN's profile (kind 0)
            const subId = `captain_profile_${Date.now()}`;
            const req = JSON.stringify(['REQ', subId, { 
              kinds: [0], 
              authors: [captainHex], 
              limit: 1
            }]);
            ws.send(req);
            console.log('[CAPTAIN] Sent REQ for profile');
          };
          
          ws.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              if (data[0] === 'EVENT' && data[2]?.kind === 0) {
                const profile = data[2];
                let profileData = {};
                
                try {
                  const content = JSON.parse(profile.content);
                  profileData = {
                    name: content.name || 'CAPTAIN',
                    about: content.about || '',
                    picture: content.picture || '',
                    banner: content.banner || ''
                  };
                } catch (e) {
                  profileData = { name: 'CAPTAIN' };
                }
                
                console.log('[CAPTAIN] Profile found:', profileData);
                ws.close();
                clearTimeout(timeout);
                resolve(profileData);
              } else if (data[0] === 'EOSE') {
                console.log('[CAPTAIN] No profile found, using default');
                ws.close();
                clearTimeout(timeout);
                resolve({ name: 'CAPTAIN' });
              }
            } catch (e) {
              console.warn('[CAPTAIN] Profile parse error:', e);
            }
          };
          
          ws.onerror = () => {
            console.warn('[CAPTAIN] WebSocket error, using default profile');
            clearTimeout(timeout);
            resolve({ name: 'CAPTAIN' });
          };
          
          timeout = setTimeout(() => {
            console.warn('[CAPTAIN] Timeout, using default profile');
            ws.close();
            resolve({ name: 'CAPTAIN' });
          }, 5000);
        });
      } catch (error) {
        console.error('[CAPTAIN] Error getting profile:', error);
        return { name: 'CAPTAIN' };
      }
    }
    
    // Function to fetch CAPTAIN balances from uSPOT API
    async function fetchCaptainBalances(captainG1pub, captainZencardG1pub) {
      try {
        const apiBase = window.__UPASSPORT_API__ || upassportUrl;
        if (!apiBase) {
          console.warn('[CAPTAIN] uSPOT API not available for balance check');
          return null;
        }
        
        const balances = {};
        
        // Fetch CAPTAIN's main balance
        if (captainG1pub) {
          try {
            const response = await fetch(`${apiBase}/check_balance?g1pub=${encodeURIComponent(captainG1pub)}`);
            if (response.ok) {
              const data = await response.json();
              const g1 = Number(data.balance || data.g1_balance || 0);
              const zen = Math.max(0, Math.floor((g1 - 1) * 10));
              balances.main = { g1, zen };
              console.log('[CAPTAIN] Main balance:', balances.main);
            }
          } catch (e) {
            console.warn('[CAPTAIN] Failed to fetch main balance:', e);
          }
        }
        
        // Fetch CAPTAIN's ZENCARD balance
        if (captainZencardG1pub) {
          try {
            const response = await fetch(`${apiBase}/check_balance?g1pub=${encodeURIComponent(captainZencardG1pub)}`);
            if (response.ok) {
              const data = await response.json();
              const g1 = Number(data.balance || data.g1_balance || 0);
              const zen = Math.max(0, Math.floor((g1 - 1) * 10));
              balances.zencard = { g1, zen };
              console.log('[CAPTAIN] ZENCARD balance:', balances.zencard);
            }
          } catch (e) {
            console.warn('[CAPTAIN] Failed to fetch ZENCARD balance:', e);
          }
        }
        
        return balances;
      } catch (error) {
        console.error('[CAPTAIN] Error fetching balances:', error);
        return null;
      }
    }
    
    // Function to get CAPTAIN's first message from relay
    async function getCaptainFirstMessage(captainHex) {
      try {
        const relayUrl = sanitizeRelayUrl(NOSTRws || DEFAULT_RELAYS[0]);
        console.log('[CAPTAIN] Fetching first message from relay:', relayUrl);
        
        return new Promise((resolve) => {
          const ws = new WebSocket(relayUrl);
          let timeout;
          
          ws.onopen = () => {
            // Request CAPTAIN's first message (kind 1 - text note)
            const subId = `captain_${Date.now()}`;
            const req = JSON.stringify(['REQ', subId, { 
              kinds: [1], 
              authors: [captainHex], 
              limit: 1,
              until: Math.floor(Date.now() / 1000) + 3600 // Last hour
            }]);
            ws.send(req);
            console.log('[CAPTAIN] Sent REQ for first message');
          };
          
          ws.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              if (data[0] === 'EVENT' && data[2]?.kind === 1) {
                const messageId = data[2].id;
                const messageContent = data[2].content;
                const messageCreated = data[2].created_at;
                console.log('[CAPTAIN] Found first message:', messageId, 'Content:', messageContent);
                ws.close();
                clearTimeout(timeout);
                resolve({
                  id: messageId,
                  content: messageContent,
                  created_at: messageCreated
                });
              } else if (data[0] === 'EOSE') {
                console.log('[CAPTAIN] No messages found, using captainHEX as fallback');
                ws.close();
                clearTimeout(timeout);
                resolve({
                  id: captainHex,
                  content: 'CAPTAIN profile',
                  created_at: Math.floor(Date.now() / 1000)
                });
              }
            } catch (e) {
              console.warn('[CAPTAIN] Message parse error:', e);
            }
          };
          
          ws.onerror = () => {
            console.warn('[CAPTAIN] WebSocket error, using captainHEX as fallback');
            clearTimeout(timeout);
            resolve({
              id: captainHex,
              content: 'CAPTAIN profile',
              created_at: Math.floor(Date.now() / 1000)
            });
          };
          
          timeout = setTimeout(() => {
            console.warn('[CAPTAIN] Timeout, using captainHEX as fallback');
            ws.close();
            resolve({
              id: captainHex,
              content: 'CAPTAIN profile',
              created_at: Math.floor(Date.now() / 1000)
            });
          }, 5000);
        });
      } catch (error) {
        console.error('[CAPTAIN] Error getting first message:', error);
        return {
          id: captainHex,
          content: 'CAPTAIN profile',
          created_at: Math.floor(Date.now() / 1000)
        };
      }
    }

    // Function to send like to CAPTAIN (triggers 1 Ẑen payment FROM player TO captain via relay 7.sh)
    async function sendLikeToCaptain() {
      try {
        console.log('[LIKE] Starting like send to CAPTAIN');
        console.log('[LIKE] User pubkey:', userPubkey ? userPubkey.substring(0, 8) + '...' : 'none');
        console.log('[LIKE] User profile:', window.userProfile);
        
        const captainData = await fetchCaptainData();
        if (!captainData) {
          console.warn('[LIKE] Cannot send like - no captain data');
          return false;
        }
        
        const { captainHex, firstMessage, captainBalances } = captainData;
        console.log('[LIKE] Captain data:', {
          captainHex: captainHex.substring(0, 8) + '...',
          messageId: firstMessage.id.substring(0, 8) + '...',
          messageContent: firstMessage.content.substring(0, 100) + '...',
          balances: captainBalances
        });
        
        // Create a like event (kind 7) to the CAPTAIN's first message
        // This will trigger the 7.sh script on the relay to send 1 Ẑen
        const likeEvent = {
          kind: 7,
          created_at: Math.floor(Date.now() / 1000),
          tags: [
            ['e', firstMessage.id], // React to CAPTAIN's first message
            ['p', captainHex],      // CAPTAIN's pubkey
            ['k', '1']              // Kind 1 (text note)
          ],
          content: '+', // Simple like
          pubkey: userPubkey
        };
        
        console.log('[LIKE] Created like event:', {
          kind: likeEvent.kind,
          created_at: likeEvent.created_at,
          tags: likeEvent.tags,
          content: likeEvent.content,
          pubkey: likeEvent.pubkey.substring(0, 8) + '...'
        });
        
        // Sign the event
        let signedLikeEvent = null;
        if (window.nostr && typeof window.nostr.signEvent === 'function') {
          console.log('[LIKE] Signing event with Nostr extension');
          signedLikeEvent = await window.nostr.signEvent(likeEvent);
        }
        
        if (!signedLikeEvent) {
          console.warn('[LIKE] Failed to sign like event');
          return false;
        }
        
        console.log('[LIKE] Event signed successfully, ID:', signedLikeEvent.id.substring(0, 8) + '...');
        
        // Send via relay
        if (nostrRelay && typeof nostrRelay.publish === 'function') {
          console.log('[LIKE] Publishing via Nostr relay');
          await nostrRelay.publish(signedLikeEvent);
          console.log('[LIKE] Like sent via relay, should trigger 1 Ẑen payment');
          return true;
        } else {
          // Fallback: direct WebSocket
          const relayUrl = sanitizeRelayUrl(NOSTRws || DEFAULT_RELAYS[0]);
          console.log('[LIKE] Using fallback WebSocket to:', relayUrl);
          const ws = new WebSocket(relayUrl);
          
          return new Promise((resolve) => {
            ws.onopen = () => {
              const eventMsg = JSON.stringify(['EVENT', signedLikeEvent]);
              ws.send(eventMsg);
              console.log('[LIKE] Like sent via direct WebSocket');
              ws.close();
              resolve(true);
            };
            
            ws.onerror = () => {
              console.error('[LIKE] WebSocket error sending like');
              resolve(false);
            };
            
            setTimeout(() => {
              ws.close();
              resolve(false);
            }, 5000);
          });
        }
      } catch (error) {
        console.error('[LIKE] Error sending like:', error);
        console.error('[LIKE] Error stack:', error.stack);
        return false;
      }
    }

    // Function to toggle CAPTAIN accordion
    function toggleCaptainAccordion() {
      const accordion = document.getElementById('captainBalance');
      const content = accordion.querySelector('.captain-accordion-content');
      const icon = accordion.querySelector('.captain-accordion-icon');
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.textContent = '▼';
        accordion.classList.add('expanded');
      } else {
        content.style.display = 'none';
        icon.textContent = '▶';
        accordion.classList.remove('expanded');
      }
    }

    // Function to display CAPTAIN balances and message in the UI
    function displayCaptainBalances(captainBalances, captainMessage = null, captainProfile = null) {
      if (!captainBalances) return;
      
      // Create or update CAPTAIN balance display
      let captainBalanceEl = document.getElementById('captainBalance');
      if (!captainBalanceEl) {
        captainBalanceEl = document.createElement('div');
        captainBalanceEl.id = 'captainBalance';
        captainBalanceEl.className = 'captain-balance-accordion';
        
        // Insert at the very top of the page, before the container
        const container = document.querySelector('.container');
        if (container && container.parentNode) {
          container.parentNode.insertBefore(captainBalanceEl, container);
        }
      }
      
      // Get CAPTAIN profile name if available
      const captainName = captainProfile?.name || 'CAPTAIN';
      
      let balanceHTML = `<div class="captain-accordion-header" onclick="toggleCaptainAccordion()">
        <span class="captain-accordion-title">🏴‍☠️ ${captainName}</span>
        <span class="captain-accordion-icon">▶</span>
      </div>`;
      
      balanceHTML += '<div class="captain-accordion-content" style="display: none;">';
      
      if (captainBalances.main) {
        balanceHTML += `<div class="balance-item">
          <span class="balance-label">MULTIPASS:</span>
          <span class="balance-amount">${captainBalances.main.zen} ẐEN</span>
          <span class="balance-g1">(${captainBalances.main.g1} Ğ1)</span>
        </div>`;
      }
      
      if (captainBalances.zencard) {
        balanceHTML += `<div class="balance-item">
          <span class="balance-label">ZENCARD:</span>
          <span class="balance-amount">${captainBalances.zencard.zen} ẐEN</span>
          <span class="balance-g1">(${captainBalances.zencard.g1} Ğ1)</span>
        </div>`;
      }
      
      if (!captainBalances.main && !captainBalances.zencard) {
        balanceHTML += '<div class="balance-item">Balance unavailable</div>';
      }
      
      // Add CAPTAIN message if available
      if (captainMessage && captainMessage.content && captainMessage.content !== 'CAPTAIN profile') {
        const messageDate = new Date(captainMessage.created_at * 1000).toLocaleDateString();
        
        // Process the message content directly with IPFS media link processing
        const processedContent = processIPFSMediaLinks(captainMessage.content);
        
        balanceHTML += `<div class="captain-message">
          <div class="message-label">📝 ${captainName} Message:</div>
          <div class="message-content">"${processedContent}"</div>
          <div class="message-date">${messageDate}</div>
        </div>`;
      }
      
      // Add info about likes and payments
      const isLiveMode = window.isPaid && userPubkey;
      if (isLiveMode) {
        balanceHTML += '<div class="balance-info">💡 Mode réel : FACE déclenche un vrai paiement de 1 ẐEN du joueur au CAPITAINE</div>';
      } else {
        balanceHTML += '<div class="balance-info">💡 Mode entraînement : Paiement FACE simulé, pas de vrais paiements</div>';
      }
      
      balanceHTML += '</div>'; // Close accordion content
      
      captainBalanceEl.innerHTML = balanceHTML;
      
      // Content is already processed with IPFS media links, no additional processing needed
    }

    // Function to handle cashing out gains
    async function cashoutGains(amount) {
      const messageEl = document.getElementById('message');
      if (!messageEl) return;
      
      if (userPubkey && window.userProfile && window.userProfile.g1pub) {
        // Live mode: process real payment
        messageEl.innerHTML = `<div class="win-display">
          <div class="win-label">💰 ENCAISSÉ ! 💰</div>
          <div class="win-amount">${amount}</div>
          <div class="win-currency">ZEN</div>
          <div class="win-status">Traitement du paiement...</div>
        </div>`;
        
        // Process winning payment
        const success = await processWinningPayment(amount, userPubkey);
        if (success) {
          messageEl.innerHTML = `<div class="win-display">
            <div class="win-label">💰 ENCAISSÉ ! 💰</div>
            <div class="win-amount">${amount}</div>
            <div class="win-currency">ZEN</div>
            <div class="win-status success">✓ Paiement envoyé !</div>
          </div>`;
        } else {
          messageEl.innerHTML = `<div class="win-display">
            <div class="win-label">💰 ENCAISSÉ ! 💰</div>
            <div class="win-amount">${amount}</div>
            <div class="win-currency">ZEN</div>
            <div class="win-status error">⚠ Paiement échoué</div>
          </div>`;
        }
      } else {
        // Practice mode: show simulated cashout
        messageEl.innerHTML = `<div class="win-display">
          <div class="win-label">💰 ENCAISSÉ ! 💰</div>
          <div class="win-amount">${amount}</div>
          <div class="win-currency">Ẑen</div>
          <div class="win-status">Simulé</div>
        </div>`;
      }
      
      // Reset game state
      consecutiveHeads = 0;
      isFirstClick = true; // Reset to first click after cashout
      window.gameResetForLiveMode = false; // Allow game reset on next mode update
      updateModeBadge();
      
      // Reset coin image
      const coinEl = document.getElementById('coin');
      if (coinEl) {
        coinEl.src = '/ipfs/QmeZhZ6yR6YHhiZ9qfBUCA1RKUP83dZL6MtU4PCBrdzjWn';
      }
      
      // Reset flipping state
      isFlipping = false;
    }

    function updateModeBadge() {
      const badge = document.getElementById('modeBadge');
      console.log('[MODE] Updating mode badge');
      console.log('[MODE] User pubkey:', userPubkey ? userPubkey.substring(0, 8) + '...' : 'none');
      console.log('[MODE] User profile:', window.userProfile);
      console.log('[MODE] Has G1PUB:', window.userProfile?.g1pub ? 'yes' : 'no');
      console.log('[MODE] Balance:', window.userProfile?.balance);
      console.log('[MODE] G1 Balance:', window.userProfile?.g1Balance);
      
      if (userPubkey && window.userProfile && window.userProfile.g1pub) {
        badge.className = 'status ready';
        if (window.userProfile.balance !== undefined) {
          badge.textContent = `Prêt à jouer • Solde : ${window.userProfile.balance} ẐEN • FACE → envoyer 1 ẐEN au CAPITAINE`;
          console.log('[MODE] Set to READY mode with balance:', window.userProfile.balance);
        } else {
          badge.textContent = 'Prêt à jouer • MULTIPASS vérifié • FACE → envoyer 1 ẐEN au CAPITAINE';
          console.log('[MODE] Set to READY mode without balance');
        }
        
        // Reset game state for live mode when user has MULTIPASS
        if (!window.gameResetForLiveMode) {
          console.log('[GAME] Resetting game state for live mode with MULTIPASS');
          consecutiveHeads = 0;
          isFirstClick = true;
          window.gameResetForLiveMode = true;
          
          // Update initial message for live mode
          const messageEl = document.getElementById('message');
          if (messageEl) {
            messageEl.innerHTML = '<p>Cliquez sur la pièce pour la lancer.<br><small>💡 Mode réel : PILE = doubler la cagnotte, FACE = perdre la cagnotte et envoyer 1 ẐEN au CAPITAINE</small></p>';
          }
          
          // Reset coin image for live mode
          const coinEl = document.getElementById('coin');
          if (coinEl) {
            coinEl.src = '/ipfs/QmeZhZ6yR6YHhiZ9qfBUCA1RKUP83dZL6MtU4PCBrdzjWn';
          }
        }
      } else if (userPubkey) {
        badge.className = 'status practice';
        badge.textContent = 'Mode entraînement • MULTIPASS requis • Paiement FACE simulé';
        console.log('[MODE] Set to PRACTICE mode - no MULTIPASS');
        // Reset game state for practice mode
        window.gameResetForLiveMode = false;
      } else {
        badge.className = 'status practice';
        badge.textContent = 'Mode entraînement • se connecter pour jouer • Paiement FACE simulé';
        console.log('[MODE] Set to PRACTICE mode - not connected');
        // Reset game state for practice mode
        window.gameResetForLiveMode = false;
      }
    }

    function detectUSPOTAPI() {
      const currentURL = new URL(window.location.href);
      const hostname = currentURL.hostname;
      const port = currentURL.port;
      const protocol = currentURL.protocol.split(":")[0];

      console.log('[API] Detecting uSPOT API configuration');
      console.log('[API] Current URL:', window.location.href);
      console.log('[API] Hostname:', hostname);
      console.log('[API] Port:', port);
      console.log('[API] Protocol:', protocol);

      // Compute uPassport base URL
      let uPort = port;
      if (uPort === '8080') uPort = '54321';
      const uHost = hostname.replace(/^ipfs\./, 'u.');
      upassportUrl = `${protocol}://${uHost}${uPort ? `:${uPort}` : ''}`;
      // Expose API base also for profile/balance fetches
      window.__UPASSPORT_API__ = upassportUrl;

      // Compute relay websocket URL robustly
      let rPort = port;
      if (rPort === '8080') rPort = '7777';
      const rHost = hostname.replace(/^ipfs\./, 'relay.').replace(/^127\.0\.0\.1$/, '127.0.0.1');
      const wsProtocol = protocol === 'https' ? 'wss' : 'ws';
      NOSTRws = `${wsProtocol}://${(hostname === '127.0.0.1' || hostname === 'localhost') && port === '8080' ? '127.0.0.1' : rHost}${rPort ? `:${rPort}` : ''}`;
      NOSTRws = sanitizeRelayUrl(NOSTRws);

      // Fall back to defaults if detection failed
      if (!NOSTRws || NOSTRws.includes('//:')) {
        NOSTRws = 'wss://relay.copylaradio.com';
      }

      // Compute ASTROPORT station URL for CAPTAIN data
      let sruPort = '12345'; // Always use port 12345 for astroport
      const sruHost = hostname.replace(/^ipfs\./, 'astroport.'); // Replace ipfs. with astroport.
      const sruUrl = (hostname === '127.0.0.1' || hostname === 'localhost') && port === '8080'
        ? `${protocol}://127.0.0.1:12345` // Local development case
        : `${protocol}://${sruHost}/12345`; // Production case with astroport subdomain
      window.__ASTROPORT_STATION_URL__ = sruUrl;

      DEFAULT_RELAYS = [NOSTRws, 'wss://relay.damus.io', 'wss://nos.lol']; // Non-Astroport fallback relays (yet)
      console.log(`[API] uSPOT API: ${upassportUrl} | Relay: ${NOSTRws} | ASTROPORT Station: ${sruUrl}`);
      console.log(`[API] Final API base stored in window.__UPASSPORT_API__:`, window.__UPASSPORT_API__);
    }

    // Ensure relay URLs contain no hidden/control characters and normalized scheme
    function sanitizeRelayUrl(url) {
      if (!url || typeof url !== 'string') return url;
      const cleaned = url.replace(/[\u200B-\u200D\uFEFF\u2060\uFE0F\uFFFC\u0000-\u001F\u007F]/g, '');
      return cleaned.replace(/^(wss?):\/*/, (m, p1) => `${p1}://`);
    }

        async function handleLogin() {
      const loginBtn = document.getElementById('loginBtn');
      const authStatus = document.getElementById('authStatus');
      if (!window.nostr || typeof window.nostr.getPublicKey !== 'function') {
        alert('Extension Nostr requise pour se connecter.');
        return;
      }
      try {
        console.log('[LOGIN] Starting login sequence');
        loginBtn.disabled = true;
        authStatus.textContent = 'Demande de clé publique...';
        const pubkey = await window.nostr.getPublicKey();
        if (!pubkey) throw new Error('Aucune clé publique retournée');
        userPubkey = pubkey;
        console.log('[LOGIN] Got public key:', pubkey.substring(0, 8) + '...');
        
        loginBtn.textContent = 'Autorisation...';
        authStatus.textContent = 'Connexion au relais Nostr...';
        console.log('[LOGIN] Connecting to relay...');
        await connectToRelay();
        
        console.log('[LOGIN] Relay connected, profile will be fetched automatically');
        // Profile will be fetched after relay connection is established
        // UI will be updated after NIP-42 completes or timeout
        
        // CAPTAIN data is already fetched once at page load, no need to fetch again
      } catch (e) {
        console.error('[LOGIN] Login failed:', e);
        alert('Connexion échouée. Veuillez autoriser dans votre extension Nostr.');
        loginBtn.disabled = false;
        authStatus.textContent = '';
      }
    }

    async function fetchAndDisplayProfile(hexPubkey) {
      try {
        const profileCard = document.getElementById('profileCard');
        const pBanner = document.getElementById('pBanner');
        const pPic = document.getElementById('pPic');
        const pName = document.getElementById('pName');
        const pAbout = document.getElementById('pAbout');
        const pFields = document.getElementById('pFields');
        const payBtn = document.getElementById('payBtn');
        profileCard.style.display = 'block';
        pName.textContent = 'Chargement du profil...';

        // Minimal profile fetch (kind 0) via SimplePool when available
        let name = hexPubkey.substring(0, 16);
        let picture = '';
        let banner = '';
        let website = '';
        let about = '';
        let g1pubFromProfile = '';
        let zencardFromProfile = '';
        try {
          // Hybrid approach: use direct WebSocket for reliable communication
          console.log('[Profile] Using direct WebSocket for profile fetch');
          
          const parseAndAssign = (ev) => {
            try { 
              const content = JSON.parse(ev.content); 
              name = content.display_name || content.name || name; 
              picture = content.picture || picture; 
              banner = content.banner || banner;
              website = content.website || website;
              about = content.about || about;
            } catch {}
            try {
              if (Array.isArray(ev.tags)) {
                console.log('[Profile] Parsing tags:', ev.tags);
                for (const t of ev.tags) {
                  if (Array.isArray(t) && t[0] === 'i' && typeof t[1] === 'string') {
                    console.log('[Profile] Processing tag:', t[0], t[1]);
                    if (t[1].startsWith('g1pub:')) { 
                      g1pubFromProfile = t[1].slice('g1pub:'.length); 
                      console.log('[Profile] Found g1pub:', g1pubFromProfile);
                    } else if (t[1].startsWith('g1pubv2:') && !g1pubFromProfile) { 
                      g1pubFromProfile = t[1].slice('g1pubv2:'.length); 
                      console.log('[Profile] Found g1pubv2:', g1pubFromProfile);
                    } else if (t[1].startsWith('zencard:')) { 
                      zencardFromProfile = t[1].slice('zencard:'.length); 
                      console.log('[Profile] Found zencard:', zencardFromProfile);
                    }
                  }
                }
              }
            } catch {}
          };

          // Create a dedicated WebSocket for profile fetching
          const relayUrl = sanitizeRelayUrl(NOSTRws || DEFAULT_RELAYS[0] || DEFAULT_PROFILE_RELAYS[0]);
          console.log('[Profile] Creating dedicated WebSocket to:', relayUrl);
          
          await new Promise((resolve) => {
            let done = false;
            const timeout = setTimeout(() => { 
              if (!done) {
                console.log('[Profile] WebSocket timeout, resolving');
                resolve(); 
              }
            }, 8000);
            
            const ws = new WebSocket(relayUrl);
            
            ws.onopen = () => {
              console.log('[Profile] WebSocket connected, sending REQ');
              const subId = `profile_${Date.now()}`;
              const req = JSON.stringify(['REQ', subId, { kinds: [0], authors: [hexPubkey], limit: 1 }]);
              ws.send(req);
              console.log('[Profile] Sent REQ:', req);
            };
            
            ws.onmessage = (event) => {
              try {
                const data = JSON.parse(event.data);
                console.log('[Profile] Received:', data[0], data[1]);
                
                if (data[0] === 'EVENT' && data[2]?.kind === 0) {
                  console.log('[Profile] Parsing profile event:', data[2]);
                  parseAndAssign(data[2]);
                } else if (data[0] === 'EOSE') {
                  console.log('[Profile] EOSE received');
                  done = true;
                  clearTimeout(timeout);
                  ws.close();
                  resolve();
                }
              } catch (e) {
                console.warn('[Profile] Message parse error:', e);
              }
            };
            
            ws.onerror = (error) => {
              console.error('[Profile] WebSocket error:', error);
            };
            
            ws.onclose = () => {
              console.log('[Profile] WebSocket closed');
              if (!done) {
                clearTimeout(timeout);
                resolve();
              }
            };
          });
          
        } catch (e) { console.warn('Profile fetch failed', e); }

        const short = `${hexPubkey.substring(0,10)}...${hexPubkey.substring(hexPubkey.length-6)}`;
        pBanner.style.backgroundImage = banner ? `url('${banner}')` : (picture ? `url('${picture}')` : '');
        pPic.src = picture || '/ipfs/QmQRq211EMmQJ7QE44FrVZt8EMF7JJWnayDXHyKzes4pX1';
        
        // Check if profile has zencard parameter (required to play)
        // Filter out "None" values from zencard
        const hasZencard = zencardFromProfile && zencardFromProfile.length > 0 && zencardFromProfile !== 'None';
        const hasG1pub = g1pubFromProfile && g1pubFromProfile.length > 0;
        
        console.log('[Profile] Final values:', {
          name,
          hasZencard,
          zencardFromProfile,
          hasG1pub,
          g1pubFromProfile
        });
        
        pName.innerHTML = `${name} <span class="muted">(${short})</span>${hasG1pub ? ' • <span style="color:#22c55e">MULTIPASS</span>' : ' • <span style="color:#ef4444">Pas de MULTIPASS</span>'}${hasZencard ? ' • <span style="color:#f59e0b">ZENCARD</span>' : ''}`;
        pAbout.textContent = about || '';
        pFields.innerHTML = '';
        
        if (hasG1pub) {
          const g1Short = `${g1pubFromProfile.substring(0,6)}...${g1pubFromProfile.substring(g1pubFromProfile.length-6)}`;
          const chip = document.createElement('span');
          chip.className = 'p-chip';
          chip.textContent = `🔑 ${g1Short}`;
          pFields.appendChild(chip);
        }
        
        if (hasZencard) {
          const zencardShort = `${zencardFromProfile.substring(0,6)}...${zencardFromProfile.substring(zencardFromProfile.length-6)}`;
          const chip = document.createElement('span');
          chip.className = 'p-chip';
          chip.style.backgroundColor = '#fef3c7';
          chip.style.color = '#92400e';
          chip.textContent = `💳 ${zencardShort}`;
          pFields.appendChild(chip);
        } else if (zencardFromProfile === 'None') {
          // Don't display anything for "None" zencard
        }
        
        // Add website if available
        if (website) {
          const websiteChip = document.createElement('a');
          websiteChip.className = 'p-chip';
          websiteChip.href = website;
          websiteChip.target = '_blank';
          websiteChip.style.textDecoration = 'none';
          websiteChip.style.backgroundColor = '#dbeafe';
          websiteChip.style.color = '#075985';
          websiteChip.textContent = `🌐 Website`;
          pFields.appendChild(websiteChip);
        }

        // Balance fetch only if member (g1pub present in profile tags)
        const apiBase = window.__UPASSPORT_API__ || upassportUrl;
        let userBalance = 0;
        let userG1Balance = 0;
        
        console.log('[BALANCE] Starting balance fetch for user with MULTIPASS');
        console.log('[BALANCE] API Base URL:', apiBase);
        console.log('[BALANCE] G1PUB from profile:', g1pubFromProfile);
        console.log('[BALANCE] Has G1PUB:', hasG1pub);
        
        if (hasG1pub) {
          try {
            const balanceUrl = `${apiBase}/check_balance?g1pub=${encodeURIComponent(g1pubFromProfile)}`;
            console.log('[BALANCE] Fetching from URL:', balanceUrl);
            
            const r = await fetch(balanceUrl);
            console.log('[BALANCE] API Response status:', r.status, r.statusText);
            console.log('[BALANCE] API Response headers:', Object.fromEntries(r.headers.entries()));
            
            if (r.ok) {
              const js = await r.json();
              console.log('[BALANCE] API Response JSON:', js);
              
              // Try different possible field names for balance
              const g1 = Number(js.balance || js.g1_balance || js.total || js.ud_value || 0);
              userG1Balance = g1;
              
              // Calculate ZEN: (G1 - 1) * 10, minimum 0
              const zen = Math.max(0, Math.floor((g1 - 1) * 10));
              userBalance = zen;
              
              console.log('[BALANCE] Calculated balance:', { 
                g1, 
                zen, 
                formula: `(${g1} - 1) * 10 = ${zen}`,
                rawResponse: js
              });
              
              const chip = document.createElement('span');
              chip.className = 'p-chip';
              chip.textContent = `ẐEN: ${zen} (${g1} Ğ1)`;
              pFields.appendChild(chip);
              
              console.log('[BALANCE] Balance chip added to UI:', chip.textContent);
            } else {
              console.warn('[BALANCE] API error response:', r.status, r.statusText);
              const errorText = await r.text();
              console.warn('[BALANCE] Error response body:', errorText);
              
              const chip = document.createElement('span');
              chip.className = 'p-chip';
              chip.textContent = 'Balance unavailable';
              pFields.appendChild(chip);
            }
          } catch (e) {
            console.error('[BALANCE] Fetch error:', e);
            console.error('[BALANCE] Error stack:', e.stack);
            
            const chip = document.createElement('span');
            chip.className = 'p-chip';
            chip.textContent = 'Balance unavailable';
            pFields.appendChild(chip);
          }
        } else {
          console.log('[BALANCE] No G1PUB found in profile, skipping balance fetch');
        }
        
        // Store profile information for later use (balance info for MULTIPASS users)
        if (hasG1pub) {
          window.userProfile = {
            zencard: zencardFromProfile,
            g1pub: g1pubFromProfile,
            name: name,
            picture: picture,
            balance: userBalance,
            g1Balance: userG1Balance
          };
          console.log('[Profile] MULTIPASS detected - balance info stored:', {
            g1pub: g1pubFromProfile,
            g1Balance: userG1Balance,
            zenBalance: userBalance
          });
        } else {
          // Clear profile information for non-MULTIPASS users
          window.userProfile = null;
          console.log('[Profile] No MULTIPASS detected');
          
          // Add help message for getting MULTIPASS
          const helpChip = document.createElement('div');
          helpChip.className = 'p-chip';
          helpChip.style.backgroundColor = '#fef3c7';
          helpChip.style.color = '#92400e';
          helpChip.style.cursor = 'pointer';
          helpChip.textContent = '💡 Comment obtenir un MULTIPASS ?';
          helpChip.onclick = () => {
            alert('Pour obtenir un MULTIPASS :\n\n1. Ajoutez un tag "i" avec "g1pub:VOTRE_CLE_G1" dans votre profil NOSTR\n2. Ou visitez votre Astroport local pour créer un MULTIPASS\n3. Le MULTIPASS vous permet de jouer en mode réel avec de vrais paiements ZEN');
          };
          pFields.appendChild(helpChip);
        }
        
        // Update mode badge to reflect current state (only once after profile is complete)
        updateModeBadge();
        
        // CAPTAIN data is already fetched once at page load, no need to fetch again
        
      } catch (e) {
        console.warn('fetchAndDisplayProfile error', e);
      }
    }

    async function connectToRelay() {
      const relayUrl = sanitizeRelayUrl(NOSTRws || DEFAULT_RELAYS[0]);
      try {
        nostrRelay = NostrTools.relayInit(relayUrl);
        nostrRelay.on('connect', () => {
          isNostrConnected = true;
          console.log('[NIP-42] Connected to relay', relayUrl);
          // Proactively publish a 22242 EVENT to be discoverable by backend
          if (!authEventPublished) {
            console.log('[NIP-42] Proactive 22242 EVENT publish starting');
            sendProactiveAuth(relayUrl).catch(err => console.warn('[NIP-42] Proactive EVENT publish failed:', err));
          }
        });
        nostrRelay.on('error', (err) => { isNostrConnected = false; console.error('Relay error', err); });
        nostrRelay.on('auth', async (challenge) => {
          // Respond with NIP-42 signed AUTH (not EVENT)
          try {
            console.log('[NIP-42] Relay challenged with', challenge);
            const authEvent = {
              kind: 22242,
              created_at: Math.floor(Date.now() / 1000),
              tags: [ ['relay', sanitizeRelayUrl(relayUrl) ], ['challenge', challenge] ],
              content: '',
              pubkey: userPubkey
            };
            console.log('[NIP-42] Building 22242 for challenge', authEvent);
            let signedAuthEvent = null;
            if (window.nostr && typeof window.nostr.signEvent === 'function') {
              signedAuthEvent = await window.nostr.signEvent(authEvent);
              console.log('[NIP-42] Signed 22242 (challenge) id:', signedAuthEvent?.id, 'sig len:', signedAuthEvent?.sig?.length);
            }
            if (signedAuthEvent) {
              // Publish as EVENT so writePolicy 22242.sh can log it if allowed
              try {
                if (typeof nostrRelay.publish === 'function') {
                  console.log('[NIP-42] Publishing 22242 as EVENT (challenge)');
                  await nostrRelay.publish(signedAuthEvent);
                } else {
                  // Create dedicated WebSocket for challenge response
                  console.log('[NIP-42] Creating dedicated WebSocket for challenge EVENT');
                  const ws = new WebSocket(relayUrl);
                  
                  ws.onopen = () => {
                    console.log('[NIP-42] Challenge WebSocket connected, sending EVENT');
                    const eventMsg = JSON.stringify(['EVENT', signedAuthEvent]);
                    ws.send(eventMsg);
                    console.log('[NIP-42] Sent challenge EVENT via dedicated WebSocket');
                    ws.close();
                  };
                  
                  ws.onerror = (error) => {
                    console.error('[NIP-42] Challenge WebSocket error:', error);
                  };
                  
                  ws.onclose = () => {
                    console.log('[NIP-42] Challenge WebSocket closed');
                  };
                }
                 // Event already sent via dedicated WebSocket above
              } catch (e) { console.warn('[NIP-42] EVENT publish (challenge) failed', e); }
              authCompleted = true;
              authEventPublished = true;
              const loginBtn = document.getElementById('loginBtn');
              const authStatus = document.getElementById('authStatus');
              loginBtn.textContent = `Connecté: ${userPubkey.substring(0,6)}...${userPubkey.substring(userPubkey.length-4)}`;
              authStatus.textContent = 'NIP-42 autorisé. Prêt à jouer.';
              updateModeBadge();
              // Fetch profile now that we're fully connected
              fetchAndDisplayProfile(userPubkey).catch(console.warn);
              // Update mode badge after profile fetch
              setTimeout(() => updateModeBadge(), 1000);
            }
          } catch (e) {
            console.error('NIP-42 AUTH failed', e);
          }
        });
        await nostrRelay.connect();
        // Fallback: if relay does not require auth, enable UI after short delay
        setTimeout(() => {
          if (!authCompleted) {
            console.log('[NIP-42] No relay challenge; proactive AUTH/EVENT was attempted earlier');
            const loginBtn = document.getElementById('loginBtn');
            const authStatus = document.getElementById('authStatus');
            loginBtn.textContent = `Connecté: ${userPubkey.substring(0,6)}...${userPubkey.substring(userPubkey.length-4)}`;
            authStatus.textContent = 'Le relais n\'a pas demandé NIP-42. Prêt à jouer.';
            // Fetch profile now that we're fully connected
            fetchAndDisplayProfile(userPubkey).catch(console.warn);
            // No need to update mode badge again, it will be done in fetchAndDisplayProfile
          }
        }, 1500);
      } catch (e) {
        console.error('Failed to connect to relay', e);
      }
    }

    async function sendProactiveAuth(relayUrl) {
      try {
        if (!userPubkey || !nostrRelay || authEventPublished) return;
        const challenge = `client-init-${Date.now()}`;
        const authEvent = {
          kind: 22242,
          created_at: Math.floor(Date.now() / 1000),
          tags: [ ['relay', sanitizeRelayUrl(relayUrl) ], ['challenge', challenge] ],
          content: '',
          pubkey: userPubkey
        };
        console.log('[NIP-42] Proactive 22242 authEvent:', authEvent);
        let signedAuthEvent = null;
        if (window.nostr && typeof window.nostr.signEvent === 'function') {
          signedAuthEvent = await window.nostr.signEvent(authEvent);
        }
        if (!signedAuthEvent) { console.warn('[NIP-42] Proactive signEvent returned null'); return; }
        console.log('[NIP-42] Proactive signed id:', signedAuthEvent?.id, 'sig len:', signedAuthEvent?.sig?.length);
        // Publish as EVENT so server-side filter/22242.sh logs it
        try {
          if (typeof nostrRelay.publish === 'function') {
            console.log('[NIP-42] Proactive EVENT publish via relay.publish');
            await nostrRelay.publish(signedAuthEvent);
          }
          // Create dedicated WebSocket for NIP-42 event publishing
          console.log('[NIP-42] Creating dedicated WebSocket for event publishing');
          const ws = new WebSocket(relayUrl);
          
          ws.onopen = () => {
            console.log('[NIP-42] WebSocket connected, sending EVENT');
            const eventMsg = JSON.stringify(['EVENT', signedAuthEvent]);
            ws.send(eventMsg);
            console.log('[NIP-42] Sent EVENT via dedicated WebSocket');
            ws.close();
          };
          
          ws.onerror = (error) => {
            console.error('[NIP-42] WebSocket error:', error);
          };
          
          ws.onclose = () => {
            console.log('[NIP-42] Dedicated WebSocket closed');
          };
                      authCompleted = true;
            authEventPublished = true;
            const loginBtn = document.getElementById('loginBtn');
            const authStatus = document.getElementById('authStatus');
          loginBtn.textContent = `Connecté: ${userPubkey.substring(0,6)}...${userPubkey.substring(userPubkey.length-4)}`;
          authStatus.textContent = 'Événement NIP-42 envoyé. Récupération du profil...';
          // Fetch profile now that we're connected
          fetchAndDisplayProfile(userPubkey).catch(console.warn);
          // Update mode badge after profile fetch
          setTimeout(() => updateModeBadge(), 1000);
        } catch (e) { console.warn('EVENT 22242 publish failed', e); }
      } catch (e) { console.warn('sendProactiveAuth error', e); }
    }

    // Direct WebSocket fallback - create dedicated connection
    function tryDirectWebSocketSend(signedAuthEvent, kind = 'EVENT') {
      try {
        const relayUrl = sanitizeRelayUrl(NOSTRws || DEFAULT_RELAYS[0]);
        console.log('[NIP-42] Creating fallback WebSocket to:', relayUrl);
        
        const ws = new WebSocket(relayUrl);
        
        ws.onopen = () => {
          console.log('[NIP-42] Fallback WebSocket connected, sending', kind);
          const msg = JSON.stringify([kind === 'AUTH' ? 'AUTH' : 'EVENT', signedAuthEvent]);
          ws.send(msg);
          console.log('[NIP-42] Sent via fallback WebSocket:', msg.substring(0, 120) + '...');
          ws.close();
        };
        
        ws.onerror = (error) => {
          console.error('[NIP-42] Fallback WebSocket error:', error);
        };
        
        ws.onclose = () => {
          console.log('[NIP-42] Fallback WebSocket closed');
        };
      } catch (e) {
        console.error('tryDirectWebSocketSend failed', e);
      }
    }

    function sendViaWebSocket(ws, event, kind) {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.error('WebSocket not open for send');
        return;
      }
      const msg = JSON.stringify([kind === 'AUTH' ? 'AUTH' : 'EVENT', event]);
      ws.send(msg);
      console.log('Sent via direct WebSocket:', msg.substring(0, 120) + '...');
    }



    // Function to process winning payments
    async function processWinningPayment(amount, userPubkey) {
      if (!upassportUrl) detectUSPOTAPI();
      
      console.log('[Payment] Processing winning payment:', amount, 'ZEN from CAPTAIN to', userPubkey);
      console.log('[Payment] CAPTAIN data:', window.captainData);
      console.log('[Payment] User profile:', window.userProfile);
      
      try {
        const form = new FormData();
        form.append('zen', amount.toString());
        form.append('g1dest', userPubkey); // Send winnings TO the winner (player)
        form.append('npub', userPubkey); // Destination Nostr pubkey (player)
        
        // Use CAPTAIN's data as the SOURCE of payment
        if (window.captainData?.captainG1pub) {
          form.append('g1source', window.captainData.captainG1pub);
          console.log('[Payment] Using CAPTAIN G1PUB as source:', window.captainData.captainG1pub);
        }
        
        // Use CAPTAIN's Nostr pubkey as sender
        if (window.captainData?.captainHex) {
          form.append('npub_sender', window.captainData.captainHex);
          console.log('[Payment] Using CAPTAIN Nostr pubkey as sender:', window.captainData.captainHex);
        }
        
        // Use CAPTAIN's ZENCARD if available
        if (window.captainData?.captainZencardG1pub && window.captainData.captainZencardG1pub !== 'None') {
          form.append('zencard', window.captainData.captainZencardG1pub);
          console.log('[Payment] Using CAPTAIN ZENCARD:', window.captainData.captainZencardG1pub);
        } else {
          console.log('[Payment] No CAPTAIN ZENCARD available, using main wallet');
        }
        
        // Include player's G1PUB for destination identification
        if (window.userProfile?.g1pub) {
          form.append('g1pub', window.userProfile.g1pub);
          console.log('[Payment] Including player G1PUB for destination:', window.userProfile.g1pub);
        }
        
        console.log('[Payment] Form data prepared:', {
          zen: amount,
          g1dest: userPubkey,
          npub: userPubkey,
          g1source: window.captainData?.captainG1pub || 'none',
          npub_sender: window.captainData?.captainHex || 'none',
          zencard: window.captainData?.captainZencardG1pub || 'none',
          g1pub: window.userProfile?.g1pub || 'none'
        });
        
        console.log('[Payment] Sending winning payment request to:', `${upassportUrl}/zen_send`);
        const resp = await fetch(`${upassportUrl}/zen_send`, { method: 'POST', body: form, mode: 'cors' });
        
        console.log('[Payment] Response status:', resp.status, resp.statusText);
        console.log('[Payment] Response headers:', Object.fromEntries(resp.headers.entries()));
        
        if (!resp.ok) {
          console.error('[Payment] HTTP error:', resp.status, resp.statusText);
          const errorText = await resp.text();
          console.error('[Payment] Error response body:', errorText);
          return false;
        }
        
        const result = await resp.json();
        console.log('[Payment] API response:', result);
        
        if (result.ok && result.zen_send_result?.success) {
          console.log('[Payment] Payment successful:', result.zen_send_result.message);
          return true;
        } else {
          console.error('[Payment] Payment failed:', result.error || result.zen_send_result?.error || 'Unknown error');
          return false;
        }
      } catch (e) {
        console.error('[Payment] Payment error:', e);
        console.error('[Payment] Error stack:', e.stack);
        return false;
      }
    }

    // Function to extract URL parameters
    function getUrlParameter(name) {
      name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
      const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
      const results = regex.exec(location.search);
      return results === null ? '' : results[1];
    }

    const AstroID = getUrlParameter('qrcode') || "";
    const AstroPASS = getUrlParameter('pass') || "";
    const G1PUB = getUrlParameter('g1pub') || "";

    let isFlipping = false;
    let consecutiveHeads = 0; // 2⁰ = 1, 2¹ = 2, 2² = 4, 2³ = 8...
    let isFirstClick = true; // Track if this is the first click

    // Add event listener only if coin element exists
    const coinElement = document.getElementById('coin');
    if (coinElement) {
      coinElement.addEventListener('click', (event) => {
        // Check if user is on the correct Astroport for their MULTIPASS
        if (userPubkey && window.userProfile && window.userProfile.g1pub) {
          const currentHostname = window.location.hostname;
          // Allow Astroport domains and their IPFS gateways
          const isOnAstroport = currentHostname.includes('astroport.') || 
                                currentHostname.includes('127.0.0.1') || 
                                currentHostname.includes('localhost') ||
                                currentHostname.includes('copylaradio.com') || // Allow all copylaradio.com subdomains
                                currentHostname.includes('ipfs.') && currentHostname.includes('.com'); // Allow IPFS gateways
          
          console.log('[GAME] Astroport check:', {
            hostname: currentHostname,
            isOnAstroport: isOnAstroport,
            checks: {
              astroport: currentHostname.includes('astroport.'),
              localhost: currentHostname.includes('127.0.0.1') || currentHostname.includes('localhost'),
              copylaradio: currentHostname.includes('copylaradio.com'),
              ipfs: currentHostname.includes('ipfs.') && currentHostname.includes('.com')
            }
          });
          
          if (!isOnAstroport) {
            console.warn('[GAME] User with MULTIPASS trying to play outside Astroport');
            const messageEl = document.getElementById('message');
            if (messageEl) {
              messageEl.innerHTML = `<div class="win-display">
                <div class="win-label">⚠️ Astroport Requis</div>
                <div class="win-amount">MULTIPASS</div>
                <div class="win-currency">Seulement</div>
                <div class="win-status">Ce jeu ne peut être joué que sur l'Astroport où votre MULTIPASS est enregistré</div>
              </div>`;
            }
            return;
          }
        }
        
        if (!isFlipping) {

          isFlipping = true;
          
          // Note: Like to CAPTAIN will be sent only if TAILS (game loss) occurs
          console.log('[GAME] Coin flip initiated - like will be sent to CAPTAIN only if TAILS (loss)');
          
          // Show flipping message
          const messageEl = document.getElementById('message');
          const coinEl = document.getElementById('coin');
          
          if (!messageEl || !coinEl) {
            console.error('Required DOM elements not found');
            return;
          }
          
          messageEl.innerHTML = '<div class="flipping-display"><div class="flipping-icon">🪙</div><div class="flipping-text">Lancement de la pièce...</div></div>';
          coinEl.style.transform = 'rotateY(360deg)';
        setTimeout(() => {
          // Use cryptographically strong randomness instead of Math.random()
          const buf = new Uint32Array(1);
          (window.crypto || window.msCrypto).getRandomValues(buf);
          const result = (buf[0] & 1) === 0 ? 'Heads' : 'Tails';
          
          // Mark that this is no longer the first click
          isFirstClick = false;
          
            if (result === 'Heads') {
              consecutiveHeads++;
              if (coinEl) {
                coinEl.src = '/ipfs/QmZ6jrZGTWo4eimrGxu7BfKjYfRLqknb18WhmekNxppFg9';
              }
              
              // Calculate potential gain: 2⁰ = 1, 2¹ = 2, 2² = 4, 2³ = 8...
              // consecutiveHeads starts at 0, so first head = 2⁰ = 1, second head = 2¹ = 2, etc.
              let potentialGain = Math.pow(2, consecutiveHeads);
              
              console.log('[GAME] Heads result - consecutiveHeads:', consecutiveHeads, 'gain:', potentialGain, 'formula: 2^' + consecutiveHeads + ' = ' + potentialGain);
              
              const msgEl1 = document.getElementById('message');
              if (msgEl1) { 
                if (userPubkey && window.userProfile && window.userProfile.g1pub) {
                  msgEl1.innerHTML = `<div class="gain-display">
                    <div class="gain-amount">${potentialGain}</div>
                    <div class="gain-currency">ZEN</div>
                    <div class="gain-streak">Série : ${consecutiveHeads} PILE</div>
                    <div class="gain-next">Prochain PILE : ${Math.pow(2, consecutiveHeads + 1)} ZEN • FACE : tout perdre + envoyer 1 ẐEN au CAPITAINE</div>
                    <button class="cashout-btn" onclick="cashoutGains(${potentialGain})">💰 ENCAISSER</button>
                    <div class="practice-info">💡 Mode réel : Continuez pour doubler ou encaissez maintenant !</div>
                  </div>`;
                } else {
                  msgEl1.innerHTML = `<div class="gain-display">
                    <div class="gain-amount">${potentialGain}</div>
                    <div class="gain-currency">Ẑen</div>
                    <div class="gain-streak">Série : ${consecutiveHeads} PILE</div>
                    <div class="gain-next">Prochain PILE : ${Math.pow(2, consecutiveHeads + 1)} Ẑen • FACE : tout perdre + envoyer 1 Ẑen au CAPITAINE</div>
                    <button class="cashout-btn" onclick="cashoutGains(${potentialGain})">💰 ENCAISSER</button>
                    <div class="practice-info">💡 Mode entraînement : Continuez pour doubler ou encaissez maintenant !</div>
                  </div>`;
                }
              }

            } else {
             // St. Petersburg paradox: When TAILS appears, player loses everything and sends 1 ZEN to CAPTAIN
             // Send like to CAPTAIN (triggers 1 Ẑen payment FROM player TO captain)
             console.log('[GAME] Tails result - game ends, player loses cagnotte and sends 1 ZEN to CAPTAIN');
             
             // Send like to CAPTAIN (player pays 1 ZEN to captain)
             console.log('[GAME] TAILS - checking conditions for like sending:');
             console.log('[GAME] - userPubkey:', userPubkey ? userPubkey.substring(0, 8) + '...' : 'none');
             console.log('[GAME] - window.userProfile:', window.userProfile);
             console.log('[GAME] - window.captainData:', window.captainData);
             
             if (userPubkey && window.userProfile && window.userProfile.g1pub) {
               console.log('[GAME] Live mode: Sending like to CAPTAIN for TAILS (player pays 1 Ẑen to captain)');
               sendLikeToCaptain().then(success => {
                 if (success) {
                   console.log('[GAME] Like sent successfully, player paid 1 Ẑen to CAPTAIN');
                 } else {
                   console.warn('[GAME] Failed to send like to CAPTAIN');
                 }
               }).catch(error => {
                 console.error('[GAME] Error sending like to CAPTAIN:', error);
               });
             } else {
               console.log('[GAME] Practice mode: Like would be sent to CAPTAIN (player would pay 1 Ẑen to captain)');
               console.log('[GAME] Conditions not met for live mode like sending');
             }

                // STOP CLIC
                event.stopPropagation();
                event.preventDefault();

                        var info = document.getElementById("ainfo");
            if (userPubkey && window.userProfile && window.userProfile.g1pub) {
              // TAILS = Loss but with 1 ZEN compensation
              const msgEl2 = document.getElementById('message');
              if (msgEl2) { 
                msgEl2.innerHTML = `<div class="win-display" style="background: linear-gradient(135deg, #fecaca, #fca5a5); border-color: #ef4444;">
                  <div class="win-label">💔 FACE - JEU TERMINÉ 💔</div>
                  <div class="win-amount">1</div>
                  <div class="win-currency">ZEN</div>
                  <div class="win-status">Envoi du paiement au CAPITAINE...</div>
                  <div class="practice-info">Cagnotte perdue : ${Math.pow(2, consecutiveHeads)} ZEN • Paiement au CAPITAINE : 1 ZEN</div>
                </div>`; 
              }
              
              // No winning payment - just the 1 ZEN compensation from like
              setTimeout(() => {
                  if (msgEl2) {
                  msgEl2.innerHTML = `<div class="win-display" style="background: linear-gradient(135deg, #fecaca, #fca5a5); border-color: #ef4444;">
                    <div class="win-label">💔 TAILS - GAME OVER 💔</div>
                    <div class="win-amount">1</div>
                      <div class="win-currency">ZEN</div>
                    <div class="win-status success">✓ Paiement envoyé au CAPITAINE !</div>
                    <div class="practice-info">Cagnotte perdue : ${Math.pow(2, consecutiveHeads)} ZEN • Paiement au CAPITAINE : 1 ZEN</div>
                    </div>`;
                  }
              }, 2000);
                } else {
                // Practice mode: show simulated loss with compensation
                const msgEl3 = document.getElementById('message');
                if (msgEl3) { 
                  msgEl3.innerHTML = `<div class="win-display" style="background: linear-gradient(135deg, #fecaca, #fca5a5); border-color: #ef4444;">
                    <div class="win-label">💔 FACE - JEU TERMINÉ 💔</div>
                    <div class="win-amount">1</div>
                    <div class="win-currency">Ẑen</div>
                    <div class="win-status">Paiement (simulé)</div>
                    <div class="practice-info">Cagnotte perdue : ${Math.pow(2, consecutiveHeads)} Ẑen • Paiement au CAPITAINE : 1 Ẑen</div>
                  </div>`; 
                }
              }

                                                // Reset game state; game can continue immediately
                consecutiveHeads = 0;
                isFirstClick = true; // Reset to first click after game ends
                window.gameResetForLiveMode = false; // Allow game reset on next mode update
                updateModeBadge();
                
                // Reset message to initial state
                if (messageEl) {
                  messageEl.innerHTML = '<p>Cliquez sur la pièce pour la lancer.<br><small>💡 PILE = doubler la cagnotte, FACE = perdre la cagnotte et envoyer 1 ẐEN au CAPITAINE</small></p>';
                }
              if (coinEl) {
                coinEl.src = '/ipfs/QmeZhZ6yR6YHhiZ9qfBUCA1RKUP83dZL6MtU4PCBrdzjWn'; // Coin Pile Icon
              }

            }
          isFlipping = false;
          if (coinEl) {
            coinEl.style.transform = 'rotateY(0deg)';
          }
        }, 600); // Delay must match the transition time in CSS
        }
      });
    }

    // Wire up auth UI
    document.addEventListener('DOMContentLoaded', () => {
      console.log('[INIT] Page loaded, starting initialization sequence');
      detectUSPOTAPI();
      const loginBtn = document.getElementById('loginBtn');
      
      // Set initial message
      const messageEl = document.getElementById('message');
      if (messageEl) {
        messageEl.innerHTML = '<p>Cliquez sur la pièce pour la lancer.<br><small>💡 PILE = doubler la cagnotte, FACE = perdre la cagnotte et envoyer 1 ẐEN au CAPITAINE</small></p>';
      }
      
      // Fetch CAPTAIN data ONCE at page load (not related to user login)
      console.log('[INIT] Fetching CAPTAIN data once at page load');
      setTimeout(() => {
        if (!window.captainDataFetched) {
          fetchCaptainData().then(captainData => {
            if (captainData) {
              console.log('[CAPTAIN] Initial data fetched for display:', captainData);
              window.captainDataFetched = true;
            }
          }).catch(err => {
            console.warn('[CAPTAIN] Failed to fetch initial data:', err);
          });
        } else {
          console.log('[CAPTAIN] Data already fetched, skipping');
        }
      }, 1000); // Small delay to ensure API detection is complete
      
      // Check Nostr extension quickly
      setTimeout(() => {
        if (!window.nostr || typeof window.nostr.getPublicKey !== 'function') {
          loginBtn.disabled = true;
          loginBtn.textContent = 'Extension Nostr Requise';
        }
      }, 400);
      loginBtn.addEventListener('click', handleLogin);
    });
    
        // Function to process IPFS media links in text content
    function processIPFSMediaLinks(text) {
      if (!text) return text;
      
      console.log('[IPFS] Processing text for media links:', text.substring(0, 100) + '...');
      
      // Replace line breaks with <br> tags to preserve formatting
      let processedText = text.replace(/\n/g, '<br>');
      
      // Get current IPFS gateway from page URL
      const currentUrl = window.location.href;
      const url = new URL(currentUrl);
      let baseUrl = `${url.protocol}//${url.hostname}`;
      if (url.port && url.port !== '80' && url.port !== '443') {
        baseUrl += `:${url.port}`;
      }
      
      console.log('[IPFS] Base URL for gateway replacement:', baseUrl);
      
      // Use a single regex to match all IPFS links and process them in order of specificity
      
      // Find all IPFS links first
      const ipfsLinks = [];
      const ipfsRegex = /(https?:\/\/[^\s<>"{}|\\^`[\]]+\/ipfs\/[^\s<>"{}|\\^`[\]]+)/gi;
      let match;
      
      while ((match = ipfsRegex.exec(text)) !== null) {
        ipfsLinks.push({
          fullMatch: match[0],
          url: match[1],
          startIndex: match.index,
          endIndex: match.index + match[0].length
        });
      }
      
      console.log('[IPFS] Found IPFS links:', ipfsLinks.length);
      
      // Sort links by specificity (media files first, then regular links)
      ipfsLinks.sort((a, b) => {
        const aIsMedia = /\.(mp4|webm|ogg|mov|avi|mkv|mp3|wav|flac|aac|m4a|jpg|jpeg|png|gif|webp|svg|bmp|ico)$/i.test(a.url);
        const bIsMedia = /\.(mp4|webm|ogg|mov|avi|mkv|mp3|wav|flac|aac|m4a|jpg|jpeg|png|gif|webp|svg|bmp|ico)$/i.test(b.url);
        
        if (aIsMedia && !bIsMedia) return -1;
        if (!aIsMedia && bIsMedia) return 1;
        return 0;
      });
      
      // Process links from most specific to least specific
      const processedUrls = new Set();
      
      for (const link of ipfsLinks) {
        if (processedUrls.has(link.url)) {
          console.log('[IPFS] URL already processed, skipping:', link.url);
          continue;
        }
        
        console.log('[IPFS] Processing link:', link.url);
        processedUrls.add(link.url);
        
        // Convert gateway
        const newUrl = link.url.replace(/(https?:\/\/)[^\/]+(\/ipfs\/)/, `${baseUrl}/ipfs/`);
        console.log('[IPFS] Converted to:', newUrl);
        
        // Determine replacement based on file type
        let replacement;
        if (/\.(mp4|webm|ogg|mov|avi|mkv)$/i.test(link.url)) {
          const ext = link.url.split('.').pop().toLowerCase();
          replacement = `<video controls style="max-width: 150px; max-height: 150px; border-radius: 8px; margin: 4px;" preload="metadata">
            <source src="${newUrl}" type="video/${ext}">
            Your browser does not support the video tag.
          </video>`;
          console.log('[IPFS] Replaced with video element');
        } else if (/\.(mp3|wav|ogg|flac|aac|m4a)$/i.test(link.url)) {
          const ext = link.url.split('.').pop().toLowerCase();
          replacement = `<audio controls style="max-width: 150px; margin: 4px;" preload="metadata">
            <source src="${newUrl}" type="audio/${ext}">
            Your browser does not support the audio tag.
          </audio>`;
          console.log('[IPFS] Replaced with audio element');
        } else if (/\.(jpg|jpeg|png|gif|webp|svg|bmp|ico)$/i.test(link.url)) {
          replacement = `<img src="${newUrl}" alt="Image" style="max-width: 150px; max-height: 150px; border-radius: 8px; margin: 4px; cursor: pointer;" onclick="openImageModal('${newUrl}')" title="Click to enlarge">`;
          console.log('[IPFS] Replaced with image element');
        } else {
          replacement = `<a href="${newUrl}" target="_blank" rel="noopener noreferrer" style="color: #0ea5e9; text-decoration: none;">${newUrl}</a>`;
          console.log('[IPFS] Replaced with link element');
        }
        
        // Replace in text
        processedText = processedText.replace(link.fullMatch, replacement);
      }
      
      console.log('[IPFS] Final processed text:', processedText.substring(0, 200) + '...');
      console.log('[IPFS] Processed URLs count:', processedUrls.size);
      return processedText;
    }
    
    // Function to open image in modal
    function openImageModal(imageUrl) {
      // Create modal if it doesn't exist
      let modal = document.getElementById('imageModal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'imageModal';
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          display: none;
          justify-content: center;
          align-items: center;
          z-index: 10000;
          cursor: pointer;
        `;
        
        modal.innerHTML = `
          <img src="" alt="Full size image" style="max-width: 90%; max-height: 90%; object-fit: contain; border-radius: 8px;">
        `;
        
        document.body.appendChild(modal);
        
        // Close modal on click
        modal.addEventListener('click', () => {
          modal.style.display = 'none';
        });
      }
      
      // Set image source and show modal
      const img = modal.querySelector('img');
      img.src = imageUrl;
      modal.style.display = 'flex';
    }
  </script>

</body>
</html>

