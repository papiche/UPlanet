<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>♥️BOX Nostr Terminal</title>
    <style>
        @import url('./fonts.css');

        :root {
            --terminal-bg: #0a0a12;
            --terminal-green: #0f0;
            --terminal-cyan: #0ff;
            --terminal-purple: #b19cd9;
            --terminal-red: #f44;
            --terminal-glow: rgba(0, 255, 0, 0.7);
            --terminal-border: #333;
            --text-color: #e0e0e0;
            --text-shadow: 0 0 8px var(--terminal-glow);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Inconsolata', monospace;
            display: flex;
            flex-direction: column; /* Allow buttons below terminal */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            perspective: 1000px;
        }

        .matrix-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.15;
        }

        .terminal-container {
            position: relative;
            width: 85%;
            max-width: 800px;
            height: 65vh; /* Adjusted height */
            background: var(--terminal-bg);
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5),
                        inset 0 0 10px rgba(0, 255, 0, 0.2);
            overflow: hidden;
            border: 1px solid var(--terminal-green);
            transform-style: preserve-3d;
            animation: float 8s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0) rotateX(10deg) rotateY(5deg);
            }
            50% {
                transform: translateY(-15px) rotateX(5deg) rotateY(10deg);
            }
        }

        .terminal-header {
            background: linear-gradient(to right, #0a0a0a, #111);
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--terminal-green);
            font-family: 'Share Tech Mono', monospace;
            border-bottom: 1px solid var(--terminal-green);
            box-shadow: 0 2px 15px rgba(0, 255, 0, 0.3);
        }

        .terminal-buttons {
            display: flex;
            gap: 8px;
        }

        .terminal-button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .terminal-button.red {
            background: #ff5f56;
        }

        .terminal-button.yellow {
            background: #ffbd2e;
        }

        .terminal-button.green {
            background: #27c93f;
        }

        .terminal-body {
            padding: 15px;
            height: calc(100% - 40px); /* height of header */
            overflow-y: auto;
            color: var(--text-color);
            text-shadow: var(--text-shadow);
            line-height: 1.6;
            font-size: 0.9rem;
        }

        .terminal-body::-webkit-scrollbar {
            width: 8px;
        }
        .terminal-body::-webkit-scrollbar-track {
            background: var(--terminal-bg);
        }
        .terminal-body::-webkit-scrollbar-thumb {
            background-color: var(--terminal-green);
            border-radius: 4px;
            border: 1px solid var(--terminal-bg);
        }


        .glitch {
            position: relative;
        }

        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--terminal-bg); /* Match terminal background */
        }

        .glitch::before {
            left: 2px;
            text-shadow: -2px 0 var(--terminal-red);
            clip: rect(24px, 550px, 90px, 0);
            animation: glitch-anim-1 2s infinite linear alternate-reverse;
        }

        .glitch::after {
            left: -2px;
            text-shadow: -2px 0 var(--terminal-cyan);
            clip: rect(85px, 550px, 140px, 0);
            animation: glitch-anim-2 2s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim-1 {
            0% { clip: rect(54px, 800px, 54px, 0); } 20% { clip: rect(27px, 800px, 86px, 0); }
            40% { clip: rect(14px, 800px, 75px, 0); } 60% { clip: rect(39px, 800px, 104px, 0); }
            80% { clip: rect(18px, 800px, 53px, 0); } 100% { clip: rect(73px, 800px, 112px, 0); }
        }
        @keyframes glitch-anim-2 {
            0% { clip: rect(35px, 800px, 89px, 0); } 20% { clip: rect(56px, 800px, 103px, 0); }
            40% { clip: rect(22px, 800px, 64px, 0); } 60% { clip: rect(88px, 800px, 120px, 0); }
            80% { clip: rect(13px, 800px, 32px, 0); } 100% { clip: rect(42px, 800px, 99px, 0); }
        }

        .profile-pic {
            max-width: 80px;
            max-height: 80px;
            border-radius: 50%;
            border: 2px solid var(--terminal-cyan);
            margin-bottom: 10px;
            float: right; /* Or left */
            margin-left: 10px;
        }

        .nostr-entry {
            border: 1px dashed var(--terminal-border);
            padding: 10px;
            margin-bottom: 15px;
            background-color: rgba(0, 255, 0, 0.03); /* Slight green tint */
        }
        .nostr-entry h3 {
            color: var(--terminal-purple);
            font-family: 'Share Tech Mono', monospace;
            margin-top: 0;
        }
        .nostr-entry .pubkey {
            color: var(--terminal-red);
            font-size: 0.8em;
            word-break: break-all;
            margin-bottom: 5px;
        }
        .nostr-entry .message-content {
            color: var(--text-color);
            white-space: pre-wrap; /* Preserve formatting in messages */
            margin-top: 5px;
            border-left: 2px solid var(--terminal-green);
            padding-left: 8px;
        }
        .nostr-entry .message-date {
            color: var(--terminal-cyan);
            font-size: 0.8em;
            margin-top: 8px;
        }
         .nostr-entry .profile-about {
            font-style: italic;
            color: #aaa; /* Lighter color for about text */
            margin-bottom: 10px;
        }
        .nav-status {
            color: var(--terminal-cyan);
            font-family: 'Share Tech Mono', monospace;
            margin-bottom: 10px;
            text-align: center;
        }

        .navigation-controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .nav-button {
            background-color: var(--terminal-green);
            color: var(--terminal-bg);
            border: 1px solid var(--terminal-green);
            padding: 8px 15px;
            font-family: 'Share Tech Mono', monospace;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            box-shadow: 0 0 5px var(--terminal-glow);
        }
        .nav-button:hover {
            background-color: var(--terminal-cyan);
            color: var(--terminal-bg);
            box-shadow: 0 0 10px var(--terminal-cyan);
        }
        .nav-button:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
        }
        canvas { display: block; } /* For matrix */

        /* Enhanced message/media rendering */
        .media-container { margin-top: 8px; }
        .message-image {
            max-width: 150px;
            height: auto;
            border: 1px solid var(--terminal-border);
            border-radius: 4px;
            display: block;
        }
        .message-video, .message-audio {
            max-width: 200px;
            height: auto;
            border: 1px solid var(--terminal-border);
            border-radius: 4px;
            display: block;
        }
        .media-link { display: inline-block; font-size: 0.85em; margin-top: 4px; color: var(--terminal-cyan); }
        .diagnostic { margin: 8px 0; padding: 8px; border: 1px dashed var(--terminal-border); font-family: 'Share Tech Mono', monospace; }
        .diagnostic.ok { color: var(--terminal-green); }
        .diagnostic.warn { color: #ffc107; }
        .diagnostic.err { color: var(--terminal-red); }
    </style>
</head>
<body>
    <canvas id="matrix" class="matrix-background"></canvas>

    <div class="terminal-container">
        <div class="terminal-header">
            <div class="terminal-buttons">
                <div class="terminal-button red"></div>
                <div class="terminal-button yellow"></div>
                <div class="terminal-button green"></div>
            </div>
            <div class="glitch" data-text="♥️BOX Nostr Stream:~">♥BOX Nostr Stream:~</div>
            <div class="terminal-buttons">
                <div style="width: 20px;"></div> <!-- Spacer -->
            </div>
        </div>
        <div class="terminal-body" id="terminal-body">
            <div id="initial-typing-text" style="white-space: pre-wrap;"></div>
            <div id="nostr-content-area">
                <!-- Nostr data will be injected here -->
            </div>
        </div>
    </div>

    <div class="navigation-controls">
        <button id="prev-key-btn" class="nav-button">Prev Key</button>
        <button id="next-key-btn" class="nav-button">Next Key</button>
        <span style="color:var(--terminal-border); margin: 0 10px;">|</span>
        <button id="prev-msg-btn" class="nav-button">Newer Msg</button>
        <button id="next-msg-btn" class="nav-button">Older Msg</button>
    </div>
    <div id="nav-status-text" class="nav-status" style="margin-top:10px;">Key 0/0 | Msg 0/0</div>

    <script src="nostr.js"></script>
    <script>
        // Matrix effect (from your example)
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const alphabet = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~01';
        const fontSize = 16;
        const columns = canvas.width / fontSize;
        const rainDrops = Array(Math.floor(columns)).fill(1);

        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f0'; // Terminal green
            ctx.font = fontSize + 'px monospace';
            for (let i = 0; i < rainDrops.length; i++) {
                const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                ctx.fillText(text, i * fontSize, rainDrops[i] * fontSize);
                if (rainDrops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    rainDrops[i] = 0;
                }
                rainDrops[i]++;
            }
            requestAnimationFrame(drawMatrix);
        }

        // Initial Terminal Typing Effect
        const initialTypingTextElement = document.getElementById('initial-typing-text');
        const nostrContentArea = document.getElementById('nostr-content-area');

        function logProgress(text, style) {
            const span = document.createElement('span');
            span.textContent = (initialTypingTextElement.textContent ? "\n" : "") + text;
            if (style) span.style = style;
            initialTypingTextElement.appendChild(span);
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // --- Main Application Logic ---
        let uPlanetDataGlobal = null;
        let allNostrKeys = [];
        let currentKeyIndex = 0;
        let nostrDataCache = {}; // { pubkey: { profile: {}, messages: [], currentMessageIndex: 0 } }
        let relayUrl = ''; // To be set from data.json or default
        let upassportUrl = '';
        let derivedRelayUrl = '';

        let userInteracted = false; // Flag to track user interaction
        let autoRefreshInterval;    // Variable to hold the interval ID

        const prevKeyBtn = document.getElementById('prev-key-btn');
        const nextKeyBtn = document.getElementById('next-key-btn');
        const prevMsgBtn = document.getElementById('prev-msg-btn');
        const nextMsgBtn = document.getElementById('next-msg-btn');
        const navStatusText = document.getElementById('nav-status-text');

        // ---------- Utilities: safe escaping ----------
        function escapeHtml(text) {
            if (typeof text !== 'string') return '';
            return text.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;');
        }

        // ---------- bech32 helpers (for npub/nprofile detection) ----------
        function bech32Polymod(values) {
            const GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
            let chk = 1;
            for (let p = 0; p < values.length; ++p) {
                const top = chk >>> 25;
                chk = (chk & 0x1ffffff) << 5 ^ values[p];
                for (let i = 0; i < 5; ++i) {
                    chk ^= ((top >>> i) & 1) ? GENERATORS[i] : 0;
                }
            }
            return chk;
        }
        function bech32HrpExpand(hrp) {
            const ret = [];
            for (let p = 0; p < hrp.length; ++p) ret.push(hrp.charCodeAt(p) >>> 5);
            ret.push(0);
            for (let p = 0; p < hrp.length; ++p) ret.push(hrp.charCodeAt(p) & 31);
            return ret;
        }
        function bech32CharToVal(c) {
            const v = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'.indexOf(c);
            return v;
        }
        function bech32Decode(str) {
            const lower = str.toLowerCase();
            if (lower !== str && str.toUpperCase() !== str) return null;
            str = lower;
            const pos = str.lastIndexOf('1');
            if (pos < 1 || pos + 7 > str.length) return null;
            const hrp = str.substring(0, pos);
            const data = [];
            for (let p = pos + 1; p < str.length; ++p) {
                const c = bech32CharToVal(str.charAt(p));
                if (c === -1) return null;
                data.push(c);
            }
            if (bech32Polymod(bech32HrpExpand(hrp).concat(data)) !== 1) return null;
            return { hrp, data: data.slice(0, -6) };
        }
        function convertBits(data, fromBits, toBits, pad) {
            let acc = 0;
            let bits = 0;
            const ret = [];
            const maxv = (1 << toBits) - 1;
            const maxAcc = (1 << (fromBits + toBits - 1)) - 1;
            for (let p = 0; p < data.length; ++p) {
                const value = data[p];
                if (value < 0 || (value >>> fromBits) !== 0) return null;
                acc = ((acc << fromBits) | value) & maxAcc;
                bits += fromBits;
                while (bits >= toBits) {
                    bits -= toBits;
                    ret.push((acc >>> bits) & maxv);
                }
            }
            if (pad) {
                if (bits > 0) ret.push((acc << (toBits - bits)) & maxv);
            } else if (bits >= fromBits || ((acc << (toBits - bits)) & maxv)) {
                return null;
            }
            return ret;
        }

        // ---------- nprofile → hex decoder ----------
        function nprofileToHex(nprofile) {
            try {
                const decoded = bech32Decode(nprofile);
                if (!decoded || decoded.hrp !== 'nprofile') return null;
                const bytes = convertBits(decoded.data, 5, 8, false);
                if (!bytes || bytes.length === 0) return null;
                let i = 0;
                while (i < bytes.length) {
                    if (i + 1 >= bytes.length) break;
                    const type = bytes[i];
                    const length = bytes[i + 1];
                    if (i + 2 + length > bytes.length) break;
                    if (type === 0 && length === 32) {
                        const pubkey = bytes.slice(i + 2, i + 2 + length);
                        return Array.from(pubkey, b => b.toString(16).padStart(2, '0')).join('');
                    }
                    i += 2 + length;
                }
                return null;
            } catch (e) {
                return null;
            }
        }

        // ---------- Linkification and media rendering ----------
        function processMediaLink(url) {
            const u = url.toLowerCase();
            if (u.match(/\.(jpg|jpeg|png|gif|webp|svg|bmp|ico)(\?.*)?$/)) {
                return `<div class="media-container">
                    <img src="${url}" alt="Image" class="message-image">
                    <a class="media-link" href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>
                </div>`;
            } else if (u.match(/\.(mp4|webm|ogg|mov|avi|mkv)(\?.*)?$/)) {
                const type = `video/${u.split('.').pop().split('?')[0]}`;
                return `<div class="media-container">
                    <video controls class="message-video" preload="metadata">
                        <source src="${url}" type="${type}">
                    </video>
                    <a class="media-link" href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>
                </div>`;
            } else if (u.match(/\.(mp3|wav|ogg|flac|aac|m4a)(\?.*)?$/)) {
                const type = `audio/${u.split('.').pop().split('?')[0]}`;
                return `<div class="media-container">
                    <audio controls class="message-audio" preload="metadata">
                        <source src="${url}" type="${type}">
                    </audio>
                    <a class="media-link" href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>
                </div>`;
            }
            return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
        }

        function makeLinksClickable(text) {
            if (typeof text !== 'string') return '';
            // Escape first
            let safe = escapeHtml(text);
            const urlRegex = /(https?:\/\/[^\s<>"{}|\\^`\[\]]+)/gi;
            const nprofileRegex = /(nostr:)?(nprofile1[a-z0-9]+)/gi;
            const npubRegex = /(nostr:)?(npub1[a-z0-9]+)/gi;

            // URLs to media or links
            safe = safe.replace(urlRegex, (m) => processMediaLink(m));

            // nprofile → link to profile viewer
            safe = safe.replace(nprofileRegex, (match, _pre, np) => {
                const hex = nprofileToHex(np);
                if (hex) {
                    return `<a href="./nostr_profile_viewer.html?hex=${hex}" target="_blank" rel="noopener noreferrer">${match}</a>`;
                }
                return match;
            });

            // npub → hex and link to viewer if possible
            safe = safe.replace(npubRegex, (match, _pre, npub) => {
                try {
                    const dec = bech32Decode(npub);
                    if (dec && dec.hrp === 'npub') {
                        const bytes = convertBits(dec.data, 5, 8, false);
                        if (bytes && bytes.length === 32) {
                            const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
                            return `<a href="./nostr_profile_viewer.html?hex=${hex}" target="_blank" rel="noopener noreferrer">${match}</a>`;
                        }
                    }
                } catch (_) {}
                return match;
            });

            return safe;
        }

        // ---------- Diagnostics UI ----------
        function appendDiagnostic(message, cls) {
            const div = document.createElement('div');
            div.className = `diagnostic ${cls || ''}`;
            div.textContent = message;
            nostrContentArea.prepend(div);
        }

        function checkNostrExtension() {
            const available = typeof window.nostr !== 'undefined';
            const hasGetPk = available && typeof window.nostr.getPublicKey === 'function';
            const hasSign = available && typeof window.nostr.signEvent === 'function';
            if (available && hasGetPk && hasSign) {
                appendDiagnostic('NOSTR extension detected and ready.', 'ok');
            } else if (available) {
                appendDiagnostic('NOSTR extension partially available.', 'warn');
            } else {
                appendDiagnostic('NOSTR extension not detected.', 'err');
            }
            return { available, hasGetPk, hasSign };
        }

        async function testRelayConnection(nostrRelayUrl) {
            try {
                const relay = nostrTools.relayInit(nostrRelayUrl);
                relay.on('connect', () => appendDiagnostic(`Connected to relay: ${nostrRelayUrl}`, 'ok'));
                relay.on('error', (e) => appendDiagnostic(`Relay error: ${e?.message || e}`, 'err'));
                relay.on('auth', async (challenge) => {
                    try {
                        const pub = (typeof window.nostr !== 'undefined' && typeof window.nostr.getPublicKey === 'function') ? await window.nostr.getPublicKey() : '';
                        if (!pub) return;
                        const authEvent = {
                            kind: 22242,
                            created_at: Math.floor(Date.now() / 1000),
                            tags: [ ['relay', nostrRelayUrl], ['challenge', challenge || ''] ],
                            content: '',
                            pubkey: pub
                        };
                        const signed = await window.nostr.signEvent(authEvent);
                        await relay.publish(signed);
                        appendDiagnostic('NIP-42 auth event sent.', 'ok');
                    } catch (err) {
                        appendDiagnostic(`NIP-42 auth failed: ${err?.message || err}`, 'err');
                    }
                });
                await relay.connect();
                // Briefly keep connection, then close
                setTimeout(() => { try { relay.close(); } catch(_){} }, 1000);
            } catch (e) {
                appendDiagnostic(`Failed to connect relay: ${nostrRelayUrl}`, 'err');
            }
        }

        // ---------- uSPOT / Relay detection and tests ----------
        function detectUSPOTAPI() {
            const currentURL = new URL(window.location.href);
            const hostname = currentURL.hostname;
            const port = currentURL.port;
            const protocol = currentURL.protocol.split(":")[0];

            if (hostname === "127.0.0.1" && port === "8080") {
                upassportUrl = `http://127.0.0.1:54321`;
                derivedRelayUrl = `ws://127.0.0.1:7777`;
            } else if (hostname.startsWith("ipfs.")) {
                const baseDomain = hostname.substring("ipfs.".length);
                upassportUrl = `${protocol}://u.${baseDomain}`;
                derivedRelayUrl = `wss://relay.${baseDomain}`;
            } else {
                upassportUrl = `https://u.copylaradio.com`;
                derivedRelayUrl = `wss://relay.copylaradio.com`;
            }
            return { upassportUrl, derivedRelayUrl };
        }

        async function testUSPOTConnection() {
            try {
                const res = await fetch(`${upassportUrl}/health`);
                if (res.ok) {
                    const data = await res.json().catch(() => ({}));
                    logProgress(`uSPOT reachable: ${upassportUrl}`, 'color: var(--terminal-green)');
                    return { ok: true, data };
                }
                logProgress(`uSPOT error HTTP ${res.status}`, 'color: var(--terminal-red)');
                return { ok: false };
            } catch (e) {
                logProgress(`uSPOT connection failed: ${e?.message || e}`, 'color: var(--terminal-red)');
                return { ok: false, error: e };
            }
        }

        // ---------- Orchestrate real boot sequence ----------
        async function runBootSequence() {
            // Keep initialTypingTextElement visible as a live log
            nostrContentArea.style.display = 'block';

            logProgress('Booting UPlanet Nostr Stream OS...', 'color: var(--terminal-purple)');
            logProgress('Detecting environment...');
            const det = detectUSPOTAPI();
            logProgress(`Calculated uSPOT: ${det.upassportUrl}`);
            await sleep(1000);
            logProgress(`Calculated wsRELAY: ${det.derivedRelayUrl}`);
            await sleep(1000);

            const ext = checkNostrExtension();
            if (ext.available) {
                logProgress('NOSTR extension detected.', 'color: var(--terminal-green)');
            } else {
                logProgress('NOSTR extension not detected.', 'color: var(--terminal-yellow)');
            }
            await sleep(1000);

            logProgress('[INFO] Fetching planetary entity map...');
            // Start stream (will compute final relayUrl from data or fallback)
            await startNostrStreamWithProgress();

            // After we know relayUrl, test connections
            logProgress('Testing uSPOT connectivity...');
            await testUSPOTConnection();
            await sleep(1000);
            logProgress('Testing relay connectivity (NIP-42 if required)...');
            await testRelayConnection(relayUrl || derivedRelayUrl);
            await sleep(1000);

            logProgress('SYSTEM READY. STREAMING NOSTR DATA...', 'font-weight: bold; color: var(--terminal-green)');
            // Clear boot log after a short pause, then show profiles area only
            await sleep(1000);
            initialTypingTextElement.textContent = '';
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                // console.log("Auto-refresh stopped.");
            }
        }

        function startAutoRefresh() {
            stopAutoRefresh(); // Clear any existing one first
            if (!userInteracted && allNostrKeys.length > 0) {
                // console.log("Auto-refresh started.");
                autoRefreshInterval = setInterval(() => {
                    let nextIndex = currentKeyIndex + 1;
                    if (nextIndex >= allNostrKeys.length) {
                        nextIndex = 0; // Loop to start
                    }
                    navigateKey(nextIndex, true); // Pass the target index and isAuto=true
                }, 3000);
            }
        }


        async function getUPlanetRelayURL(uPlanetData) {
            if (uPlanetData && uPlanetData.myRELAY) {
                return uPlanetData.myRELAY;
            }
            const currentUrl = new URL(window.location.href);
            let relayName = currentUrl.hostname.replace('ipfs.', 'relay.');
            if (currentUrl.port === '8080' || currentUrl.port) {
                return `ws://127.0.0.1:7777`;
            }
            return `wss://${relayName}`;
        }

        async function loadUPlanetData(apiUrl) {
            try {
                const response = await fetch(apiUrl); // Assuming apiUrl is the full path to UStat json
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Failed to load uPlanetData:", error);
                nostrContentArea.innerHTML = `<p style="color:var(--terminal-red)">Error loading uPlanetData from ${apiUrl}. Check console.</p>`;
                return null;
            }
        }

        function extractNostrKeys(data) {
            const keys = new Set();
            if (data.PLAYERs) {
                data.PLAYERs.forEach(player => player.HEX && player.HEX !== "null" && keys.add(player.HEX));
            }
            if (data.UMAPs) {
                data.UMAPs.forEach(umap => umap.UMAPHEX && keys.add(umap.UMAPHEX));
            }
             if (data.NOSTR) {
                data.NOSTR.forEach(item => item.HEX && item.HEX !== "null" && keys.add(item.HEX));
            }
            return Array.from(keys);
        }

        async function fetchNostrProfile(pubkey, nostrRelayUrl) {
            if (nostrDataCache[pubkey] && nostrDataCache[pubkey].profile) {
                return nostrDataCache[pubkey].profile;
            }
            // console.log(`Fetching profile for ${pubkey} from ${nostrRelayUrl}`);
            try {
                const relay = nostrTools.relayInit(nostrRelayUrl);
                await relay.connect();
                const sub = relay.sub([{ kinds: [0], authors: [pubkey], limit: 1 }]);
                return new Promise((resolve, reject) => {
                    let profile = null;
                    const timeout = setTimeout(() => {
                        sub.unsub();
                        relay.close();
                        console.warn(`Timeout fetching profile for ${pubkey}`);
                        resolve({});
                    }, 3000);

                    sub.on('event', event => {
                        clearTimeout(timeout);
                        try {
                            profile = JSON.parse(event.content);
                        } catch (e) {
                            console.error(`Error parsing profile JSON for ${pubkey}:`, e, event.content);
                            profile = {}; // Fallback to empty profile on parse error
                        }
                        sub.unsub();
                        relay.close();
                        resolve(profile);
                    });
                    sub.on('eose', () => {
                        if (!profile) {
                           clearTimeout(timeout);
                           sub.unsub();
                           relay.close();
                           resolve({});
                        }
                    });
                     relay.on('error', (err) => {
                        clearTimeout(timeout);
                        sub.unsub();
                        try { relay.close(); } catch(e){}
                        console.error(`Relay error fetching profile for ${pubkey}:`, err);
                        reject(err); // Let displayCurrentKeyData handle the error message
                    });
                });
            } catch (error) {
                console.error(`Error fetching Nostr profile for ${pubkey}:`, error);
                return {}; // Fallback to empty profile
            }
        }

        async function fetchNostrMessages(pubkey, nostrRelayUrl, limit = 20) {
            // Do not use cache for messages if user explicitly navigates, to get potentially newer messages.
            // For auto-refresh, cache is fine. Let's keep it simple for now and always try to fetch.
            // OR: only bypass cache on manual refresh button (not implemented yet)
            // For now, let's keep the cache for messages as well for performance during auto-scroll.
            if (nostrDataCache[pubkey] && nostrDataCache[pubkey].messages) {
                nostrDataCache[pubkey].messages.sort((a, b) => b.created_at - a.created_at);
                return nostrDataCache[pubkey].messages;
            }
            // console.log(`Fetching messages for ${pubkey} from ${nostrRelayUrl}`);
            try {
                const relay = nostrTools.relayInit(nostrRelayUrl);
                await relay.connect();
                const sub = relay.sub([{ kinds: [1], authors: [pubkey], limit: limit }]);
                const messages = [];
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        sub.unsub();
                        relay.close();
                        console.warn(`Timeout fetching messages for ${pubkey}`);
                        resolve(messages.sort((a, b) => b.created_at - a.created_at));
                    }, 5000);

                    sub.on('event', event => {
                        messages.push(event);
                    });
                    sub.on('eose', () => {
                        clearTimeout(timeout);
                        sub.unsub();
                        relay.close();
                        resolve(messages.sort((a, b) => b.created_at - a.created_at));
                    });
                    relay.on('error', (err) => {
                        clearTimeout(timeout);
                        sub.unsub();
                        try { relay.close(); } catch(e){}
                        console.error(`Relay error fetching messages for ${pubkey}:`, err);
                        reject(err); // Let displayCurrentKeyData handle the error message
                    });
                });
            } catch (error) {
                console.error(`Error fetching Nostr messages for ${pubkey}:`, error);
                return [];
            }
        }

        async function navigateKey(targetIndex, isAuto = false) {
            if (!isAuto) {
                userInteracted = true;
                stopAutoRefresh();
            }

            if (allNostrKeys.length === 0) {
                currentKeyIndex = 0;
            } else if (isAuto) {
                currentKeyIndex = targetIndex; // Directly use the index decided by the auto-refresh logic
            } else { // Manual navigation, targetIndex is currentKeyIndex + direction (or specific index)
                if (targetIndex < 0) {
                    currentKeyIndex = 0;
                } else if (targetIndex >= allNostrKeys.length) {
                    currentKeyIndex = allNostrKeys.length - 1;
                } else {
                    currentKeyIndex = targetIndex;
                }
            }

            const currentActualKey = allNostrKeys[currentKeyIndex];
            if (currentActualKey && !nostrDataCache[currentActualKey]) {
                nostrDataCache[currentActualKey] = { profile: null, messages: null, currentMessageIndex: 0 };
            }
            await displayCurrentKeyData();
        }

        async function navigateMessage(direction) { // direction is -1 or 1
            userInteracted = true;
            stopAutoRefresh();

            const pubkey = allNostrKeys[currentKeyIndex];
            if (pubkey && nostrDataCache[pubkey] && nostrDataCache[pubkey].messages) {
                let msgIdx = nostrDataCache[pubkey].currentMessageIndex;
                const messages = nostrDataCache[pubkey].messages;

                msgIdx += direction;

                if (messages.length === 0) {
                    msgIdx = 0;
                } else {
                    if (msgIdx < 0) msgIdx = 0;
                    if (msgIdx >= messages.length) msgIdx = messages.length - 1;
                }

                nostrDataCache[pubkey].currentMessageIndex = msgIdx;
                await displayCurrentKeyData();
            }
        }


        async function displayCurrentKeyData() {
            if (allNostrKeys.length === 0) {
                nostrContentArea.innerHTML = `<p style="color:var(--terminal-yellow);">No Nostr keys found in uPlanetData.</p>`;
                updateNavStatus();
                updateButtonStates(null);
                return;
            }

            const pubkey = allNostrKeys[currentKeyIndex];
            nostrContentArea.innerHTML = `<p style="color:var(--terminal-cyan);">Loading data for ${pubkey.substring(0,10)}...</p>`;
            updateNavStatus(pubkey); // Update status early with current key
            updateButtonStates(pubkey); // Update button states early


            if (!nostrDataCache[pubkey]) { // Should be initialized by navigateKey
                nostrDataCache[pubkey] = { profile: null, messages: null, currentMessageIndex: 0 };
            }

            try {
                // Fetch profile if not cached or if forced refresh (not implemented yet)
                if (!nostrDataCache[pubkey].profile) {
                    nostrDataCache[pubkey].profile = await fetchNostrProfile(pubkey, relayUrl);
                }
                // Fetch messages if not cached or if forced refresh
                if (!nostrDataCache[pubkey].messages) {
                     nostrDataCache[pubkey].messages = await fetchNostrMessages(pubkey, relayUrl);
                }
            } catch (err) { // Catch errors from fetchNostrProfile/Messages
                 nostrContentArea.innerHTML = `<p style="color:var(--terminal-red);">Error fetching data for ${pubkey.substring(0,10)}... Relay might be unresponsive. Check console.</p>`;
                 updateNavStatus(pubkey); // Update status even on error
                 updateButtonStates(pubkey);
                 return;
            }


            const profile = nostrDataCache[pubkey].profile || {};
            const messages = nostrDataCache[pubkey].messages || [];
            let currentMessageIdx = nostrDataCache[pubkey].currentMessageIndex || 0;

            // Ensure currentMessageIdx is valid
            if (messages.length > 0) {
                if (currentMessageIdx < 0 || currentMessageIdx >= messages.length) {
                    currentMessageIdx = 0;
                    nostrDataCache[pubkey].currentMessageIndex = 0;
                }
            } else {
                currentMessageIdx = 0; // No messages, so index is 0 of 0
                 nostrDataCache[pubkey].currentMessageIndex = 0;
            }


            let html = `<div class="nostr-entry">`;
            html += `<h3>PROFILE: ${escapeHtml(profile.name || 'N/A')} ${profile.display_name ? '('+escapeHtml(profile.display_name)+')' : ''}</h3>`;
            html += `<p class="pubkey">Pubkey: ${pubkey}</p>`;
            if (profile.picture) {
                html += `<img src="${profile.picture}" alt="Profile Pic" class="profile-pic">`;
            }
            if (profile.about) {
                html += `<p class="profile-about"><em>${profile.about.replace(/</g, "<").replace(/>/g, ">")}</em></p>`;
            }
            html += `<div style="clear:both;"></div>`;

            if (messages.length > 0) {
                const message = messages[currentMessageIdx];
                html += `<h4>MESSAGE (${currentMessageIdx + 1}/${messages.length})</h4>`;
                const clickableContent = makeLinksClickable(message.content || '');
                html += `<div class="message-content">${clickableContent}</div>`;
                html += `<p class="message-date">Posted: ${new Date(message.created_at * 1000).toLocaleString()}</p>`;
                const repliedToEvents = message.tags.filter(t => t[0] === 'e' && t[1]).map(t => t[1]);
                if (repliedToEvents.length > 0) {
                    html += `<p style="font-size:0.8em; color: var(--terminal-yellow);">Replies to: ${repliedToEvents.map(e => e.substring(0,10)+'...').join(', ')}</p>`;
                }
            } else {
                html += `<p style="color:var(--terminal-yellow);">No messages found for this key on the relay.</p>`;
            }
            html += `</div>`;
            nostrContentArea.innerHTML = html;
            updateNavStatus(pubkey);
            updateButtonStates(pubkey);
        }

        function updateNavStatus(currentPubkey) {
            const totalKeys = allNostrKeys.length;
            const keyText = totalKeys > 0 ? `Key ${currentKeyIndex + 1}/${totalKeys}` : 'Key 0/0';

            let msgText = 'Msg 0/0';
            if (currentPubkey && nostrDataCache[currentPubkey] && nostrDataCache[currentPubkey].messages) {
                const messages = nostrDataCache[currentPubkey].messages;
                const currentMsgIdx = nostrDataCache[currentPubkey].currentMessageIndex; // Already validated
                if (messages.length > 0) {
                    msgText = `Msg ${currentMsgIdx + 1}/${messages.length}`;
                }
            }
            navStatusText.textContent = `${keyText} | ${msgText}`;
        }

        function updateButtonStates(pubkey) {
            prevKeyBtn.disabled = allNostrKeys.length === 0 || currentKeyIndex === 0;
            nextKeyBtn.disabled = allNostrKeys.length === 0 || currentKeyIndex >= allNostrKeys.length - 1;

            if (pubkey && nostrDataCache[pubkey] && nostrDataCache[pubkey].messages) {
                const messages = nostrDataCache[pubkey].messages;
                const currentMsgIdx = nostrDataCache[pubkey].currentMessageIndex; // Already validated
                prevMsgBtn.disabled = messages.length === 0 || currentMsgIdx === 0;
                nextMsgBtn.disabled = messages.length === 0 || currentMsgIdx >= messages.length - 1;
            } else {
                prevMsgBtn.disabled = true;
                nextMsgBtn.disabled = true;
            }
        }

        async function startNostrStreamWithProgress() {
            nostrContentArea.innerHTML = `<p style="color:var(--terminal-cyan);">Connecting to UPlanet Network...</p>`;

            const currentURL = new URL(window.location.href);
            const protocol = currentURL.protocol;
            const hostname = currentURL.hostname;
            let port = currentURL.port;

            var uHost = hostname.replace("ipfs.", "u.");
             if (port === "8080") {
                port = "54321";
            } else if (port) {
                 // keep port
            } else {
                port = "";
            }
            const uPlanetBase = protocol + "//" + uHost + (port ? (":" + port) : "");
            // Assuming data json is at the root of this uPlanetBase
            const uPlanetDataURL = uPlanetBase + '/'; // Construct full URL to get json
            console.log('UPLANET DATA URL:', uPlanetDataURL);
            logProgress(`[INFO] Loading uPlanetData from ${uPlanetDataURL}...`);
            uPlanetDataGlobal = await loadUPlanetData(uPlanetDataURL);

            if (uPlanetDataGlobal) {
                relayUrl = await getUPlanetRelayURL(uPlanetDataGlobal);
                console.log('Using Nostr Relay:', relayUrl);
                logProgress(`[OK] Entity map loaded. Using relay: ${relayUrl}`, 'color: var(--terminal-green)');

                allNostrKeys = extractNostrKeys(uPlanetDataGlobal);
                console.log('Extracted Nostr Keys:', allNostrKeys.length > 0 ? allNostrKeys : "None");

                if (allNostrKeys.length > 0) {
                    currentKeyIndex = 0; // Start with the first key
                    logProgress('Initializing Nostr Data Feed...');
                    await displayCurrentKeyData();
                    startAutoRefresh();
                } else {
                    nostrContentArea.innerHTML = `<p style="color:var(--terminal-yellow);">No Nostr keys found to stream.</p>`;
                    updateNavStatus(null);
                    updateButtonStates(null);
                }
            } else {
                 nostrContentArea.innerHTML = `<p style="color:var(--terminal-red);">Failed to load UPlanet data. Cannot start Nostr stream.</p>`;
                 updateNavStatus(null);
                 updateButtonStates(null);
            }
        }

        // Event Listeners for navigation
        prevKeyBtn.addEventListener('click', () => navigateKey(currentKeyIndex - 1, false));
        nextKeyBtn.addEventListener('click', () => navigateKey(currentKeyIndex + 1, false));
        prevMsgBtn.addEventListener('click', () => navigateMessage(-1));
        nextMsgBtn.addEventListener('click', () => navigateMessage(1));

        // Start animations and app
        window.addEventListener('load', function() {
            drawMatrix();
            runBootSequence();
        });

        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Recalculate columns for matrix if needed
            const newColumns = canvas.width / fontSize;
            while(rainDrops.length > newColumns) rainDrops.pop();
            while(rainDrops.length < newColumns) rainDrops.push(1);
        });

    </script>
</body>
</html>
