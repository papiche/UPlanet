<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Profile Viewer</title>
    <style>
        @import url('./fonts.css');

        :root {
            --terminal-bg: #0a0a12;
            --terminal-green: #0f0;
            --terminal-cyan: #0ff;
            --terminal-purple: #b19cd9;
            --terminal-red: #f44;
            --terminal-glow: rgba(0, 255, 0, 0.7);
            --terminal-border: #333;
            --text-color: #e0e0e0;
            --text-shadow: 0 0 8px var(--terminal-glow);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow-y: auto; /* Allow scrolling if content exceeds viewport */
            overflow-x: hidden;
            font-family: 'Inconsolata', monospace;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Align to top */
            align-items: center;
            min-height: 100vh;
            padding-top: 2rem; /* Add some padding at the top */
            perspective: 1000px;
        }

        .matrix-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.15;
        }

        .terminal-container {
            position: relative;
            width: 85%;
            max-width: 800px;
            /* height: auto; Let content define height */
            min-height: 70vh; /* Minimum height */
            background: var(--terminal-bg);
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5),
                        inset 0 0 10px rgba(0, 255, 0, 0.2);
            overflow: hidden;
            border: 1px solid var(--terminal-green);
            transform-style: preserve-3d;
            animation: float 8s ease-in-out infinite;
            margin-bottom: 2rem; /* Space at the bottom */
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0) rotateX(10deg) rotateY(5deg);
            }
            50% {
                transform: translateY(-15px) rotateX(5deg) rotateY(10deg);
            }
        }

        .terminal-header {
            background: linear-gradient(to right, #0a0a0a, #111);
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--terminal-green);
            font-family: 'Share Tech Mono', monospace;
            border-bottom: 1px solid var(--terminal-green);
            box-shadow: 0 2px 15px rgba(0, 255, 0, 0.3);
        }

        .terminal-buttons-group { /* Renamed to avoid conflict */
            display: flex;
            gap: 8px;
        }

        .terminal-button-ctrl { /* Renamed to avoid conflict */
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .terminal-button-ctrl.red { background: #ff5f56; }
        .terminal-button-ctrl.yellow { background: #ffbd2e; }
        .terminal-button-ctrl.green { background: #27c93f; }

        /* Make buttons clickable */
        .terminal-button-ctrl {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .terminal-button-ctrl:hover {
            transform: scale(1.2);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }
        .terminal-button-ctrl.red:hover {
            box-shadow: 0 0 8px rgba(255, 95, 86, 0.7);
        }
        .terminal-button-ctrl.yellow:hover {
            box-shadow: 0 0 8px rgba(255, 189, 46, 0.7);
        }
        .terminal-button-ctrl.green:hover {
            box-shadow: 0 0 8px rgba(39, 201, 63, 0.7);
        }

        .terminal-body {
            padding: 15px;
            height: calc(100% - 40px); /* Adjust if header height changes */
            overflow-y: auto;
            color: var(--text-color);
            text-shadow: var(--text-shadow);
            line-height: 1.6;
            font-size: 0.9rem;
        }

        .terminal-body::-webkit-scrollbar { width: 8px; }
        .terminal-body::-webkit-scrollbar-track { background: var(--terminal-bg); }
        .terminal-body::-webkit-scrollbar-thumb {
            background-color: var(--terminal-green);
            border-radius: 4px;
            border: 1px solid var(--terminal-bg);
        }

        .glitch { position: relative; }
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: var(--terminal-bg);
        }
        .glitch::before {
            left: 2px; text-shadow: -2px 0 var(--terminal-red);
            clip: rect(24px, 550px, 90px, 0);
            animation: glitch-anim-1 2s infinite linear alternate-reverse;
        }
        .glitch::after {
            left: -2px; text-shadow: -2px 0 var(--terminal-cyan);
            clip: rect(85px, 550px, 140px, 0);
            animation: glitch-anim-2 2s infinite linear alternate-reverse;
        }
        @keyframes glitch-anim-1 { /* ... (glitch keyframes from UPlanet Terminal) ... */
            0% { clip: rect(54px, 800px, 54px, 0); } 20% { clip: rect(27px, 800px, 86px, 0); }
            40% { clip: rect(14px, 800px, 75px, 0); } 60% { clip: rect(39px, 800px, 104px, 0); }
            80% { clip: rect(18px, 800px, 53px, 0); } 100% { clip: rect(73px, 800px, 112px, 0); }
        }
        @keyframes glitch-anim-2 { /* ... (glitch keyframes from UPlanet Terminal) ... */
            0% { clip: rect(35px, 800px, 89px, 0); } 20% { clip: rect(56px, 800px, 103px, 0); }
            40% { clip: rect(22px, 800px, 64px, 0); } 60% { clip: rect(88px, 800px, 120px, 0); }
            80% { clip: rect(13px, 800px, 32px, 0); } 100% { clip: rect(42px, 800px, 99px, 0); }
        }
        canvas { display: block; }

        /* Styles for Nostr Profile Content */
        .uplanet-logo-link {
            display: block;
            text-align: center;
            margin-bottom: 20px; /* Was in <center> before */
        }
        .uplanet-logo-link img {
             max-width: 150px; /* Adjust as needed */
             border: 2px solid var(--terminal-cyan);
             padding: 5px;
             background-color: var(--terminal-bg);
        }

        .profile {
            border-bottom: 1px dashed var(--terminal-border);
            padding-bottom: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        .profile h3 {
            color: var(--terminal-purple);
            font-family: 'Share Tech Mono', monospace;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.4em;
        }
        .profile p {
            color: var(--text-color);
            margin-bottom: 10px;
        }
        .profile-picture {
            max-width: 100px;
            border-radius: 50%;
            border: 2px solid var(--terminal-cyan);
            margin: 0 auto 10px auto; /* Center picture */
            display: block;
        }
        .profile.loading, .messages.loading {
            color: var(--terminal-cyan); /* Loading text color */
        }
        .profile.loading div, .messages.loading div{
            color: var(--terminal-cyan);
        }


        #follow-button-container {
            margin-top: 20px;
            text-align: center;
            margin-bottom: 20px;
        }
        #follow-button {
            background-color: var(--terminal-green);
            color: var(--terminal-bg);
            border: 1px solid var(--terminal-green);
            padding: 10px 20px;
            font-family: 'Share Tech Mono', monospace;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            box-shadow: 0 0 5px var(--terminal-glow);
            font-size: 1.1em;
        }
        #follow-button:hover {
            background-color: var(--terminal-cyan);
            color: var(--terminal-bg);
            box-shadow: 0 0 10px var(--terminal-cyan);
        }
        #follow-button:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
        }
        #follow-error-message {
            color: var(--terminal-red);
            margin-top: 10px;
            text-align: center;
            font-family: 'Share Tech Mono', monospace;
        }

        .messages h2 {
            color: var(--terminal-purple);
            font-family: 'Share Tech Mono', monospace;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.5em;
            border-bottom: 1px solid var(--terminal-green);
            padding-bottom: 5px;
        }
        .messages-scrollable {
            max-height: 350px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid var(--terminal-border);
            border-radius: 5px;
            padding: 10px;
            background-color: rgba(0,0,0, 0.1); /* Slightly darker than terminal-bg */
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
        }
        .message-item {
            display: flex;
            align-items: flex-start;
            border-bottom: 1px dotted var(--terminal-border);
            padding: 10px 0;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
            gap: 5px;
        }
        .message-item:last-child { border-bottom: none; }

        .message-item strong { /* Date/Time */
            display: block;
            margin-bottom: 5px;
            color: var(--terminal-cyan);
            font-size: 0.9em;
        }
        .message-item p { /* Message content */
            color: var(--text-color);
            margin: 0;
            line-height: 1.4;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }


        /* Loading text */
        #profile-content, #messages-content {
            color: var(--terminal-cyan);
        }
        #profile-content p, #messages-content p { /* Ensure p inside loading also gets color */
             color: var(--terminal-cyan);
        }

        /* Heart/Like button styles */
        .heart-button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            margin-right: 10px;
            margin-top: 5px;
            padding: 5px;
            transition: all 0.2s ease;
            color: var(--terminal-border);
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.3);
        }
        .heart-button:hover {
            color: var(--terminal-red);
            text-shadow: 0 0 5px var(--terminal-red);
            transform: scale(1.1);
        }
        .heart-button.liked {
            color: var(--terminal-red);
            text-shadow: 0 0 8px var(--terminal-red);
        }
        .heart-button.loading {
            color: var(--terminal-cyan);
            text-shadow: 0 0 5px var(--terminal-cyan);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Styles for clickable links in content */
        .terminal-body a {
            color: var(--terminal-cyan);
            text-decoration: underline;
            transition: all 0.2s ease;
            text-shadow: 0 0 3px rgba(0, 255, 255, 0.3);
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
            max-width: 100%;
        }
        .terminal-body a:hover {
            color: var(--terminal-green);
            text-shadow: 0 0 5px var(--terminal-glow);
        }
        .terminal-body a.nprofile-link {
            color: var(--terminal-purple);
            font-weight: bold;
            text-shadow: 0 0 3px rgba(177, 156, 217, 0.3);
        }
        .terminal-body a.nprofile-link:hover {
            color: var(--terminal-cyan);
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }

        /* Styles for media links */
        .media-container {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .media-link {
            color: var(--terminal-cyan);
            text-decoration: underline;
            font-size: 0.9em;
        }
        .message-image {
            max-width: 150px; /* Smaller image for message */
            height: auto;
            border: 1px solid var(--terminal-border);
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .message-image:hover {
            transform: scale(1.05);
        }
        .message-video, .message-audio {
            max-width: 150px; /* Smaller media for message */
            height: auto;
            border: 1px solid var(--terminal-border);
            border-radius: 4px;
        }

        /* Profile banner and picture styles */
        .profile-banner {
            width: 100%;
            height: 120px;
            background: linear-gradient(45deg, var(--terminal-cyan), var(--terminal-purple));
            border-radius: 8px 8px 0 0;
            margin-bottom: 10px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .profile-banner:hover {
            transform: scale(1.02);
        }
        .profile-banner img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px 8px 0 0;
        }
        .profile-banner.no-image {
            background: linear-gradient(45deg, var(--terminal-cyan), var(--terminal-purple));
        }
        
        .profile-picture-container {
            position: relative;
            display: inline-block;
            margin-bottom: 10px;
        }
        .profile-picture {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid var(--terminal-cyan);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            object-fit: cover;
        }
        .profile-picture:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        .profile-picture.no-image {
            background: linear-gradient(45deg, var(--terminal-purple), var(--terminal-cyan));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
        }

        /* Additional profile fields styles */
        .profile-additional-fields {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--terminal-cyan);
            border-radius: 6px;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .profile-field {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: rgba(0, 255, 255, 0.05);
            border-radius: 4px;
            border-left: 3px solid var(--terminal-cyan);
        }
        
        .profile-field strong {
            color: var(--terminal-cyan);
            font-weight: bold;
        }
        
        .profile-field a {
            color: var(--terminal-green);
            text-decoration: underline;
            transition: color 0.2s ease;
        }
        
        .profile-field a:hover {
            color: var(--terminal-cyan);
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }
        
        .balance-info {
            color: var(--terminal-green);
            font-weight: bold;
            font-size: 0.95em;
            background: rgba(0, 255, 0, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--terminal-green);
            margin-left: 8px;
        }
        
        .balance-info.na {
            color: var(--terminal-orange);
            background: rgba(255, 165, 0, 0.1);
            border-color: var(--terminal-orange);
        }

        /* Modal styles */
        .image-modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.9); /* Black w/ opacity */
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-modal-content {
            position: relative;
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
            border: 3px solid var(--terminal-cyan);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            animation-name: zoom;
            animation-duration: 0.6s;
        }

        .image-modal-content img,
        .image-modal-content video,
        .image-modal-content audio {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 5px;
        }

        .image-modal-content, .image-modal-close {
            animation-name: zoom;
            animation-duration: 0.6s;
        }

        @keyframes zoom {
            from {transform:scale(0)}
            to {transform:scale(1)}
        }

        .image-modal-close {
            position: absolute;
            top: -40px;
            right: -40px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
            background: rgba(0,0,0,0.7);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        .image-modal-close:hover,
        .image-modal-close:focus {
            color: #bbb;
            text-decoration: none;
            cursor: pointer;
            background: rgba(0,0,0,0.9);
        }

        /* Navigation buttons for media gallery */
        .modal-nav-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: #f1f1f1;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
            background: rgba(0,0,0,0.7);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            border: none;
            outline: none;
        }

        .modal-nav-button:hover {
            background: rgba(0,0,0,0.9);
            color: var(--terminal-cyan);
        }

        .modal-nav-prev {
            left: -60px;
        }

        .modal-nav-next {
            right: -60px;
        }

        .modal-nav-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Media counter */
        .modal-counter {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            color: #f1f1f1;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 15px;
            z-index: 1001;
        }
    </style>
    <script src="nostr.js"></script>
</head>
<body>
    <canvas id="matrix" class="matrix-background"></canvas>
    <div class="terminal-container">
        <div class="terminal-header">
            <div class="terminal-buttons-group">
                <div class="terminal-button-ctrl red"></div>
                <div class="terminal-button-ctrl yellow"></div>
                <div class="terminal-button-ctrl green"></div>
            </div>
            <div class="glitch" data-text="Nostr Profile Viewer:~">Nostr Profile Viewer:~</div>
            <div class="terminal-buttons-group">
                <div style="width: 20px;"></div> <!-- Spacer -->
            </div>
        </div>
        <div class="terminal-body">
            <!-- Original content goes here -->
            <div id="profile-container" class="profile loading">
                <div id="profile-content">loading profile...</div>
            </div>

            <div id="follow-button-container">
                <button id="follow-button">Follow</button>
                <div id="follow-error-message"></div>
            </div>

            <div id="messages-container" class="messages loading">
                <h2>Messages & Articles</h2>
                <div id="messages-content" class="messages-scrollable">loading messages...</div>
            </div>
            <!-- End of original content -->
        </div>
    </div>

    <script>
                // Matrix effect with iframe protection
        let canvas, ctx, columns, rainDrops;
        let animationRunning = false;
        
        // Global constants for matrix animation
        const alphabet = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~01';
        const fontSize = 16;
        
        try {
            canvas = document.getElementById('matrix');
            if (canvas && canvas.getContext) {
                ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                columns = canvas.width / fontSize;
                rainDrops = Array(Math.floor(columns)).fill(1);
                
                animationRunning = true;
            } else {
                console.log('Canvas not available, skipping matrix animation');
            }
        } catch (error) {
            console.log('Matrix initialization failed (normal in some iframe contexts)');
            animationRunning = false;
        }
        
        function drawMatrix() {
            // Check if animation should continue and all required variables are valid
            if (!animationRunning || !ctx || !canvas || !canvas.getContext || !rainDrops || !alphabet) {
                return;
            }
            
            try {
                // Check if we're in an iframe and if so, reduce animation intensity
                const isInIframe = window.self !== window.top;
                if (isInIframe && Math.random() > 0.1) {
                    // Only animate 10% of the time when in iframe to reduce load
                    requestAnimationFrame(drawMatrix);
                    return;
                }
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#0f0'; // Fallback color instead of CSS variable in iframe
                ctx.font = fontSize + 'px monospace';
                
                for (let i = 0; i < rainDrops.length; i++) {
                    const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                    ctx.fillText(text, i * fontSize, rainDrops[i] * fontSize);
                    if (rainDrops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        rainDrops[i] = 0;
                    }
                    rainDrops[i]++;
                }
                
                if (animationRunning) {
                    requestAnimationFrame(drawMatrix);
                }
            } catch (error) {
                console.log('Matrix animation stopped due to context error (normal in iframe)');
                animationRunning = false;
            }
        }
        
        // Start matrix animation
        drawMatrix();

        window.addEventListener('resize', function() {
            try {
                if (!canvas || !animationRunning) return;
                
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                columns = canvas.width / fontSize;
                rainDrops = Array(Math.floor(columns)).fill(1).map(() => Math.floor(Math.random() * canvas.height / fontSize)); // Reinitialize drops on resize
            } catch (error) {
                console.log('Matrix resize handler error (normal in iframe)');
                animationRunning = false;
            }
        });
        
        // Stop matrix animation when page is about to unload (cleanup)
        window.addEventListener('beforeunload', function() {
            animationRunning = false;
        });

        // Navigation history management
        let navigationHistory = [];
        let currentHistoryIndex = -1;
        let initialHex = null;

        // URL parameter management
        function updateURLParams(hex, action = 'navigate') {
            const currentParams = new URLSearchParams(window.location.search);
            const previousHex = currentParams.get('hex');
            
            // Set the new hex
            currentParams.set('hex', hex);
            
            // Handle navigation parameters based on action
            if (action === 'click') {
                // User clicked on a link - set previous
                if (previousHex && previousHex !== hex) {
                    currentParams.set('previous', previousHex);
                }
                // Clear next since we're going forward
                currentParams.delete('next');
            } else if (action === 'back') {
                // User clicked back button - set next
                if (previousHex && previousHex !== hex) {
                    currentParams.set('next', previousHex);
                }
                // Clear previous since we're going backward
                currentParams.delete('previous');
            } else if (action === 'origin') {
                // User clicked home button - clear navigation params
                currentParams.delete('previous');
                currentParams.delete('next');
            }
            
            // Always maintain origin
            if (!currentParams.has('origin')) {
                currentParams.set('origin', initialHex || hex);
            }
            
            const newUrl = window.location.pathname + '?' + currentParams.toString();
            window.history.pushState({ hex: hex, action: action }, '', newUrl);
        }

        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                hex: params.get('hex'),
                previous: params.get('previous'),
                next: params.get('next'),
                origin: params.get('origin')
            };
        }

        function updateNavigationButtonsFromURL() {
            const params = getURLParams();
            const backButton = document.querySelector('.terminal-button-ctrl.red');
            const homeButton = document.querySelector('.terminal-button-ctrl.yellow');
            const forwardButton = document.querySelector('.terminal-button-ctrl.green');
            
            if (!backButton || !homeButton || !forwardButton) return;
            
            // Update back button state
            if (params.previous) {
                backButton.style.opacity = '1';
                backButton.title = `Previous profile (${params.previous.substring(0, 10)}...)`;
            } else {
                backButton.style.opacity = '0.5';
                backButton.title = 'No previous profile';
            }
            
            // Update home button state
            if (params.origin) {
                homeButton.style.opacity = '1';
                homeButton.title = `Go to initial profile (${params.origin.substring(0, 10)}...)`;
            } else {
                homeButton.style.opacity = '0.5';
                homeButton.title = 'No initial profile';
            }
            
            // Update forward button state
            if (params.next) {
                forwardButton.style.opacity = '1';
                forwardButton.title = `Next profile (${params.next.substring(0, 10)}...)`;
            } else {
                forwardButton.style.opacity = '0.5';
                forwardButton.title = 'No next profile';
            }
        }

        // Navigation functions
        function addToHistory(hex) {
            // Check if this hex is already the current one
            if (currentHistoryIndex >= 0 && navigationHistory[currentHistoryIndex] === hex) {
                return; // Already at this profile
            }
            
            // Remove any entries after current index (if we navigated back)
            navigationHistory = navigationHistory.slice(0, currentHistoryIndex + 1);
            
            // Add new entry
            navigationHistory.push(hex);
            currentHistoryIndex = navigationHistory.length - 1;
            
            // Keep only last 20 entries to prevent memory issues
            if (navigationHistory.length > 20) {
                navigationHistory = navigationHistory.slice(-20);
                currentHistoryIndex = navigationHistory.length - 1;
            }
            
            updateNavigationButtons();
        }

        function navigateBack() {
            const params = getURLParams();
            if (params.previous) {
                loadProfile(params.previous, 'back');
            }
        }

        function navigateForward() {
            const params = getURLParams();
            if (params.next) {
                loadProfile(params.next, 'click');
            }
        }

        function goToInitial() {
            const params = getURLParams();
            if (params.origin) {
                loadProfile(params.origin, 'origin');
            }
        }

        function loadProfile(hex, action = 'click') {
            // Update URL with parameters
            updateURLParams(hex, action);
            
            // Update global hexKey variable
            window.hexKey = hex;
            
            // Update navigation buttons immediately
            updateNavigationButtonsFromURL();
            
            // Reload profile data - use a timeout to ensure displayNostrData is defined
            setTimeout(() => {
                if (typeof displayNostrData === 'function') {
                    displayNostrData();
                } else {
                    // Fallback: reload page if displayNostrData not ready
                    window.location.reload();
                }
            }, 100);
        }

        function updateNavigationButtons() {
            // Use URL-based navigation instead of history array
            updateNavigationButtonsFromURL();
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            if (event.state && event.state.hex) {
                window.hexKey = event.state.hex;
                updateNavigationButtonsFromURL();
                setTimeout(() => {
                    if (typeof displayNostrData === 'function') {
                        displayNostrData();
                    }
                }, 100);
            }
        });

        // Add event listeners for navigation buttons
        document.addEventListener('DOMContentLoaded', function() {
            const backButton = document.querySelector('.terminal-button-ctrl.red');
            const homeButton = document.querySelector('.terminal-button-ctrl.yellow');
            const forwardButton = document.querySelector('.terminal-button-ctrl.green');
            
            if (backButton) {
                backButton.addEventListener('click', navigateBack);
            }
            if (homeButton) {
                homeButton.addEventListener('click', goToInitial);
            }
            if (forwardButton) {
                forwardButton.addEventListener('click', navigateForward);
            }
            
            // Initialize navigation buttons from URL
            updateNavigationButtonsFromURL();
        });

        // --- Original Nostr Profile JavaScript ---
        const followButton = document.getElementById('follow-button');
        const originalButtonBgColor = getComputedStyle(followButton).backgroundColor; // Get initial dynamic color

        // Helper function to get Nostr extension (works in iframe)
        function getNostrExtension() {
            // First try current window
            if (window.nostr) {
                return window.nostr;
            }
            
            // If in iframe, try parent window
            try {
                if (window.self !== window.top && window.parent && window.parent.nostr) {
                    return window.parent.nostr;
                }
                
                // Try top window
                if (window.top && window.top.nostr) {
                    return window.top.nostr;
                }
            } catch (e) {
                // Cross-origin iframe - can't access parent
                console.warn('Cannot access parent window nostr (cross-origin):', e);
            }
            
            return null;
        }

        // Bech32 decoder for nprofile
        function bech32Decode(bech) {
            const debug = window.enableNprofileDebug || false;
            const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
            const BECH32_CONST = 1;
            
            if (debug) console.log('bech32Decode input:', bech);
            
            if (bech.length < 8) {
                if (debug) console.log('Bech32 too short:', bech.length);
                return null;
            }
            
            const pos = bech.lastIndexOf('1');
            // Fixed separator validation - be more permissive
            if (pos < 1 || bech.length > 90) {
                if (debug) console.log('Invalid separator position:', pos, 'length:', bech.length);
                return null;
            }
            
            const hrp = bech.substring(0, pos);
            const data = bech.substring(pos + 1);
            
            if (debug) console.log('HRP:', hrp, 'Data part:', data);
            
            const decoded = [];
            for (let i = 0; i < data.length; i++) {
                const v = CHARSET.indexOf(data.charAt(i));
                if (v === -1) {
                    if (debug) console.log('Invalid character at position', i, ':', data.charAt(i));
                    return null;
                }
                decoded.push(v);
            }
            
            if (debug) console.log('Decoded data array:', decoded);
            
            const checksumValid = verifyChecksum(hrp, decoded);
            if (debug) console.log('Checksum valid:', checksumValid);
            
            if (!checksumValid) {
                if (debug) console.log('Checksum verification failed');
                return null;
            }
            
            const result = { hrp, data: decoded.slice(0, -6) };
            if (debug) console.log('bech32Decode result:', result);
            return result;
        }
        
        function verifyChecksum(hrp, data) {
            const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
            let chk = 1;
            
            for (let i = 0; i < hrp.length; i++) {
                chk = polymodStep(chk) ^ (hrp.charCodeAt(i) >> 5);
            }
            chk = polymodStep(chk);
            
            for (let i = 0; i < hrp.length; i++) {
                chk = polymodStep(chk) ^ (hrp.charCodeAt(i) & 0x1f);
            }
            
            for (let i = 0; i < data.length; i++) {
                chk = polymodStep(chk) ^ data[i];
            }
            
            return chk === 1;
        }
        
        function polymodStep(pre) {
            const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
            const b = pre >> 25;
            return ((pre & 0x1ffffff) << 5) ^ 
                   (-((b >> 0) & 1) & GENERATOR[0]) ^
                   (-((b >> 1) & 1) & GENERATOR[1]) ^
                   (-((b >> 2) & 1) & GENERATOR[2]) ^
                   (-((b >> 3) & 1) & GENERATOR[3]) ^
                   (-((b >> 4) & 1) & GENERATOR[4]);
        }
        
        function convertBits(data, fromBits, toBits, pad) {
            let acc = 0;
            let bits = 0;
            const ret = [];
            const maxv = (1 << toBits) - 1;
            const maxAcc = (1 << (fromBits + toBits - 1)) - 1;
            
            for (let i = 0; i < data.length; i++) {
                const value = data[i];
                if (value < 0 || (value >> fromBits) !== 0) return null;
                acc = ((acc << fromBits) | value) & maxAcc;
                bits += fromBits;
                while (bits >= toBits) {
                    bits -= toBits;
                    ret.push((acc >> bits) & maxv);
                }
            }
            
            if (pad) {
                if (bits > 0) ret.push((acc << (toBits - bits)) & maxv);
            } else if (bits >= fromBits || ((acc << (toBits - bits)) & maxv)) {
                return null;
            }
            
            return ret;
        }

        // Function to decode nprofile to hex pubkey
        function nprofileToHex(nprofile) {
            const debug = window.enableNprofileDebug || false;
            try {
                if (debug) console.log('Starting nprofile decode for:', nprofile);
                
                const decoded = bech32Decode(nprofile);
                if (debug) console.log('Bech32 decode result:', decoded);
                
                if (!decoded || decoded.hrp !== 'nprofile') {
                    if (debug) console.log('Invalid bech32 decode or wrong hrp. Expected "nprofile", got:', decoded?.hrp);
                    return null;
                }
                
                const bytes = convertBits(decoded.data, 5, 8, false);
                if (debug) console.log('Converted bits result:', bytes);
                
                if (!bytes) {
                    if (debug) console.log('Failed to convert bits');
                    return null;
                }
                
                // Parse TLV (Type-Length-Value) data
                let i = 0;
                let pubkey = null;
                
                if (debug) console.log('Starting TLV parsing, bytes length:', bytes.length);
                
                while (i < bytes.length) {
                    if (i + 1 >= bytes.length) {
                        if (debug) console.log('Not enough bytes for type-length at position:', i);
                        break;
                    }
                    
                    const type = bytes[i];
                    const length = bytes[i + 1];
                    i += 2;
                    
                    if (debug) console.log(`TLV entry - Type: ${type}, Length: ${length}, Position: ${i}`);
                    
                    if (i + length > bytes.length) {
                        if (debug) console.log('Not enough bytes for value, expected:', length, 'available:', bytes.length - i);
                        break;
                    }
                    
                    if (type === 0 && length === 32) { // pubkey
                        pubkey = bytes.slice(i, i + length);
                        if (debug) console.log('Found pubkey at position:', i, 'pubkey bytes:', pubkey);
                        break;
                    } else {
                        if (debug) console.log('Skipping TLV entry - Type:', type, 'Length:', length);
                    }
                    
                    i += length;
                }
                
                if (pubkey) {
                    const hexResult = Array.from(pubkey, byte => byte.toString(16).padStart(2, '0')).join('');
                    if (debug) console.log('Final hex result:', hexResult);
                    return hexResult;
                }
                
                if (debug) console.log('No pubkey found in TLV data');
                return null;
            } catch (error) {
                console.error('Error decoding nprofile:', error);
                if (debug) console.log('Error stack:', error.stack);
                return null;
            }
        }

        // Working nprofile decoder based on the successful simple test
        function nprofileToHexWorking(nprofile) {
            try {
                console.log('nprofileToHexWorking called with:', nprofile);
                console.log('Input length:', nprofile.length);
                
                // Use the working approach from simpleNprofileTest
                const pos = nprofile.lastIndexOf('1');
                console.log('Last 1 position:', pos);
                
                if (pos === -1) {
                    console.log('No separator found');
                    return null;
                }
                
                const data = nprofile.substring(pos + 1);
                console.log('Data part length:', data.length);
                console.log('Data part (first 50 chars):', data.substring(0, 50));
                
                const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
                const decoded = [];
                for (let i = 0; i < data.length; i++) {
                    const v = CHARSET.indexOf(data.charAt(i));
                    if (v === -1) {
                        console.log('Invalid character at position', i, ':', data.charAt(i));
                        return null;
                    }
                    decoded.push(v);
                }
                
                console.log('Decoded values length:', decoded.length);
                console.log('First 10 decoded values:', decoded.slice(0, 10));
                
                // Remove checksum (last 6 characters)
                const dataWithoutChecksum = decoded.slice(0, -6);
                console.log('Data without checksum length:', dataWithoutChecksum.length);
                
                const bytes = convertBits(dataWithoutChecksum, 5, 8, false);
                console.log('Converted bytes length:', bytes ? bytes.length : 'null');
                
                if (bytes && bytes.length > 0) {
                    console.log('First 10 bytes:', bytes.slice(0, 10));
                    
                    // Parse TLV structure to find the pubkey (type 0)
                    let i = 0;
                    while (i < bytes.length) {
                        if (i + 1 >= bytes.length) break;
                        
                        const type = bytes[i];
                        const length = bytes[i + 1];
                        console.log(`TLV entry: type=${type}, length=${length}`);
                        
                        if (i + 2 + length > bytes.length) {
                            console.log('TLV entry extends beyond data');
                            break;
                        }
                        
                        if (type === 0 && length === 32) {
                            // Found pubkey entry
                            const pubkey = bytes.slice(i + 2, i + 2 + length);
                            const hex = Array.from(pubkey, byte => byte.toString(16).padStart(2, '0')).join('');
                            console.log('Found pubkey hex:', hex);
                            return hex;
                        }
                        
                        // Move to next TLV entry
                        i += 2 + length;
                    }
                    
                    console.log('No pubkey (type 0) found in TLV structure');
                } else {
                    console.log('Not enough bytes or convertBits failed');
                }
                
                return null;
            } catch (error) {
                console.error('Error in working nprofile decoder:', error);
                console.error('Error stack:', error.stack);
                return null;
            }
        }

        // Enhanced nprofile decoder that wraps the working function
        function nprofileToHexEnhanced(nprofile) {
            try {
                console.log('nprofileToHexEnhanced called with:', nprofile);
                console.log('Length:', nprofile.length);
                
                const result = nprofileToHexWorking(nprofile);
                console.log('nprofileToHexEnhanced result:', result);
                return result;
            } catch (error) {
                console.error('Error in enhanced nprofile decoder:', error);
                return null;
            }
        }

        // Function to make text with clickable links and handle nprofile
        function makeLinksClickable(text) {
            const debug = window.enableNprofileDebug || false;
            if (debug) console.log('Original text:', text); // Debug
            
            // Improved regex patterns for different types of links
            const urlRegex = /(https?:\/\/[^\s<>"{}|\\^`[\]]+)/gi;
            // More robust nprofile regex that handles nostr: prefix and punctuation correctly
            const nprofileRegex = /(nostr:)?(nprofile1[a-z0-9]+)/gi;
            // More robust npub regex that handles nostr: prefix
            const npubRegex = /(nostr:)?(npub1[a-z0-9]+)/gi;
            
            // Replace URLs first
            text = text.replace(urlRegex, function(match) {
                return processMediaLink(match);
            });
            if (debug) console.log('After URL replacement:', text); // Debug
            
            // Replace nprofile links using the working decoder
            text = text.replace(nprofileRegex, function(match, nostrPrefix, p1) {
                if (debug) console.log('Found nprofile match:', match, 'Prefix:', nostrPrefix, 'Group 1:', p1); // Debug
                const hex = nprofileToHexEnhanced(p1); // Use the enhanced version
                if (debug) console.log('Decoded hex:', hex); // Debug
                if (hex) {
                    const linkHtml = `<a href="#" onclick="loadProfile('${hex}'); return false;" class="nprofile-link" title="View profile for ${hex.substring(0,10)}...">${match}</a>`;
                    if (debug) console.log('Generated nprofile link:', linkHtml); // Debug
                    return linkHtml;
                }
                return match;
            });
            if (debug) console.log('After nprofile replacement:', text); // Debug
            
            // Replace npub links
            text = text.replace(npubRegex, function(match, nostrPrefix, p1) {
                if (debug) console.log('Found npub match:', match, 'Prefix:', nostrPrefix, 'Group 1:', p1); // Debug
                try {
                    const decoded = bech32Decode(p1);
                    if (decoded && decoded.hrp === 'npub') {
                        const bytes = convertBits(decoded.data, 5, 8, false);
                        if (bytes && bytes.length === 32) {
                            const hex = Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');
                            const linkHtml = `<a href="#" onclick="loadProfile('${hex}'); return false;" class="nprofile-link" title="View profile for ${hex.substring(0,10)}...">${match}</a>`;
                            if (debug) console.log('Generated npub link:', linkHtml); // Debug
                            return linkHtml;
                        }
                    }
                } catch (error) {
                    console.error('Error decoding npub:', error);
                }
                return match;
            });
            if (debug) console.log('Final text:', text); // Debug
            
            return text;
        }

        // Global media collection for navigation
        window.mediaCollection = [];
        window.currentMediaIndex = 0;
        
        // Global messages data for article expansion
        window.currentMessagesData = [];

        // Function to process media links and return appropriate HTML
        function processMediaLink(url) {
            const urlLower = url.toLowerCase();
            
            // Image formats
            if (urlLower.match(/\.(jpg|jpeg|png|gif|webp|svg|bmp|ico)$/)) {
                // Add to media collection
                const mediaIndex = window.mediaCollection.length;
                window.mediaCollection.push({ type: 'image', url: url });
                
                return `<div class="media-container">
                    <img src="${url}" alt="Image" class="message-image" onclick="openMediaModal(${mediaIndex})" title="Click to enlarge">
                    <a href="${url}" target="_blank" rel="noopener noreferrer" class="media-link">${url}</a>
                </div>`;
            }
            
            // Video formats
            else if (urlLower.match(/\.(mp4|webm|ogg|mov|avi|mkv)$/)) {
                // Add to media collection
                const mediaIndex = window.mediaCollection.length;
                window.mediaCollection.push({ type: 'video', url: url });
                
                return `<div class="media-container">
                    <video controls class="message-video" preload="metadata" onclick="openMediaModal(${mediaIndex})" title="Click to open in modal">
                        <source src="${url}" type="video/${urlLower.split('.').pop()}">
                        Your browser does not support the video tag.
                    </video>
                    <a href="${url}" target="_blank" rel="noopener noreferrer" class="media-link">${url}</a>
                </div>`;
            }
            
            // Audio formats
            else if (urlLower.match(/\.(mp3|wav|ogg|flac|aac|m4a)$/)) {
                // Add to media collection
                const mediaIndex = window.mediaCollection.length;
                window.mediaCollection.push({ type: 'audio', url: url });
                
                return `<div class="media-container">
                    <audio controls class="message-audio" preload="metadata" onclick="openMediaModal(${mediaIndex})" title="Click to open in modal">
                        <source src="${url}" type="audio/${urlLower.split('.').pop()}">
                        Your browser does not support the audio tag.
                    </audio>
                    <a href="${url}" target="_blank" rel="noopener noreferrer" class="media-link">${url}</a>
                </div>`;
            }
            
            // Regular links
            else {
                return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
            }
        }

        // Function to open image in modal
        function openImageModal(imageUrl) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('imageModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'imageModal';
                modal.className = 'image-modal';
                modal.innerHTML = `
                    <div class="image-modal-content">
                        <span class="image-modal-close">&times;</span>
                        <img id="modalImage" src="" alt="Full size image" onerror="this.style.display='none'; this.parentElement.innerHTML='<p style=\'color: white; text-align: center; padding: 20px;\'>Failed to load image</p>'">
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close modal on click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal || e.target.className === 'image-modal-close') {
                        modal.style.display = 'none';
                    }
                });
                
                // Close modal on escape key
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape' && modal.style.display === 'flex') {
                        modal.style.display = 'none';
                    }
                });
            }
            
            // Show image in modal
            const modalImage = document.getElementById('modalImage');
            modalImage.style.display = 'block';
            modalImage.src = imageUrl;
            modal.style.display = 'flex';
            
            // Add loading state
            modalImage.onload = function() {
                this.style.opacity = '1';
            };
            modalImage.onerror = function() {
                this.style.display = 'none';
                this.parentElement.innerHTML = '<p style="color: white; text-align: center; padding: 20px;">Failed to load image</p>';
            };
            modalImage.style.opacity = '0.7';
        }

        // Function to reset media collection
        function resetMediaCollection() {
            window.mediaCollection = [];
            window.currentMediaIndex = 0;
        }

        // Function to stop all media playback
        function stopAllMedia() {
            const modal = document.getElementById('mediaModal');
            if (modal) {
                const mediaElements = modal.querySelectorAll('video, audio');
                mediaElements.forEach(media => {
                    media.pause();
                    media.currentTime = 0;
                });
            }
        }

        // Function to open media modal with navigation
        function openMediaModal(mediaIndex) {
            window.currentMediaIndex = mediaIndex;
            const media = window.mediaCollection[mediaIndex];
            if (!media) return;

            let modal = document.getElementById('mediaModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'mediaModal';
                modal.className = 'image-modal'; // Uses the same modal styles
                modal.innerHTML = `
                    <div class="image-modal-content">
                        <span class="image-modal-close">&times;</span>
                        <button class="modal-nav-button modal-nav-prev" onclick="navigateMedia(-1)" title="Previous media">‹</button>
                        <button class="modal-nav-button modal-nav-next" onclick="navigateMedia(1)" title="Next media">›</button>
                        <div class="modal-counter" id="modalCounter"></div>
                        <div id="modalMediaContent"></div>
                    </div>
                `;
                document.body.appendChild(modal);

                // Add event listeners for closing modal
                const closeBtn = modal.querySelector('.image-modal-close');
                closeBtn.addEventListener('click', () => {
                    stopAllMedia(); // Stop media before closing
                    modal.style.display = 'none';
                });

                // Close modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        stopAllMedia(); // Stop media before closing
                        modal.style.display = 'none';
                    }
                });

                // Keyboard navigation
                document.addEventListener('keydown', function modalKeyHandler(e) {
                    if (modal.style.display === 'flex') {
                        if (e.key === 'Escape') {
                            stopAllMedia(); // Stop media before closing
                            modal.style.display = 'none';
                            document.removeEventListener('keydown', modalKeyHandler);
                        } else if (e.key === 'ArrowLeft') {
                            navigateMedia(-1);
                        } else if (e.key === 'ArrowRight') {
                            navigateMedia(1);
                        }
                    }
                });
            }

            showMediaInModal(media);
            modal.style.display = 'flex'; // Use flex for centering
        }

        // Function to show media in modal
        function showMediaInModal(media) {
            const modalContent = document.getElementById('modalMediaContent');
            const counter = document.getElementById('modalCounter');
            const prevBtn = document.querySelector('.modal-nav-prev');
            const nextBtn = document.querySelector('.modal-nav-next');
            
            if (!modalContent) return;
            
            // Stop any currently playing media before showing new media
            const currentMedia = modalContent.querySelector('video, audio');
            if (currentMedia) {
                currentMedia.pause();
                currentMedia.currentTime = 0;
            }
            
            // Update counter
            if (counter) {
                counter.textContent = `${window.currentMediaIndex + 1} / ${window.mediaCollection.length}`;
            }
            
            // Update navigation buttons
            if (prevBtn) {
                prevBtn.disabled = window.currentMediaIndex === 0;
                prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
            }
            if (nextBtn) {
                nextBtn.disabled = window.currentMediaIndex === window.mediaCollection.length - 1;
                nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
            }
            
            // Create media element based on type
            let mediaHTML = '';
            switch (media.type) {
                case 'image':
                    mediaHTML = `<img src="${media.url}" alt="Image" style="max-width: 100%; max-height: 80vh; object-fit: contain;">`;
                    break;
                case 'video':
                    mediaHTML = `<video controls style="max-width: 100%; max-height: 80vh; object-fit: contain;">
                        <source src="${media.url}" type="video/${media.url.split('.').pop()}">
                        Your browser does not support the video tag.
                    </video>`;
                    break;
                case 'audio':
                    mediaHTML = `<audio controls style="max-width: 100%;">
                        <source src="${media.url}" type="audio/${media.url.split('.').pop()}">
                        Your browser does not support the audio tag.
                    </audio>`;
                    break;
                default:
                    mediaHTML = `<p>Unsupported media type: ${media.type}</p>`;
            }
            
            modalContent.innerHTML = mediaHTML;
        }

        // Function to navigate between media
        function navigateMedia(direction) {
            const newIndex = window.currentMediaIndex + direction;
            if (newIndex >= 0 && newIndex < window.mediaCollection.length) {
                window.currentMediaIndex = newIndex;
                const media = window.mediaCollection[newIndex];
                showMediaInModal(media);
            }
        }

        // Test function for nprofile decoding (can be called from console)
        window.testNprofileDecoding = function() {
            const testNprofile = 'nprofile1qqs825fxw8a2lyfa5fknnk2rk3ep8df78qhj54cmzcr2xk9tcsdck8sprdmhxue69uhhyetvv9ujucm0wpukcctjv9jxjmewvdhk6qgnwaen5te0xyerwt3s9cczuvf6xumnwdcs2xx5h';
            const hex = nprofileToHex(testNprofile);
            console.log('Test nprofile:', testNprofile);
            console.log('Decoded hex:', hex);
            if (hex) {
                const currentParams = new URLSearchParams(window.location.search);
                currentParams.set('hex', hex);
                const newUrl = window.location.pathname + '?' + currentParams.toString();
                console.log('Generated URL:', newUrl);
                return { testNprofile, hex, newUrl };
            } else {
                console.error('Failed to decode nprofile');
                return null;
            }
        };

        // Test function for the specific message content
        window.testMessageLinkification = function() {
            const testMessage = "Hello NOSTR visitor. nprofile1qqs825fxw8a2lyfa5fknnk2rk3ep8df78qhj54cmzcr2xk9tcsdck8sprdmhxue69uhhyetvv9ujucm0wpukcctjv9jxjmewvdhk6qgnwaen5te0xyerwt3s9cczuvf6xumnwdcs2xx5h, we noticed that you're using our Relay without being registered on our #Ğ1 Web of Trust. You have 0 message(s) left before being automatically blocked. Please join our self-sovereign community to avoid interruption. Take place on #UPlanet : https://ipfs.copylaradio.com/ipns/copylaradio.com Get a #MULTIPASS Your devoted Astroport Captain. #Co";
            
            console.log('Testing message linkification...');
            window.enableNprofileDebug = true;
            const result = makeLinksClickable(testMessage);
            console.log('Result:', result);
            window.enableNprofileDebug = false;
            return result;
        };

        // Quick debug toggle
        window.enableDebug = function() {
            window.enableNprofileDebug = true;
            console.log('Debug mode enabled for nprofile detection');
        };

        window.disableDebug = function() {
            window.enableNprofileDebug = false;
            console.log('Debug mode disabled');
        };

        // Navigation history utilities
        window.showNavigationHistory = function() {
            console.log('=== Navigation History ===');
            console.log('Current index:', currentHistoryIndex);
            console.log('Initial hex:', initialHex);
            console.log('History:', navigationHistory);
            console.log('History length:', navigationHistory.length);
            
            if (navigationHistory.length > 0) {
                console.log('History entries:');
                navigationHistory.forEach((hex, index) => {
                    const marker = index === currentHistoryIndex ? '→ ' : '  ';
                    console.log(`${marker}${index}: ${hex.substring(0, 10)}...`);
                });
            }
            
            return {
                currentIndex: currentHistoryIndex,
                initialHex: initialHex,
                history: navigationHistory,
                length: navigationHistory.length
            };
        };

        window.clearNavigationHistory = function() {
            navigationHistory = [];
            currentHistoryIndex = -1;
            updateNavigationButtons();
            console.log('Navigation history cleared');
        };

        window.goToProfile = function(hex) {
            if (hex && hex.length === 64) {
                loadProfile(hex);
                console.log('Navigated to profile:', hex.substring(0, 10) + '...');
            } else {
                console.error('Invalid hex key:', hex);
            }
        };

        // Debug function to test navigation
        window.testNavigation = function() {
            console.log('=== Testing Navigation ===');
            console.log('Current hexKey:', window.hexKey);
            console.log('Initial hex:', initialHex);
            
            const params = getURLParams();
            console.log('URL Parameters:', params);
            
            // Test button states
            const backButton = document.querySelector('.terminal-button-ctrl.red');
            const homeButton = document.querySelector('.terminal-button-ctrl.yellow');
            const forwardButton = document.querySelector('.terminal-button-ctrl.green');
            
            console.log('Button states:');
            console.log('Back button opacity:', backButton?.style.opacity);
            console.log('Home button opacity:', homeButton?.style.opacity);
            console.log('Forward button opacity:', forwardButton?.style.opacity);
            
            console.log('Navigation History (legacy):');
            showNavigationHistory();
        };

        // Debug function to show URL parameters
        window.showURLParams = function() {
            const params = getURLParams();
            console.log('=== URL Parameters ===');
            console.log('hex:', params.hex);
            console.log('previous:', params.previous);
            console.log('next:', params.next);
            console.log('origin:', params.origin);
            console.log('Full URL:', window.location.href);
            return params;
        };

        // Debug function to simulate navigation
        window.simulateNavigation = function(action) {
            const params = getURLParams();
            console.log(`=== Simulating ${action} ===`);
            
            switch(action) {
                case 'click':
                    if (params.previous) {
                        console.log('Simulating click on previous profile');
                        loadProfile(params.previous, 'click');
                    } else {
                        console.log('No previous profile to navigate to');
                    }
                    break;
                case 'back':
                    if (params.previous) {
                        console.log('Simulating back navigation');
                        loadProfile(params.previous, 'back');
                    } else {
                        console.log('No previous profile to go back to');
                    }
                    break;
                case 'forward':
                    if (params.next) {
                        console.log('Simulating forward navigation');
                        loadProfile(params.next, 'click');
                    } else {
                        console.log('No next profile to go forward to');
                    }
                    break;
                case 'origin':
                    if (params.origin) {
                        console.log('Simulating origin navigation');
                        loadProfile(params.origin, 'origin');
                    } else {
                        console.log('No origin profile to navigate to');
                    }
                    break;
                default:
                    console.log('Available actions: click, back, forward, origin');
            }
        };

        // Test function for media link processing
        window.testMediaLinks = function() {
            const testMessage = `
                Check out this image: https://example.com/image.jpg
                And this video: https://example.com/video.mp4
                And this audio: https://example.com/audio.mp3
                And a regular link: https://example.com/page.html
                And a nprofile: nprofile1qqs825fxw8a2lyfa5fknnk2rk3ep8df78qhj54cmzcr2xk9tcsdck8sprdmhxue69uhhyetvv9ujucm0wpukcctjv9jxjmewvdhk6qgnwaen5te0xyerwt3s9cczuvf6xumnwdcs2xx5h
            `;
            
            console.log('=== Testing Media Link Processing ===');
            console.log('Original message:', testMessage);
            const processed = makeLinksClickable(testMessage);
            console.log('Processed message:', processed);
            
            // Create a test div to show the result
            const testDiv = document.createElement('div');
            testDiv.innerHTML = processed;
            testDiv.style.border = '1px solid var(--terminal-cyan)';
            testDiv.style.padding = '10px';
            testDiv.style.margin = '10px';
            testDiv.style.backgroundColor = 'var(--terminal-bg)';
            testDiv.style.color = 'var(--text-color)';
            testDiv.style.fontFamily = 'var(--font-family)';
            
            document.body.appendChild(testDiv);
            
            console.log('Test div added to page. Check the bottom of the page.');
            return processed;
        };

        // Test function for banner and profile picture display
        window.testProfileDisplay = function() {
            console.log('=== Testing Profile Display ===');
            
            // Create a test profile container
            const testContainer = document.createElement('div');
            testContainer.style.border = '1px solid var(--terminal-green)';
            testContainer.style.padding = '10px';
            testContainer.style.margin = '10px';
            testContainer.style.backgroundColor = 'var(--terminal-bg)';
            testContainer.style.color = 'var(--text-color)';
            testContainer.style.fontFamily = 'var(--font-family)';
            testContainer.style.maxWidth = '400px';
            
            // Test profile with banner and picture
            const testProfileHTML = `
                <div class="profile-banner" onclick="openImageModal('https://picsum.photos/800/200')" title="Click to enlarge banner">
                    <img src="https://picsum.photos/800/200" alt="Profile Banner">
                </div>
                <div class="profile-picture-container">
                    <img src="https://picsum.photos/200/200" alt="Profile Picture" class="profile-picture" onclick="openImageModal('https://picsum.photos/200/200')" title="Click to enlarge profile picture">
                </div>
                <h3>Test User</h3>
                <p>This is a test profile with banner and profile picture. Click on the images to zoom!</p>
            `;
            
            testContainer.innerHTML = testProfileHTML;
            document.body.appendChild(testContainer);
            
            console.log('Test profile display added to page. Check the bottom of the page.');
            console.log('Click on the banner or profile picture to test zoom functionality.');
        };

        // Test function for improved modal system
        window.testModalSystem = function() {
            console.log('=== Testing Improved Modal System ===');
            
            // Create test images with different aspect ratios
            const testImages = [
                'https://picsum.photos/800/200', // Wide banner
                'https://picsum.photos/200/200', // Square
                'https://picsum.photos/200/800', // Tall
                'https://picsum.photos/400/300'  // Standard
            ];
            
            const testContainer = document.createElement('div');
            testContainer.style.border = '1px solid var(--terminal-purple)';
            testContainer.style.padding = '10px';
            testContainer.style.margin = '10px';
            testContainer.style.backgroundColor = 'var(--terminal-bg)';
            testContainer.style.color = 'var(--text-color)';
            testContainer.style.fontFamily = 'var(--font-family)';
            
            let testHTML = '<h4>Test Modal System - Click images to test centering:</h4>';
            testImages.forEach((url, index) => {
                testHTML += `
                    <div style="display: inline-block; margin: 5px;">
                        <img src="${url}" alt="Test ${index + 1}" 
                             style="width: 100px; height: 100px; object-fit: cover; cursor: pointer; border: 1px solid var(--terminal-cyan);" 
                             onclick="openImageModal('${url}')" 
                             title="Click to test modal centering">
                    </div>
                `;
            });
            
            testContainer.innerHTML = testHTML;
            document.body.appendChild(testContainer);
            
            console.log('Test modal system added. Click on any image to test the centered modal.');
        };

        // Test function for multimedia gallery system
        window.testMultimediaGallery = function() {
            console.log('=== Testing Multimedia Gallery System ===');
            
            // Reset media collection
            resetMediaCollection();
            
            // Create test media with the provided URLs
            const testMedia = [
                'https://ipfs.copylaradio.com/ipfs/QmZAFi9UPBDYDUPAchBYF1uGisS1p29XsgbiLdfJR5mDkv/2xPhi.png', // Image
                'https://ipfs.copylaradio.com/ipfs/Qmb5WiLq8ESU9RjbnZ7ymYaUkXNS59k6A7Q8JDjBs2SDfw/UPlanetWMobileScreen.png', // Image
                'https://ipfs.copylaradio.com/ipfs/QmYRwJyqXRBErQUJRwyj1bdwvi4vFM1Nj1qV2LMnsYWH91/video_1750867447_3192dcea.mp4', // Video
                'https://ipfs.copylaradio.com/ipfs/QmSQ3dm4u88tQZxsVVqJPxxH5NUYpdLbPFWi597wwjLqkH/00001_Caribou%20_%20Sun.mp3' // Audio
            ];
            
            const testContainer = document.createElement('div');
            testContainer.style.border = '1px solid var(--terminal-orange)';
            testContainer.style.padding = '10px';
            testContainer.style.margin = '10px';
            testContainer.style.backgroundColor = 'var(--terminal-bg)';
            testContainer.style.color = 'var(--text-color)';
            testContainer.style.fontFamily = 'var(--font-family)';
            
            let testHTML = '<h4>🎬 Test Multimedia Gallery - Click media to test navigation and stop functionality:</h4>';
            testMedia.forEach((url, index) => {
                const urlLower = url.toLowerCase();
                let mediaHTML = '';
                
                if (urlLower.match(/\.(jpg|jpeg|png|gif|webp|svg|bmp|ico)$/)) {
                    mediaHTML = `<img src="${url}" alt="Test Image ${index + 1}" style="width: 100px; height: 100px; object-fit: cover; cursor: pointer; border: 1px solid var(--terminal-cyan);" onclick="openMediaModal(${index})" title="Click to open in gallery">`;
                } else if (urlLower.match(/\.(mp4|webm|ogg|mov|avi|mkv)$/)) {
                    mediaHTML = `<video style="width: 100px; height: 100px; object-fit: cover; cursor: pointer; border: 1px solid var(--terminal-green);" onclick="openMediaModal(${index})" title="Click to open in gallery"><source src="${url}"></video>`;
                } else if (urlLower.match(/\.(mp3|wav|ogg|flac|aac|m4a)$/)) {
                    mediaHTML = `<audio style="width: 100px; height: 50px; cursor: pointer; border: 1px solid var(--terminal-purple);" onclick="openMediaModal(${index})" title="Click to open in gallery"><source src="${url}"></audio>`;
                }
                
                testHTML += `<div style="display: inline-block; margin: 5px;">${mediaHTML}</div>`;
            });
            
            testContainer.innerHTML = testHTML;
            document.body.appendChild(testContainer);
            
            console.log('Test multimedia gallery added with real URLs.');
            console.log('Features to test:');
            console.log('• Click on media to open modal');
            console.log('• Navigate between media with arrows or buttons');
            console.log('• Close modal with X, Escape, or clicking outside');
            console.log('• Media should stop playing when modal closes');
            console.log('• Media should stop when navigating to different media');
        };

        // Test function for additional profile fields
        window.testProfileFields = function() {
            console.log('=== Testing Additional Profile Fields ===');
            
            const testContainer = document.createElement('div');
            testContainer.style.border = '1px solid var(--terminal-yellow)';
            testContainer.style.padding = '10px';
            testContainer.style.margin = '10px';
            testContainer.style.backgroundColor = 'var(--terminal-bg)';
            testContainer.style.color = 'var(--text-color)';
            testContainer.style.fontFamily = 'var(--font-family)';
            testContainer.style.maxWidth = '500px';
            
            // Test profile with additional fields
            const testProfileHTML = `
                <div class="profile-banner no-image" title="No banner image"></div>
                <div class="profile-picture-container">
                    <div class="profile-picture no-image">TU</div>
                </div>
                <h3>Test User</h3>
                <div class="profile-additional-fields">
                    <span class="profile-field"><strong>🌐 uDRIVE:</strong> <a href="https://example.com" target="_blank" rel="noopener noreferrer">https://example.com</a></span> • 
                    <span class="profile-field"><strong>🐘 Mastodon:</strong> <a href="https://mastodon.social/@testuser" target="_blank" rel="noopener noreferrer">https://mastodon.social/@testuser</a></span> • 
                    <span class="profile-field"><strong>🔑 MULTIPASS:</strong> MULTIPASS • PRIMAL</span> • 
                    <span class="profile-field"><strong>💳 ZenCard:</strong> zen1qwerty123456789</span>
                </div>
            `;
            
            testContainer.innerHTML = testProfileHTML;
            document.body.appendChild(testContainer);
            
            console.log('Test profile fields added. Check the styling of additional fields.');
        };

        async function getRelayURL() {
            // ipfs. astroport. u. relay.
            const currentUrl = new URL(window.location.href);
            let relayName = currentUrl.hostname.replace('ipfs.', 'relay.');
            if (currentUrl.port === '8080' || currentUrl.port !== '') { // Using '8080' or any port
                return `ws://127.0.0.1:7777`; // Default local relay
            }
            return `wss://${relayName}`;
        }

        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        const hexKey = getUrlParameter('hex');
        let relayUrl; // Will be set in displayNostrData

        const profileContentDiv = document.getElementById('profile-content');
        const messagesContentDiv = document.getElementById('messages-content');
        const profileContainerDiv = document.getElementById('profile-container');
        const messagesContainerDiv = document.getElementById('messages-container');


        if (!hexKey) {
            profileContentDiv.innerText = "HEX key not provided in URL.";
            messagesContentDiv.innerText = "HEX key not provided in URL.";
            profileContainerDiv.classList.remove('loading');
            messagesContainerDiv.classList.remove('loading');
        } else {
            initialHex = hexKey; // Set initialHex when page loads
            
            // Initialize URL parameters for first load
            const currentParams = new URLSearchParams(window.location.search);
            if (!currentParams.has('origin')) {
                currentParams.set('origin', hexKey);
                const newUrl = window.location.pathname + '?' + currentParams.toString();
                window.history.replaceState({ hex: hexKey, action: 'initial' }, '', newUrl);
            }
            
            profileContentDiv.innerText = `Fetching profile for pubkey: ${hexKey.substring(0,10)}...`;
            messagesContentDiv.innerText = `Fetching recent messages...`;

            async function fetchNostrProfile(hex, nostrRelayUrl) { // Renamed relayUrl param
                try {
                    const relay = nostrTools.relayInit(nostrRelayUrl);
                    await relay.connect();
                    const sub = relay.sub([{ kinds: [0], authors: [hex], limit: 1 }]); // Added limit
                    return new Promise((resolve, reject) => {
                        let profileData = null;
                        let timeout = setTimeout(() => {
                            sub.unsub();
                            relay.close();
                            console.warn(`Timeout fetching profile for ${hex}`);
                            resolve({}); // Resolve with empty on timeout
                        }, 5000);

                        sub.on('event', event => {
                            clearTimeout(timeout);
                            try {
                                profileData = JSON.parse(event.content);
                                
                                // Extract additional fields from event tags
                                if (event.tags && Array.isArray(event.tags)) {
                                    event.tags.forEach(tag => {
                                        if (tag.length >= 3 && tag[0] === 'i') {
                                            const value = tag[1];
                                            if (value.startsWith('g1pub:')) {
                                                profileData.g1pub = value.substring(6); // Remove 'g1pub:' prefix
                                            } else if (value.startsWith('website:')) {
                                                profileData.website = value.substring(8); // Remove 'website:' prefix
                                            } else if (value.startsWith('mastodon:')) {
                                                profileData.mastodon = value.substring(9); // Remove 'mastodon:' prefix
                                            } else if (value.startsWith('zencard:')) {
                                                profileData.zencard = value.substring(8); // Remove 'zencard:' prefix
                                            } else if (value.startsWith('email:')) {
                                                profileData.email = value.substring(6); // Remove 'email:' prefix
                                            }
                                        }
                                    });
                                }
                                
                                console.log('Extracted profile data:', profileData);
                                console.log('Event tags:', event.tags);
                            } catch (e) {
                                console.error("Error parsing profile JSON:", e, event.content);
                                profileData = {}; // Fallback
                            }
                            sub.unsub();
                            relay.close();
                            resolve(profileData);
                        });
                        sub.on('eose', () => {
                            if (!profileData) { // If EOSE before event
                                clearTimeout(timeout);
                                sub.unsub();
                                relay.close();
                                resolve({});
                            }
                        });
                        relay.on('error', (err) => { // Changed to err param
                            clearTimeout(timeout);
                            sub.unsub();
                            try { relay.close(); } catch(e) {} // Best effort close
                            console.error(`Relay error fetching profile on ${nostrRelayUrl}:`, err);
                            reject(`Relay error fetching profile`); // More specific error
                        });
                    });
                } catch (error) {
                    console.error("Nostr Profile Fetch Error:", error);
                    throw error; // Re-throw to be caught by displayNostrData
                }
            }

            async function fetchNostrMessages(hex, nostrRelayUrl) {
                try {
                    const relay = nostrTools.relayInit(nostrRelayUrl);
                    await relay.connect();
                    const now = Math.floor(Date.now() / 1000);
                    const oneWeekAgo = now - (7 * 24 * 3600);
                    // Fetch both kind 1 (short messages) and kind 30023 (long-form articles)
                    const sub = relay.sub([{ kinds: [1, 30023], authors: [hex], since: oneWeekAgo, limit: 50 }]);
                    const messages = [];
                    return new Promise((resolve, reject) => {
                        let timeout = setTimeout(() => {
                            sub.unsub();
                            relay.close();
                            console.warn(`Timeout fetching messages for ${hex}`);
                            resolve(messages.sort((a,b) => b.created_at - a.created_at)); // Sort what we have
                        }, 10000);

                        sub.on('event', event => { messages.push(event); });
                        sub.on('eose', () => {
                            clearTimeout(timeout);
                            sub.unsub();
                            relay.close();
                            resolve(messages.sort((a,b) => b.created_at - a.created_at));
                        });
                        relay.on('error', (err) => {
                            clearTimeout(timeout);
                            sub.unsub();
                            try { relay.close(); } catch(e) {}
                            console.error(`Relay error fetching messages on ${nostrRelayUrl}:`, err);
                            reject(`Relay error fetching messages`);
                        });
                    });
                } catch (error) {
                    console.error("Nostr Messages Fetch Error:", error);
                    throw error;
                }
            }

            window.fetchExistingFollowList = async function(publicKey, nostrRelayUrl) {
                try {
                    const relay = nostrTools.relayInit(nostrRelayUrl);
                    await relay.connect();
                    const sub = relay.sub([{ kinds: [3], authors: [publicKey], limit: 1 }]); // Get latest
                    return new Promise((resolve, reject) => {
                        let followListEvent = null;
                        let timeout = setTimeout(() => {
                            sub.unsub();
                            relay.close();
                            console.warn(`Timeout fetching follow list for ${publicKey}`);
                            resolve(null); // Resolve with null on timeout
                        }, 5000);
                        sub.on('event', event => {
                            clearTimeout(timeout);
                            followListEvent = event;
                            sub.unsub();
                            relay.close();
                            resolve(followListEvent);
                        });
                        sub.on('eose', () => {
                             if (!followListEvent) {
                                clearTimeout(timeout);
                                sub.unsub();
                                relay.close();
                                resolve(null);
                            }
                        });
                        relay.on('error', (error) => {
                            clearTimeout(timeout);
                            sub.unsub();
                            try { relay.close(); } catch(e) {}
                            console.error(`Relay error fetching follow list on ${nostrRelayUrl}:`, error);
                            reject(`Relay error fetching follow list`);
                        });
                    });
                } catch (error) {
                    console.error("Error fetching existing follow list:", error);
                    throw error;
                }
            }

            async function displayNostrData() {
                relayUrl = await getRelayURL(); // Set global relayUrl
                
                // Reset media collection for new profile
                resetMediaCollection();
                
                try {
                    const profileData = await fetchNostrProfile(hexKey, relayUrl);
                    profileContainerDiv.classList.remove('loading');
                    
                    // Build profile HTML with banner and picture
                    let profileHTML = '';
                    
                    // Banner section
                    if (profileData.banner) {
                        profileHTML += `<div class="profile-banner" onclick="openImageModal('${profileData.banner}')" title="Click to enlarge banner">
                            <img src="${profileData.banner}" alt="Profile Banner" onerror="this.parentElement.classList.add('no-image')">
                        </div>`;
                    } else {
                        profileHTML += `<div class="profile-banner no-image" title="No banner image"></div>`;
                    }
                    
                    // Profile picture and name section
                    profileHTML += `<div class="profile-picture-container">`;
                    if (profileData.picture) {
                        profileHTML += `<img src="${profileData.picture}" alt="Profile Picture" class="profile-picture" onclick="openImageModal('${profileData.picture}')" title="Click to enlarge profile picture">`;
                    } else {
                        const initials = (profileData.name || profileData.display_name || 'N/A').substring(0, 2).toUpperCase();
                        profileHTML += `<div class="profile-picture no-image" title="No profile picture">${initials}</div>`;
                    }
                    profileHTML += `</div>`;
                    
                    // Name
                    profileHTML += `<h3>${(profileData.name || profileData.display_name || 'N/A')}</h3>`;
                    
                    // About section
                    const aboutText = profileData.about || 'No description available.';
                    profileHTML += `<p>${makeLinksClickable(aboutText)}</p>`;
                    
                    // Additional profile fields
                    let additionalFields = [];
                    
                    // Debug: Log all profile data to see what's available
                    console.log('=== Profile Data Debug ===');
                    console.log('Full profile data:', profileData);
                    console.log('g1pub:', profileData.g1pub);
                    console.log('website:', profileData.website);
                    console.log('mastodon:', profileData.mastodon);
                    console.log('zencard:', profileData.zencard);

                    // Website
                    if (profileData.website) {
                        additionalFields.push(`<span class="profile-field"><strong>🌐 uDRIVE:</strong> <a href="${profileData.website}" target="_blank" rel="noopener noreferrer">${profileData.website}</a></span>`);
                    }
                    
                    // Mastodon
                    if (profileData.mastodon) {
                        additionalFields.push(`<span class="profile-field"><strong>🐘 Mastodon:</strong> <a href="${profileData.mastodon}" target="_blank" rel="noopener noreferrer">${profileData.mastodon}</a></span>`);
                    }

                    // Check ZEN balances for g1pub and zencard
                    console.log('Checking ZEN balances...');
                    const balanceResults = await checkAllZenBalances(profileData);
                    console.log('Balance results:', balanceResults);
                    
                    // Ğ1 Pubkey (can contain multiple keys like "MULTIPASS:PRIMAL")
                    if (profileData.g1pub) {
                        const g1pubText = profileData.g1pub.includes(':') ? 
                            profileData.g1pub.split(':').join(' • ') : 
                            profileData.g1pub;
                        
                        // Add balance information if available
                        let balanceInfo = '';
                        if (balanceResults.multipass) {
                            balanceInfo = ` <span class="balance-info">${balanceResults.multipass.zenBalance} ẐEN</span>`;
                        } else if (balanceResults.g1pub) {
                            balanceInfo = ` <span class="balance-info">${balanceResults.g1pub.zenBalance} ẐEN</span>`;
                        } else {
                            const apiUrl = getApiServerUrl();
                            balanceInfo = ` <a href="${apiUrl}/check_zencard?email=${profileData.email || 'unknown'}" target="_blank" rel="noopener noreferrer" class="balance-info na" style="color: var(--terminal-orange); text-decoration: underline;">Check ZEN Card</a>`;
                        }
                        const shortenedText = `${g1pubText.substring(0, 6)}...${g1pubText.substring(g1pubText.length - 6)}`;
                        additionalFields.push(`<span class="profile-field"><strong>🔑 MULTIPASS: </strong> ${shortenedText} ${balanceInfo}</span>`);
                        console.log('Added Ğ1 field:', g1pubText, balanceInfo);
                    } else {
                        console.log('Ğ1 field is empty or undefined');
                    }

                    
                    // ZenCard
                    if (profileData.zencard && profileData.zencard !== 'None' && profileData.zencard.trim() !== '') {
                        // Add balance information if available
                        let balanceInfo = '';
                        if (balanceResults.zencard) {
                            const apiUrl = getApiServerUrl();
                            balanceInfo = ` <a href="${apiUrl}/check_zencard?email=${profileData.email || 'unknown'}" target="_blank" rel="noopener noreferrer" class="balance-info na" style="color: var(--terminal-orange); text-decoration: underline;">ZEN Card</a>`;
                        }
                        const shortenedZCard = `${profileData.zencard.substring(0, 6)}...${profileData.zencard.substring(profileData.zencard.length - 6)}`;
                        additionalFields.push(`<span class="profile-field"><strong>💳 ZenCard:</strong> ${shortenedZCard} ${balanceInfo}</span>`);
                    } else if (profileData.zencard === 'None' || profileData.zencard === '') {
                        additionalFields.push(`<span class="profile-field"><strong>💳 ZenCard:</strong> <span style="color: var(--terminal-orange); font-style: italic;">...</span></span>`);
                    }
                    
                    // Display additional fields if any
                    if (additionalFields.length > 0) {
                        profileHTML += `<div class="profile-additional-fields">${additionalFields.join('')}</div>`;
                    }
                    
                    profileContentDiv.innerHTML = profileHTML;
                    // addToHistory(hexKey); // Removed - now handled in loadProfile
                } catch (profileError) {
                    console.error("Profile display error:", profileError);
                    profileContainerDiv.classList.remove('loading');
                    profileContentDiv.innerHTML = `<p style="color:var(--terminal-red)">Error loading profile from ${relayUrl}: ${profileError.message || profileError}</p>`;
                }

                try {
                    const messagesData = await fetchNostrMessages(hexKey, relayUrl);
                    window.currentMessagesData = messagesData; // Store for article expansion
                    messagesContainerDiv.classList.remove('loading');
                    let messagesHTML = '';
                    if (messagesData && messagesData.length > 0) {
                        // Already sorted by fetchNostrMessages
                        messagesData.forEach(message => {
                            const date = new Date(message.created_at * 1000);
                            
                            // Handle kind 30023 (Long-form Content) differently
                            if (message.kind === 30023) {
                                // Extract title from tags
                                let title = 'Article';
                                let articleTags = [];
                                if (message.tags) {
                                    const titleTag = message.tags.find(tag => tag[0] === 'title');
                                    if (titleTag && titleTag[1]) title = titleTag[1];
                                    
                                    // Extract hashtags
                                    const tTags = message.tags.filter(tag => tag[0] === 't');
                                    articleTags = tTags.map(tag => tag[1]).filter(t => t);
                                }
                                
                                // Truncate content for preview (first 200 chars)
                                const content = message.content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                                const preview = content.substring(0, 200) + (content.length > 200 ? '...' : '');
                                const clickablePreview = makeLinksClickable(preview);
                                
                                messagesHTML += `<div class="message-item" style="border-left: 3px solid var(--terminal-purple); padding-left: 10px;">
                                                    <button class="heart-button" onclick="likeMessage('${message.id}', '${hexKey}', this)" title="Like this article">
                                                        ♡
                                                    </button>
                                                    <div style="flex: 1;">
                                                        <strong style="color: var(--terminal-purple);">📄 ${title}</strong>
                                                        <div style="font-size: 0.85em; color: var(--terminal-cyan); margin: 3px 0;">
                                                            ${date.toLocaleDateString()} ${date.toLocaleTimeString()}
                                                            ${articleTags.length > 0 ? ' • ' + articleTags.map(t => '#' + t).join(' ') : ''}
                                                        </div>
                                                        <p style="margin-top: 5px;">${clickablePreview}</p>
                                                        ${content.length > 200 ? `<a href="#" onclick="showFullArticle('${message.id}', this); return false;" style="color: var(--terminal-green); font-size: 0.9em;">Read full article ▼</a>` : ''}
                                                    </div>
                                                </div>`;
                            } else {
                                // Handle kind 1 (regular short messages)
                                const content = message.content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                                const clickableContent = makeLinksClickable(content);
                                messagesHTML += `<div class="message-item">
                                                    <button class="heart-button" onclick="likeMessage('${message.id}', '${hexKey}', this)" title="Like this message">
                                                        ♡
                                                    </button>
                                                    <div style="flex: 1;">
                                                        <strong>${date.toLocaleDateString()} ${date.toLocaleTimeString()}</strong>
                                                        <p>${clickableContent}</p>
                                                    </div>
                                                </div>`;
                            }
                        });
                    } else {
                        messagesHTML = "<p>No recent messages found for this pubkey on this relay.</p>";
                    }
                    messagesContentDiv.innerHTML = messagesHTML;
                } catch (messagesError) {
                    console.error("Messages display error:", messagesError);
                    messagesContainerDiv.classList.remove('loading');
                    messagesContentDiv.innerHTML = `<p style="color:var(--terminal-red)">Error loading messages from ${relayUrl}: ${messagesError.message || messagesError}</p>`;
                }
            }
            displayNostrData();
        }

        // Function to toggle full article display
        window.showFullArticle = function(messageId, linkElement) {
            const messageDiv = linkElement.closest('.message-item');
            const contentP = messageDiv.querySelector('p');
            
            // Find the full message from messagesData
            const message = window.currentMessagesData.find(m => m.id === messageId);
            if (!message) {
                console.error('Message not found:', messageId);
                return;
            }
            
            // Check if already expanded
            if (linkElement.dataset.expanded === 'true') {
                // Collapse back to preview
                const content = message.content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const preview = content.substring(0, 200) + '...';
                contentP.innerHTML = makeLinksClickable(preview);
                linkElement.textContent = 'Read full article ▼';
                linkElement.dataset.expanded = 'false';
            } else {
                // Expand to full content
                const fullContent = message.content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                contentP.innerHTML = makeLinksClickable(fullContent);
                linkElement.textContent = 'Show less ▲';
                linkElement.dataset.expanded = 'true';
            }
        };

        async function likeMessage(messageId, authorPubkey, heartButton) {
            const nostr = getNostrExtension();
            if (!nostr) {
                alert("Nostr extension (NOSTR Connect, Alby, nos2x) not detected.");
                return;
            }

            try {
                // Show loading state
                heartButton.classList.add('loading');
                const originalContent = heartButton.innerHTML;
                heartButton.innerHTML = '♡';
                heartButton.disabled = true;

                const userPublicKey = await nostr.getPublicKey();
                // relayUrl should be set by displayNostrData, if not, get it again
                if (!relayUrl) relayUrl = await getRelayURL();

                // Create like event (kind 7 - reaction)
                const likeEvent = {
                    kind: 7,
                    pubkey: userPublicKey,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ["e", messageId], // Reference to the liked event
                        ["p", authorPubkey] // Reference to the author's pubkey
                    ],
                    content: "♥" // The reaction content
                };

                const signedEvent = await nostr.signEvent(likeEvent);
                const relay = nostrTools.relayInit(relayUrl);
                await relay.connect();
                await relay.publish(signedEvent);
                relay.close();

                // Success state
                heartButton.classList.remove('loading');
                heartButton.classList.add('liked');
                heartButton.innerHTML = '♥';
                heartButton.title = 'Liked!';
                
                // Keep the liked state - don't reset
                heartButton.disabled = false;

            } catch (error) {
                console.error("Error during like action:", error);
                
                // Error state
                heartButton.classList.remove('loading');
                heartButton.innerHTML = originalContent;
                heartButton.disabled = false;
                
                alert(`Error liking message: ${error.message || error}`);
            }
        }

        followButton.addEventListener('click', async function(event) {
            event.preventDefault();
            const followErrorMessageDiv = document.getElementById('follow-error-message');
            followErrorMessageDiv.textContent = "";

            const nostr = getNostrExtension();
            if (!nostr) {
                followErrorMessageDiv.textContent = "Nostr extension (NOSTR Connect, Alby, nos2x) not detected.";
                return;
            }
            if (!hexKey) {
                followErrorMessageDiv.textContent = "Target pubkey (HEX) not available.";
                return;
            }

            try {
                followButton.disabled = true;
                followButton.textContent = "Processing...";
                const userPublicKey = await nostr.getPublicKey();
                // relayUrl should be set by displayNostrData, if not, get it again
                if (!relayUrl) relayUrl = await getRelayURL();

                const existingFollowListEvent = await window.fetchExistingFollowList(userPublicKey, relayUrl);
                let currentFollowsTags = []; // Store full tags ["p", pubkey, relay_url, name]
                if (existingFollowListEvent && existingFollowListEvent.tags) {
                    currentFollowsTags = existingFollowListEvent.tags.filter(tag => tag[0] === 'p');
                }

                const isAlreadyFollowing = currentFollowsTags.some(tag => tag[1] === hexKey);

                if (!isAlreadyFollowing) {
                    // Add new follow. For simplicity, we don't fetch the name/relay for the new follow tag.
                    // A more complete implementation might try to fetch profile for name.
                    currentFollowsTags.push(["p", hexKey, "", ""]); // Recommended relay and petname are often empty
                } else {
                    // Optional: If already following, maybe unfollow or just indicate already following.
                    // For this example, we'll proceed as if updating (which re-adds if not present).
                    // Or, you could show a different message:
                    // followErrorMessageDiv.textContent = "Already following this user.";
                    // followButton.textContent = "Already Following";
                    // setTimeout(() => { /* reset button */ }, 2000);
                    // return;
                }


                const newEvent = {
                    kind: 3,
                    pubkey: userPublicKey,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: currentFollowsTags, // Use the modified list of tags
                    content: existingFollowListEvent ? existingFollowListEvent.content : "" // Preserve original content if any
                };

                const signedEvent = await nostr.signEvent(newEvent);
                const relay = nostrTools.relayInit(relayUrl);
                await relay.connect();
                await relay.publish(signedEvent);
                relay.close();

                followButton.style.backgroundColor = 'var(--terminal-cyan)';
                followButton.textContent = 'Followed!';
            } catch (error) {
                console.error("Error during follow action:", error);
                followErrorMessageDiv.textContent = `Error: ${error.message || error}`;
                followButton.style.backgroundColor = 'var(--terminal-red)';
                followButton.textContent = 'Follow Failed';
            } finally {
                setTimeout(() => {
                    followButton.disabled = false;
                    followButton.textContent = 'Follow';
                    followButton.style.backgroundColor = originalButtonBgColor; // Reset to original dynamic color
                }, 3000);
            }
        });

        // Test function for the specific problematic nprofile
        window.testSpecificNprofile = function() {
            console.log('=== Testing Specific Nprofile ===');
            
            const testNprofile = 'nostr:nprofile1qythwumn8ghj7un9d3shjtnswf5k6ctv9ehx2ap0qyfhwumn8ghj7ur4wfcxcetsv9njuetn9uq32amnwvaz7tmjv4kxz7fwv3sk6atn9e5k7tcpzdmhxue69uhhqmmnw3jhytnsd3skxef0qyv8wumn8ghj7un9d3shjtn8v4uhxetj9en82mny9uqs7amnwvaz7tmev4ehgu3wd4jj7qgcwaehxw309ajxjun9vd6x7une9eukzcn49ekk2tcqyqlr8lt3ynchflzn29gexlu8rp35mkwc2c2r6n80kkssmkhj7c2uqfhms5h';
            
            console.log('Testing nprofile:', testNprofile);
            console.log('Length:', testNprofile.length);
            
            // Test the regex match
            const nprofileRegex = /(nostr:)?(nprofile1[a-z0-9]+)/gi;
            const match = nprofileRegex.exec(testNprofile);
            console.log('Regex match:', match);
            
            if (match) {
                console.log('Prefix:', match[1]);
                console.log('Nprofile part:', match[2]);
                
                // Test the decoding
                const hex = nprofileToHexEnhanced(match[2]);
                console.log('Decoded hex:', hex);
                
                if (hex) {
                    console.log('✅ SUCCESS: Nprofile decoded successfully');
                    console.log('Hex key:', hex);
                    
                    // Test the link generation
                    const linkHtml = `<a href="#" onclick="loadProfile('${hex}'); return false;" class="nprofile-link" title="View profile for ${hex.substring(0,10)}...">${testNprofile}</a>`;
                    console.log('Generated link HTML:', linkHtml);
                    
                    // Create a test div to show the result
                    const testDiv = document.createElement('div');
                    testDiv.innerHTML = linkHtml;
                    testDiv.style.border = '2px solid var(--terminal-green)';
                    testDiv.style.padding = '10px';
                    testDiv.style.margin = '10px';
                    testDiv.style.backgroundColor = 'var(--terminal-bg)';
                    testDiv.style.color = 'var(--text-color)';
                    testDiv.style.fontFamily = 'var(--font-family)';
                    
                    document.body.appendChild(testDiv);
                    console.log('✅ Test div added - click the link to test navigation');
                } else {
                    console.log('❌ FAILED: Nprofile decoding failed');
                }
            } else {
                console.log('❌ FAILED: Regex did not match');
            }
        };

        // Function to calculate API server URL from current location
        function getApiServerUrl() {
            const currentUrl = window.location.href;
            const url = new URL(currentUrl);
            
            // Replace ipfs. with u. in hostname
            let hostname = url.hostname.replace(/^ipfs\./, 'u.');
            
            // Replace port 8080 with 54321 if present
            let port = url.port;
            if (port === '8080') {
                port = '54321';
            }
            
            // Build the API URL
            const protocol = url.protocol;
            const apiUrl = port ? `${protocol}//${hostname}:${port}` : `${protocol}//${hostname}`;
            
            console.log('Calculated API server URL:', apiUrl);
            return apiUrl;
        }

        // Function to check ZEN balance for a g1pub
        async function checkZenBalance(g1pub) {
            try {
                const apiUrl = getApiServerUrl();
                const response = await fetch(`${apiUrl}/check_balance?g1pub=${g1pub}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Balance response for', g1pub, ':', data);
                
                if (data.balance && data.g1pub) {
                    // Convert Ğ1 to ZEN: (Ğ1_BALANCE - 1) * 10
                    const g1Balance = parseFloat(data.balance);
                    const zenBalance = Math.floor((g1Balance - 1) * 10);
                    
                    return {
                        g1Balance: g1Balance,
                        zenBalance: zenBalance,
                        g1pub: data.g1pub
                    };
                } else {
                    throw new Error('Invalid balance response format');
                }
            } catch (error) {
                console.error('Error checking ZEN balance for', g1pub, ':', error);
                return null;
            }
        }

        // Function to check balances for all g1pub addresses in a profile
        async function checkAllZenBalances(profileData) {
            const balanceResults = {};
            
            // Check Ğ1 balance (handles both MULTIPASS:PRIMAL format and simple g1pub)
            if (profileData.g1pub) {
                const g1pubParts = profileData.g1pub.split(':');
                if (g1pubParts.length >= 2) {
                    // MULTIPASS:PRIMAL format - check MULTIPASS part only
                    const multipassPub = g1pubParts[0]; // MULTIPASS part only
                    console.log('Checking MULTIPASS balance for:', multipassPub);
                    const multipassBalance = await checkZenBalance(multipassPub);
                    if (multipassBalance) {
                        balanceResults.multipass = multipassBalance;
                    }
                } else {
                    // Simple g1pub format - check the entire address
                    console.log('Checking simple Ğ1 balance for:', profileData.g1pub);
                    const g1Balance = await checkZenBalance(profileData.g1pub);
                    if (g1Balance) {
                        balanceResults.g1pub = g1Balance;
                    }
                }
            }
            
            // Check ZenCard balance if available
            if (profileData.zencard && profileData.zencard !== 'None' && profileData.zencard.trim() !== '') {
                console.log('Checking ZenCard balance for:', profileData.zencard);
                const zencardBalance = await checkZenBalance(profileData.zencard);
                if (zencardBalance) {
                    balanceResults.zencard = zencardBalance;
                }
            }
            
            return balanceResults;
        }
    </script>
</body>
</html>
