<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåø uPlanet Flora Explorer - PlantNet Integration</title>
    <!-- Nostr integration -->
    <script src="/ipfs/QmXEmaPRUaGcvhuyeG99mHHNyP43nn8GtNeuDok8jdpG4a/nostr.bundle.js"></script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="/ipns/copylaradio.com/leaflet.css"/>
    <!-- Leaflet JavaScript -->
    <script src="/ipns/copylaradio.com/leaflet.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            min-height: 100vh;
        }
        .container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 {
            color: #4ade80;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
        }
        
        .subtitle {
            text-align: center;
            color: #94a3b8;
            font-size: 1.1em;
            margin-bottom: 30px;
            font-weight: 300;
        }
        .controls {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #e2e8f0;
        }
        input, button {
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.05);
            color: #e2e8f0;
            transition: all 0.3s ease;
        }
        input:focus {
            outline: none;
            border-color: #4ade80;
            box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);
        }
        button {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
            border: none;
            cursor: pointer;
            margin-right: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        button:hover {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .info-card {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            border-left: 4px solid #4ade80;
            transition: all 0.3s ease;
        }
        .info-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        .info-card.montante {
            border-left-color: #4ade80;
        }
        .info-card.descendante {
            border-left-color: #f87171;
        }
        .calendar-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .calendar-table th,
        .calendar-table td {
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 12px;
            text-align: left;
        }
        .calendar-table th {
            background: rgba(74, 222, 128, 0.2);
            color: #e2e8f0;
            font-weight: 600;
        }
        .montante-row {
            background: rgba(74, 222, 128, 0.1);
        }
        .descendante-row {
            background: rgba(248, 113, 113, 0.1);
        }
        .current-period {
            font-weight: bold;
            background: rgba(74, 222, 128, 0.2) !important;
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        .export-section {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            background: rgba(74, 222, 128, 0.1);
            border: 1px solid rgba(74, 222, 128, 0.2);
            border-radius: 15px;
        }
        .moon-icon {
            font-size: 20px;
            margin-right: 5px;
        }
        .nostr-section {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-top: 30px;
        }
        .photo-upload {
            border: 2px dashed #4ade80;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(74, 222, 128, 0.05);
        }
        .photo-upload:hover {
            border-color: #22c55e;
            background: rgba(74, 222, 128, 0.1);
            transform: translateY(-2px);
        }
        .photo-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .location-info {
            background: rgba(74, 222, 128, 0.1);
            border: 1px solid rgba(74, 222, 128, 0.2);
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
            line-height: 1.6;
            color: #2c3e50;
            transition: all 0.3s ease;
        }
        
        .location-info strong {
            display: inline-block;
            margin-right: 5px;
            color: #2c3e50;
        }
        .nostr-login {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px 0;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .nostr-login:hover {
            background: linear-gradient(135deg, #4f46e5, #4338ca);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }
        .message-form {
            display: none;
            margin-top: 20px;
        }
        .message-form textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            margin: 10px 0;
            resize: vertical;
            background: rgba(255, 255, 255, 0.05);
            color: #e2e8f0;
            transition: all 0.3s ease;
        }
        .message-form textarea:focus {
            outline: none;
            border-color: #4ade80;
            box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);
        }
        .send-button {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .send-button:hover {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }
        .send-button:disabled {
            background: rgba(148, 163, 184, 0.5);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* Profile and Messages Section Styles */
        .profile-section {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            display: none;
        }
        
        .profile-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            transition: all 0.3s ease;
        }
        
        .profile-header:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        .profile-toggle {
            font-size: 18px;
            transition: transform 0.3s ease;
        }
        
        .profile-toggle.expanded {
            transform: rotate(180deg);
        }
        
        .profile-content {
            display: none;
            margin-top: 15px;
        }
        
        .profile-content.expanded {
            display: block;
        }
        
        .profile-info {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .profile-picture {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #3498db;
        }
        
        .profile-details h3 {
            margin: 0 0 5px 0;
            color: #e2e8f0;
            font-weight: 600;
        }
        
        .profile-details p {
            margin: 0;
            color: #94a3b8;
            font-size: 14px;
        }
        
        .messages-section {
            margin-top: 20px;
        }
        
        .message-item {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .message-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .message-content {
            flex: 1;
        }
        
        .message-meta {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 8px;
        }
        
        .message-text {
            color: #e2e8f0;
            line-height: 1.4;
        }
        
        .loading {
            text-align: center;
            color: #94a3b8;
            font-style: italic;
        }
        
        .no-messages {
            text-align: center;
            color: #94a3b8;
            font-style: italic;
            padding: 20px;
        }
        
        /* Message Navigation Styles */
        #message-navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            gap: 10px;
        }
        
        #message-navigation button {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #message-navigation button:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        #message-navigation button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Replies Section Styles */
        #replies-area {
            margin-top: 20px;
        }
        
        #replies-area h3 {
            color: #e2e8f0;
            font-size: 1.1em;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }
        
        #replies-list {
            list-style: none;
            padding: 0;
        }
        
        .reply-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        
        .reply-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-1px);
        }
        
        .reply-author {
            font-size: 0.85em;
            color: #94a3b8;
            margin-bottom: 8px;
        }
        
        .reply-author code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        
        .reply-content {
            color: #e2e8f0;
            line-height: 1.5;
        }
        
        .reply-content img {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            margin: 8px 0;
        }
        
        .reply-content a {
            color: #4ade80;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .reply-content a:hover {
            color: #22c55e;
            text-decoration: underline;
        }
        
        /* Delete Button Styles */
        .delete-button {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-left: 10px;
            opacity: 0.8;
        }
        
        .delete-button:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
            opacity: 1;
        }
        
        .delete-button:disabled {
            background: rgba(148, 163, 184, 0.5);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
        }
        
        .message-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .message-actions .delete-button {
            margin-left: auto;
        }
        
        #last-message-area .message-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        #last-message-area .message-content img {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            margin: 8px 0;
        }
        
        #last-message-area .message-meta {
            font-size: 0.8em;
            color: #94a3b8;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Location Controls & Map Styles */
        #location-controls {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            margin: 15px 0;
            display: block;
        }
        
        .coord-control {
            text-align: center;
            margin: 10px 0;
            min-width: 200px;
        }
        
        .coord-control > div {
            justify-content: center;
            display: flex;
            align-items: center;
            gap: 3px;
            flex-wrap: nowrap;
            min-width: 180px;
        }
        
        .tumbler {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            padding: 4px 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #e2e8f0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85em;
            font-weight: bold;
            border-radius: 6px;
            margin: 0 1px;
            text-align: center;
            cursor: pointer;
            min-width: 28px;
            max-width: 35px;
            width: 32px;
            transition: all 0.3s ease;
        }
        
        .tumbler:focus {
            outline: none;
            border-color: #4ade80;
            box-shadow: 0 0 5px rgba(74, 222, 128, 0.3);
        }
        
        .tumbler-dot {
            font-size: 1.2em;
            font-weight: bold;
            margin: 0 5px;
            color: #94a3b8;
        }
        
        #location-status {
            min-height: 1.1em;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 0.9em;
            color: #94a3b8;
        }
        
        #location-status:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Map accordion styles */
        .map-accordion {
            margin-top: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }
        
        .map-accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .map-accordion-header:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        .map-toggle {
            font-size: 16px;
            transition: transform 0.3s ease;
        }
        
        .map-toggle.expanded {
            transform: rotate(180deg);
        }
        
        .map-accordion-content {
            padding: 15px;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        
        .map-accordion-content.closed {
            max-height: 0;
            padding: 0 15px;
        }
        
        .map-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .coord-input {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .coord-input label {
            font-weight: bold;
            color: #e2e8f0;
            margin: 0;
            min-width: 30px;
            font-size: 0.8em;
        }
        
        .coord-input input {
            width: 80px;
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 0.85em;
            background: rgba(255, 255, 255, 0.05);
            color: #e2e8f0;
        }
        
        .coord-input input:focus {
            border-color: #4ade80;
            outline: none;
            box-shadow: 0 0 0 2px rgba(74, 222, 128, 0.1);
        }
        
        .map-button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .map-button:hover {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(74, 222, 128, 0.3);
        }
        
        .map-button.secondary {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
        }
        
        .map-button.secondary:hover {
            background: linear-gradient(135deg, #4f46e5, #4338ca);
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }
        
        .map-button.nearby {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        
        .map-button.nearby:hover {
            background: linear-gradient(135deg, #d97706, #b45309);
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
        }
        
        #mini-map {
            height: 400px;
            width: 100%;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            background: #f0f0f0;
            min-height: 400px;
        }
        
        /* Nearby Messages Styles */
        .nearby-message-marker {
            background: #f59e0b;
            border: 2px solid white;
            border-radius: 50%;
            width: 12px;
            height: 12px;
        }
        
        .umap-marker {
            background: #4ade80 !important; /* Green for UMAPs */
        }
        
        .sector-marker {
            background: #3b82f6 !important; /* Blue for SECTORS */
        }
        
        .region-marker {
            background: #ef4444 !important; /* Red for REGIONS */
        }
        
        .nearby-popup {
            max-width: 300px;
        }
        
        .nearby-popup-content {
            padding: 8px;
        }
        
        .nearby-popup-author {
            font-weight: bold;
            color: #1e40af;
            margin-bottom: 8px;
            cursor: pointer;
            text-decoration: underline;
        }
        
        .nearby-popup-author:hover {
            color: #3b82f6;
        }
        
        .nearby-popup-text {
            margin: 8px 0;
            line-height: 1.4;
        }
        
        .nearby-popup-image {
            max-width: 100%;
            border-radius: 6px;
            margin: 8px 0;
        }
        
        .nearby-popup-meta {
            font-size: 0.8em;
            color: #666;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e0e0e0;
        }
        
        .loading-nearby {
            text-align: center;
            padding: 10px;
            color: #f59e0b;
            font-weight: bold;
        }
        
        /* Responsive Design */
        @media screen and (max-width: 768px) {
            .container {
                padding: 10px;
                margin: 10px auto;
            }
            
            .nostr-section {
                margin-bottom: 15px;
            }
            
            .nostr-section > div:first-child {
                flex-direction: column;
                gap: 10px;
            }
            
            .nostr-section h3 {
                font-size: 16px;
                margin: 0;
            }
            
            .nostr-section p {
                font-size: 12px;
                margin: 5px 0;
            }
            
            #nostr-message-section > div:first-child {
                flex-direction: column;
                gap: 10px;
            }
            
            .photo-upload {
                min-width: 100%;
            }
            
            textarea {
                min-width: 100%;
            }
            
            .send-button {
                width: 100%;
            }
            
            #location-controls {
                margin-bottom: 10px;
            }
            
            #location-values {
                flex-direction: column;
                gap: 10px;
            }
            
            .coord-control {
                width: 100%;
            }
            
            .coord-control > div {
                justify-content: center;
                flex-wrap: wrap;
                gap: 3px;
            }
            
            .tumbler {
                padding: 4px 6px;
                font-size: 0.85em;
                min-width: 28px;
                max-width: 35px;
            }
            
            .tumbler-dot {
                font-size: 1em;
                margin: 0 2px;
            }
            
            .map-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .coord-input {
                justify-content: center;
            }
            
            #mini-map {
                height: 300px;
            }
        }
        
        @media screen and (max-width: 480px) {
            .tumbler {
                padding: 3px 4px;
                font-size: 0.8em;
                min-width: 25px;
                max-width: 30px;
            }
            
            #mini-map {
                height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåø uPlanet Flora Explorer</h1>
        <p class="subtitle">Cataloguez la flore avec PlantNet (#BRO #plantnet)</p>
        
        <!-- Nostr Integration Section - Moved to top -->
        <div class="nostr-section" style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                <div>
                    <h3 style="margin: 0; font-size: 18px;">üå± Partagez vos Observations</h3>
                    <p style="margin: 5px 0 0 0; font-size: 14px; color: var(--muted);">Connectez-vous pour r√©pertorier les plantes sur uPlanet</p>
                </div>
                <button class="nostr-login" id="nostrLoginBtn" onclick="handleNostrLogin()" style="margin: 0;">Nostr Connect</button>
            </div>
            
            <div id="nostr-message-section" class="message-form" style="margin-top: 15px;">
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <div class="photo-upload" onclick="document.getElementById('photoInput').click()" style="flex: 1; min-width: 200px;">
                        <div id="photoUploadText">üì∑ Ajouter une photo</div>
                        <img id="photoPreview" class="photo-preview" style="display: none;">
                    </div>
                    <input type="file" id="photoInput" accept="image/*" capture="environment" style="display: none;" onchange="handlePhotoUpload(event)">
                    
                    <textarea id="messageText" placeholder="Description (optionnel)..." rows="2" style="flex: 1; min-width: 200px; margin: 0;"></textarea>
                    
                    <button class="send-button" id="sendMessageBtn" onclick="sendGeolocatedMessage()" style="margin: 0;">üå± Partager</button>
                </div>
                
                <div id="locationInfo" class="location-info" style="display: none; margin-top: 10px;">
                    <strong>üìç Position:</strong> <span id="locationText"></span>
                </div>
                
                <div id="plantnetResult" class="location-info" style="display: none; margin-top: 10px; background: #e8f4fd;">
                    <strong>üåø PlantNet:</strong> <span id="plantnetText"></span>
                </div>
            </div>
            
            <!-- Location Adjustment UI - Moved outside nostr-message-section -->
            <div id="location-controls">
                <!-- Map Accordion -->
                <div id="map-accordion" class="map-accordion">
                    <div class="map-accordion-header" onclick="toggleMapAccordion()">
                        <h4 style="margin: 0; font-size: 14px; color: #e2e8f0;">üó∫Ô∏è Carte Interactive</h4>
                        <span class="map-toggle">‚ñº</span>
                    </div>
                    <div class="map-accordion-content">
                        <div class="map-controls">
                            <div class="coord-input">
                                <label>Lat:</label>
                                <input type="number" id="lat-display" step="0.01" min="-90" max="90" value="48.86">
                            </div>
                            <div class="coord-input">
                                <label>Lon:</label>
                                <input type="number" id="lon-display" step="0.01" min="-180" max="180" value="2.35">
                            </div>
                            <button type="button" class="map-button" id="update-map">Y aller</button>
                            <button type="button" class="map-button secondary" id="get-location">Ma position</button>
                            <button type="button" class="map-button nearby" id="load-nearby">üåç Messages environs</button>
                        </div>
                        <div id="mini-map"></div>
                        <div style="padding: 8px 0; font-size: 0.8em; color: #7f8c8d; text-align: center;">
                            üí° Cliquez sur la carte pour ajuster votre position
                        </div>
                        <div style="margin-top: 10px; padding: 8px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; font-size: 0.75em;">
                            <div style="margin-bottom: 4px; font-weight: bold; color: #e2e8f0;">L√©gende des marqueurs :</div>
                            <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 8px;">
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <div style="width: 12px; height: 12px; background: #4ade80; border: 2px solid white; border-radius: 50%;"></div>
                                    <span>UMAP (~500m)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <div style="width: 12px; height: 12px; background: #3b82f6; border: 2px solid white; border-radius: 50%;"></div>
                                    <span>SECTOR (~10km)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <div style="width: 12px; height: 12px; background: #ef4444; border: 2px solid white; border-radius: 50%;"></div>
                                    <span>REGION (~100km)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Profile and Messages Section -->
        <div id="profile-section" class="profile-section">
            <div class="profile-header" onclick="toggleProfileSection()">
                <h3 style="margin: 0;">üë§ Mon Profil & Messages R√©cents</h3>
                <span class="profile-toggle">‚ñº</span>
            </div>
            <div id="profile-content" class="profile-content">
                <div id="profile-info" class="profile-info">
                    <div class="loading">Chargement du profil...</div>
                </div>
                <div id="messages-section" class="messages-section">
                    <h4>Messages R√©cents</h4>
                    <!-- Message Navigation -->
                    <div id="message-navigation">
                        <button id="older-button" disabled> ‚óÄ Ancien </button>
                        <button id="refresh-button">üîÑ Actualiser</button>
                        <button id="newer-button" disabled> R√©cent ‚ñ∂ </button>
                    </div>
                    <!-- Current Message Display -->
                    <div id="last-message-area">
                        <div class="loading">Chargement des messages...</div>
                    </div>
                    <!-- Replies Section -->
                    <div id="replies-area">
                        <h3>üí¨ R√©ponses</h3>
                        <ul id="replies-list">
                            <li class="loading">S√©lectionnez un message...</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="calculateLunarCalendar()">Calculer le Calendrier Lunaire</button>
        </div>

        <div class="info-grid">
            <div class="info-card montante">
                <h3>üå± Lune Montante</h3>
                <p><strong>La s√®ve monte</strong> dans les parties a√©riennes de la plante.</p>
                <ul>
                    <li>Semis et plantations</li>
                    <li>Greffes</li>
                    <li>R√©colte des fruits et l√©gumes-fruits</li>
                    <li>Travail du sol l√©ger</li>
                </ul>
            </div>
            <div class="info-card descendante">
                <h3>üçÇ Lune Descendante</h3>
                <p><strong>La s√®ve redescend</strong> vers les racines.</p>
                <ul>
                    <li>Plantation et repiquage</li>
                    <li>Tailles et √©lagages</li>
                    <li>Bouturages</li>
                    <li>Travail du sol profond</li>
                    <li>Apports d'engrais</li>
                </ul>
            </div>
        </div>

        <div id="results">
            <h2>Calendrier Lunaire de l'Ann√©e <span id="current-year"></span></h2>
            <div id="calendar-table-container"></div>
        </div>

        <div class="export-section">
            <h3>Exporter le Calendrier</h3>
            <p>T√©l√©chargez le calendrier lunaire complet au format iCal pour l'importer dans votre application de calendrier.</p>
            <button onclick="generateICalFile()">üì• T√©l√©charger le fichier .ics</button>
        </div>

    </div>

    <script>
        // Nostr Integration Variables
        let DEFAULT_RELAYS = [ // This will be dynamically set
            'wss://relay.copylaradio.com',
            'ws://127.0.0.1:7777',
            'wss://relay.damus.io',
            'wss://nos.lol'
        ];
        let nostrRelay = null;
        let isNostrConnected = false;
        let userPubkey = null;
        let currentLocation = null;
        let selectedPhoto = null;
        
        // Message navigation variables
        let fetchedMessages = [];
        let currentMessageIndex = 0;
        const MESSAGES_PER_PAGE = 20;

        // Variables globales pour l'API uSPOT
        let USPOT_API_BASE = '';
        let USPOT_RELAY = '';

        // Function to get API base URL (following generate_ipfs_structure.sh pattern)
        function getAPIBaseUrl() {
            return USPOT_API_BASE;
        }

        // D√©tection de l'API uSPOT et des relais par d√©faut
        function detectUSPOTAPI() {
            const currentURL = new URL(window.location.href);
            const hostname = currentURL.hostname;
            const port = currentURL.port;
            const protocol = currentURL.protocol.split(":")[0];

            let determinedRelay = '';
            let apiBase = '';

            if (hostname === "127.0.0.1" && port === "8080") {
                determinedRelay = `ws://127.0.0.1:7777`;
                apiBase = `http://127.0.0.1:54321`;
            } else if (hostname.startsWith("ipfs.")) {
                const baseDomain = hostname.substring("ipfs.".length);
                determinedRelay = `wss://relay.${baseDomain}`;
                apiBase = `https://u.${baseDomain}`;
            } else {
                // Fallback for other environments or if detection fails
                determinedRelay = `wss://relay.copylaradio.com`;
                apiBase = `https://u.copylaradio.com`;
            }

            DEFAULT_RELAYS = [determinedRelay, 'wss://relay.damus.io', 'wss://nos.lol'];
            USPOT_API_BASE = apiBase;
            USPOT_RELAY = determinedRelay;

            console.log(`uSPOT API Base d√©tect√©e: ${USPOT_API_BASE}`);
            console.log(`Relay par d√©faut d√©tect√©: ${DEFAULT_RELAYS[0]}`);
            console.log(`Gateway IPFS: ${hostname}:${port}`);
        }

        // Nostr Connection Functions
        async function handleNostrLogin() {
            if (typeof window.nostr === 'undefined' || typeof window.nostr.getPublicKey !== 'function') {
                alert("L'extension Nostr est requise pour la connexion.");
                return;
            }
            
            try {
                console.log("Attempting to get public key from Nostr extension...");
                const pubkey = await window.nostr.getPublicKey();
                if (pubkey) {
                    userPubkey = pubkey;
                    console.log("Public key obtained:", pubkey);
                    updateNostrUI(true);
                    console.log("Connecting to Nostr relay after successful public key retrieval...");
                    await connectToNostrRelay();
                    
                    // Load profile and messages after successful connection
                    if (isNostrConnected) {
                        console.log("Loading profile and messages...");
                        await loadUserProfileAndMessages();
                    }
                } else {
                    alert("Impossible de r√©cup√©rer la cl√© publique. Autorisez l'acc√®s dans votre extension Nostr.");
                }
            } catch (error) {
                alert("La connexion a √©chou√©. Veuillez autoriser l'acc√®s dans votre extension Nostr.");
                console.error("Erreur de connexion Nostr:", error);
            }
        }

        function updateNostrUI(isLoggedIn) {
            const loginSection = document.getElementById('nostr-login-section');
            const messageSection = document.getElementById('nostr-message-section');
            const loginBtn = document.getElementById('nostrLoginBtn');
            const profileSection = document.getElementById('profile-section');
            
            if (isLoggedIn) {
                loginBtn.textContent = `Connect√© : ${userPubkey.substring(0, 6)}...${userPubkey.substring(userPubkey.length - 4)}`;
                loginBtn.style.background = '#27ae60';
                messageSection.style.display = 'block';
                profileSection.style.display = 'block';
            } else {
                loginBtn.textContent = 'Nostr Connect';
                loginBtn.style.background = '#3498db';
                messageSection.style.display = 'none';
                profileSection.style.display = 'none';
            }
        }

        // Track if AUTH has been sent to avoid duplicates
        let authSent = false;
        
        async function connectToNostrRelay() {
            const NOSTRws = DEFAULT_RELAYS[0];
            
            if (!NOSTRws) {
                console.error("NOSTRws is not defined. Cannot connect to relay.");
                return;
            }

            // Check if we already have a connected relay
            if (nostrRelay && isNostrConnected) {
                console.log('‚úÖ Reusing existing relay connection');
                return;
            }

            console.log('Connecting to relay:', NOSTRws);
            authSent = false; // Reset on new connection

            try {
                // Close existing connection if any
                if (nostrRelay) {
                    try {
                        nostrRelay.close();
                    } catch (e) {
                        console.warn('Error closing existing relay:', e);
                    }
                }

                nostrRelay = NostrTools.relayInit(NOSTRws);

                nostrRelay.on('connect', async () => {
                    console.log('‚úÖ Connected to NOSTR relay:', NOSTRws);
                    isNostrConnected = true;
                    
                    // Send NIP-42 authentication event once
                    if (userPubkey && !authSent) {
                        authSent = true;
                        setTimeout(() => sendNIP42Auth(NOSTRws), 500);
                    }
                });

                nostrRelay.on('error', (error) => {
                    console.error('‚ùå Relay connection error:', error);
                    isNostrConnected = false;
                });

                nostrRelay.on('disconnect', () => {
                    console.log('üîå Relay disconnected');
                    isNostrConnected = false;
                });

                await nostrRelay.connect();
                console.log('‚úÖ Connected to NOSTR relay:', NOSTRws);
                isNostrConnected = true;

            } catch (error) {
                console.error('Failed to connect to relay:', error);
                isNostrConnected = false;
                throw error;
            }
        }
        
        // Send NIP-42 authentication event using nostr-tools publish method
        async function sendNIP42Auth(relayUrl) {
            if (!window.nostr || !userPubkey) {
                console.warn('Cannot send NIP-42 auth: missing nostr extension or pubkey');
                return;
            }
            
            if (!nostrRelay || !isNostrConnected) {
                console.warn('Cannot send NIP-42 auth: relay not connected');
                return;
            }
            
            try {
                console.log('üìù Sending NIP-42 authentication event...');
                
                // Create NIP-42 authentication event (kind 22242)
                const authEvent = {
                    kind: 22242,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['relay', relayUrl],
                        ['challenge', 'auth-' + Date.now()]
                    ],
                    content: '',
                    pubkey: userPubkey
                };
                
                // Sign the event with the user's extension
                const signedEvent = await window.nostr.signEvent(authEvent);
                
                if (!signedEvent || !signedEvent.id) {
                    console.error('‚ùå Failed to sign NIP-42 event');
                    return;
                }
                
                console.log('‚úÖ NIP-42 event signed:', signedEvent.id);
                
                // Publish the event to the relay so it gets stored
                console.log('üì§ Publishing NIP-42 event to relay...');
                const publishPromise = nostrRelay.publish(signedEvent);
                
                // Add timeout for publish
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('NIP-42 publish timeout')), 10000);
                });
                
                await Promise.race([publishPromise, timeoutPromise]);
                console.log('‚úÖ NIP-42 event published to relay:', signedEvent.id);
                
                // Verify the event was stored by querying it back
                setTimeout(async () => {
                    try {
                        await verifyNIP42Event(signedEvent.id);
                    } catch (verifyError) {
                        console.warn('‚ö†Ô∏è Could not verify NIP-42 event:', verifyError);
                    }
                }, 1000);
                
                // Also send AUTH message for immediate authentication
                try {
                    let ws = null;
                    if (nostrRelay._ws) {
                        ws = nostrRelay._ws;
                    } else if (nostrRelay.ws) {
                        ws = nostrRelay.ws;
                    } else if (nostrRelay.socket) {
                        ws = nostrRelay.socket;
                    }
                    
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        const authMessage = JSON.stringify(['AUTH', signedEvent]);
                        ws.send(authMessage);
                        console.log('‚úÖ NIP-42 AUTH message sent via relay WebSocket:', signedEvent.id);
                    }
                } catch (authError) {
                    console.warn('‚ö†Ô∏è Could not send AUTH message, but event was published:', authError);
                }
                
            } catch (error) {
                console.error('‚ùå Failed to send NIP-42 auth:', error);
            }
        }

        // Verify that NIP-42 event was stored on the relay
        async function verifyNIP42Event(eventId) {
            if (!nostrRelay || !isNostrConnected) {
                throw new Error('Relay not connected');
            }

            try {
                const events = await new Promise((resolve, reject) => {
                    const sub = nostrRelay.sub([{ kinds: [22242], ids: [eventId], limit: 1 }]);
                    const foundEvents = [];
                    
                    let timeout = setTimeout(() => {
                        sub.unsub();
                        resolve(foundEvents);
                    }, 5000);

                    sub.on('event', (event) => {
                        foundEvents.push(event);
                        clearTimeout(timeout);
                        sub.unsub();
                        resolve(foundEvents);
                    });

                    sub.on('eose', () => {
                        clearTimeout(timeout);
                        sub.unsub();
                        resolve(foundEvents);
                    });
                });

                if (events.length > 0) {
                    console.log('‚úÖ NIP-42 event verified on relay:', eventId);
                    return true;
                } else {
                    console.warn('‚ö†Ô∏è NIP-42 event not found on relay:', eventId);
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error verifying NIP-42 event:', error);
                throw error;
            }
        }

        // Profile and Messages Functions
        async function loadUserProfileAndMessages() {
            if (!userPubkey || !nostrRelay || !isNostrConnected) {
                console.error('Cannot load profile: missing userPubkey or relay connection');
                return;
            }

            try {
                // Load profile data
                const profileData = await fetchNostrProfile(userPubkey);
                displayProfileData(profileData);

                // Load recent messages with navigation
                await fetchAndDisplayMessages(userPubkey);

            } catch (error) {
                console.error('Error loading profile and messages:', error);
                document.getElementById('profile-info').innerHTML = '<div style="color: #e74c3c;">Erreur lors du chargement du profil</div>';
                document.getElementById('last-message-area').innerHTML = '<div style="color: #e74c3c;">Erreur lors du chargement des messages</div>';
            }
        }
        
        // Fetch and display messages with navigation
        async function fetchAndDisplayMessages(pubkey) {
            console.log(`Fetching messages for ${pubkey.substring(0, 10)}...`);
            const messageArea = document.getElementById('last-message-area');
            const repliesList = document.getElementById('replies-list');
            
            messageArea.innerHTML = '<div class="loading">Chargement des messages...</div>';
            repliesList.innerHTML = '<li class="loading">S√©lectionnez un message...</li>';
            
            document.getElementById('older-button').disabled = true;
            document.getElementById('newer-button').disabled = true;
            
            fetchedMessages = [];
            currentMessageIndex = 0;

            try {
                const relay = NostrTools.relayInit(DEFAULT_RELAYS[0]);
                await relay.connect();
                
                const events = await new Promise((resolve, reject) => {
                    const sub = relay.sub([{ kinds: [1], authors: [pubkey], limit: MESSAGES_PER_PAGE }]);
                    const messages = [];
                    
                    let timeout = setTimeout(() => {
                        sub.unsub();
                        relay.close();
                        resolve(messages.sort((a,b) => b.created_at - a.created_at));
                    }, 10000);

                    sub.on('event', (event) => {
                        messages.push(event);
                    });

                    sub.on('eose', () => {
                        clearTimeout(timeout);
                        sub.unsub();
                        relay.close();
                        resolve(messages.sort((a,b) => b.created_at - a.created_at));
                    });
                });

                if (events.length > 0) {
                    console.log(`Fetched ${events.length} messages`);
                    fetchedMessages = events;
                    displayMessageAtIndex(0);
                } else {
                    console.log('No messages found');
                    messageArea.innerHTML = '<div class="no-messages">Aucun message trouv√©</div>';
                    repliesList.innerHTML = '<li class="no-messages">N/A</li>';
                }
            } catch (error) {
                console.error('Error fetching messages:', error);
                messageArea.innerHTML = '<div style="color: #e74c3c;">Erreur lors du chargement des messages</div>';
                repliesList.innerHTML = '<li style="color: #e74c3c;">Erreur</li>';
            }
        }
        
        // Display message at specific index
        function displayMessageAtIndex(index) {
            console.log(`Displaying message at index: ${index}`);
            const messageArea = document.getElementById('last-message-area');
            const repliesList = document.getElementById('replies-list');

            if (index < 0 || index >= fetchedMessages.length) {
                console.log(`Index ${index} out of bounds`);
                messageArea.innerHTML = '<div class="no-messages">Index invalide</div>';
                repliesList.innerHTML = '<li class="no-messages">N/A</li>';
                document.getElementById('newer-button').disabled = true;
                document.getElementById('older-button').disabled = true;
                return;
            }

            currentMessageIndex = index;
            const currentMessage = fetchedMessages[currentMessageIndex];
            renderMessage(messageArea, currentMessage);
            fetchAndDisplayReplies(currentMessage.id);

            // Update navigation buttons
            document.getElementById('newer-button').disabled = (currentMessageIndex <= 0);
            document.getElementById('older-button').disabled = (currentMessageIndex >= fetchedMessages.length - 1);
        }
        
        // Render a single message
        function renderMessage(container, event) {
            container.innerHTML = '';
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message-item';
            
            // Check if this message is a reply to another message
            const replyToTag = event.tags.find(tag => tag[0] === 'e');
            if (replyToTag && replyToTag[1]) {
                const parentId = replyToTag[1];
                const replyToDiv = document.createElement('div');
                replyToDiv.className = 'reply-to-indicator';
                replyToDiv.innerHTML = `<strong>‚Ü©Ô∏è En r√©ponse √†:</strong> <code>${parentId.substring(0, 10)}...</code>`;
                replyToDiv.style.cssText = 'background: rgba(74, 222, 128, 0.1); border-left: 3px solid #4ade80; padding: 8px 12px; margin-bottom: 10px; border-radius: 4px; font-size: 0.9em; color: #94a3b8;';
                messageDiv.appendChild(replyToDiv);
                
                // Load and display parent message
                fetchAndDisplayParentMessage(parentId, messageDiv);
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Process content with better image detection
            const lines = event.content.split('\n');
            lines.forEach((line, i) => {
                const trimmed = line.trim();
                
                // Check if line contains an image URL (with or without emoji/text prefix)
                const imageUrlMatch = trimmed.match(/(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/i);
                if (imageUrlMatch) {
                    const img = document.createElement('img');
                    img.src = imageUrlMatch[1];
                    img.style.cssText = 'max-width: 100%; height: auto; border-radius: 6px; margin: 8px 0; display: block;';
                    contentDiv.appendChild(img);
                } 
                // Check if line is a URL (but not an image)
                else if (/^https?:\/\/[^\s]+$/i.test(trimmed)) {
                    const link = document.createElement('a');
                    link.href = trimmed;
                    link.target = '_blank';
                    link.textContent = trimmed;
                    link.style.cssText = 'color: #4ade80; text-decoration: none;';
                    contentDiv.appendChild(link);
                } 
                // Check if line contains a URL within text
                else if (/https?:\/\/[^\s]+/i.test(trimmed)) {
                    // Replace URLs in text with links, but skip if it's an image URL
                    const parts = trimmed.split(/(https?:\/\/[^\s]+)/gi);
                    parts.forEach(part => {
                        if (/^https?:\/\//i.test(part)) {
                            // Skip if it's an image URL (already handled above)
                            if (!/\.(jpg|jpeg|png|gif|webp)$/i.test(part)) {
                                const link = document.createElement('a');
                                link.href = part;
                                link.target = '_blank';
                                link.textContent = part;
                                link.style.cssText = 'color: #4ade80; text-decoration: none;';
                                contentDiv.appendChild(link);
                            }
                        } else if (part.trim()) {
                            contentDiv.appendChild(document.createTextNode(part));
                        }
                    });
                } 
                // Regular text
                else if (trimmed) {
                    contentDiv.appendChild(document.createTextNode(line));
                }
                
                if (i < lines.length - 1) contentDiv.appendChild(document.createElement('br'));
            });
            
            const metaDiv = document.createElement('div');
            metaDiv.className = 'message-meta';
            metaDiv.textContent = `Message ${currentMessageIndex + 1}/${fetchedMessages.length} | ID: ${event.id.substring(0, 10)}... | ${new Date(event.created_at * 1000).toLocaleString('fr-FR')}`;
            
            // Add delete button if this is the user's own message
            if (userPubkey && event.pubkey === userPubkey) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-button';
                deleteBtn.textContent = 'üóëÔ∏è Supprimer';
                deleteBtn.onclick = () => deleteMessage(event.id);
                
                actionsDiv.appendChild(deleteBtn);
                messageDiv.appendChild(actionsDiv);
            }
            
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(metaDiv);
            container.appendChild(messageDiv);
        }
        
        // Fetch and display parent message
        async function fetchAndDisplayParentMessage(parentId, messageDiv) {
            try {
                const relay = NostrTools.relayInit(DEFAULT_RELAYS[0]);
                await relay.connect();
                
                const parentEvent = await new Promise((resolve, reject) => {
                    const sub = relay.sub([{ kinds: [1], ids: [parentId], limit: 1 }]);
                    let found = false;
                    
                    let timeout = setTimeout(() => {
                        sub.unsub();
                        relay.close();
                        resolve(null);
                    }, 5000);

                    sub.on('event', (event) => {
                        found = true;
                        clearTimeout(timeout);
                        sub.unsub();
                        relay.close();
                        resolve(event);
                    });

                    sub.on('eose', () => {
                        if (!found) {
                            clearTimeout(timeout);
                            sub.unsub();
                            relay.close();
                            resolve(null);
                        }
                    });
                });

                if (parentEvent) {
                    const parentDiv = document.createElement('div');
                    parentDiv.className = 'parent-message';
                    parentDiv.style.cssText = 'background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.1); padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 0.95em;';
                    
                    const parentHeader = document.createElement('div');
                    parentHeader.style.cssText = 'font-size: 0.85em; color: #94a3b8; margin-bottom: 8px;';
                    parentHeader.innerHTML = `<strong>Message original de:</strong> <code>${parentEvent.pubkey.substring(0, 10)}...</code> le ${new Date(parentEvent.created_at * 1000).toLocaleString('fr-FR')}`;
                    
                    const parentContent = document.createElement('div');
                    parentContent.style.cssText = 'color: #cbd5e1; line-height: 1.5;';
                    
                    // Process parent content (simplified version)
                    const lines = parentEvent.content.split('\n');
                    lines.forEach((line, i) => {
                        const trimmed = line.trim();
                        const imageUrlMatch = trimmed.match(/(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/i);
                        
                        if (imageUrlMatch) {
                            const img = document.createElement('img');
                            img.src = imageUrlMatch[1];
                            img.style.cssText = 'max-width: 100%; height: auto; border-radius: 6px; margin: 8px 0; display: block;';
                            parentContent.appendChild(img);
                        } else if (trimmed) {
                            parentContent.appendChild(document.createTextNode(line));
                            if (i < lines.length - 1) parentContent.appendChild(document.createElement('br'));
                        }
                    });
                    
                    parentDiv.appendChild(parentHeader);
                    parentDiv.appendChild(parentContent);
                    
                    // Insert parent message after reply indicator
                    const replyIndicator = messageDiv.querySelector('.reply-to-indicator');
                    if (replyIndicator) {
                        replyIndicator.insertAdjacentElement('afterend', parentDiv);
                    }
                }
            } catch (error) {
                console.error('Error fetching parent message:', error);
            }
        }
        
        // Fetch and display replies
        async function fetchAndDisplayReplies(eventId) {
            console.log(`Fetching replies for event ${eventId.substring(0, 10)}...`);
            const list = document.getElementById('replies-list');
            list.innerHTML = '<li class="loading">Chargement des r√©ponses...</li>';
            
            if (!eventId) {
                list.innerHTML = '<li class="no-messages">Aucun ID parent</li>';
                return;
            }

            try {
                const relay = NostrTools.relayInit(DEFAULT_RELAYS[0]);
                await relay.connect();
                
                const replies = await new Promise((resolve, reject) => {
                    const sub = relay.sub([{ kinds: [1], '#e': [eventId], limit: 20 }]);
                    const replyEvents = [];
                    
                    let timeout = setTimeout(() => {
                        sub.unsub();
                        relay.close();
                        resolve(replyEvents.sort((a,b) => a.created_at - b.created_at));
                    }, 10000);

                    sub.on('event', (event) => {
                        replyEvents.push(event);
                    });

                    sub.on('eose', () => {
                        clearTimeout(timeout);
                        sub.unsub();
                        relay.close();
                        resolve(replyEvents.sort((a,b) => a.created_at - b.created_at));
                    });
                });

                if (replies.length > 0) {
                    console.log(`Found ${replies.length} replies`);
                    list.innerHTML = '';
                    replies.forEach(reply => renderReply(list, reply));
                } else {
                    console.log('No replies found');
                    list.innerHTML = '<li class="no-messages">Aucune r√©ponse pour le moment</li>';
                }
            } catch (error) {
                console.error('Error fetching replies:', error);
                list.innerHTML = '<li style="color: #e74c3c;">Erreur lors du chargement des r√©ponses</li>';
            }
        }
        
        // Render a single reply
        function renderReply(list, event) {
            const item = document.createElement('li');
            item.className = 'reply-item';
            
            const authorP = document.createElement('p');
            authorP.className = 'reply-author';
            authorP.innerHTML = `R√©ponse de: <code>${event.pubkey.substring(0, 10)}...</code> le ${new Date(event.created_at * 1000).toLocaleString('fr-FR')}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'reply-content';
            
            // Process content with better image detection (same as renderMessage)
            const lines = event.content.split('\n');
            lines.forEach((line, i) => {
                const trimmed = line.trim();
                
                // Check if line contains an image URL (with or without emoji/text prefix)
                const imageUrlMatch = trimmed.match(/(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/i);
                if (imageUrlMatch) {
                    const img = document.createElement('img');
                    img.src = imageUrlMatch[1];
                    img.style.cssText = 'max-width: 100%; height: auto; border-radius: 6px; margin: 8px 0; display: block;';
                    contentDiv.appendChild(img);
                } 
                // Check if line is a URL (but not an image)
                else if (/^https?:\/\/[^\s]+$/i.test(trimmed)) {
                    const link = document.createElement('a');
                    link.href = trimmed;
                    link.target = '_blank';
                    link.textContent = trimmed;
                    link.style.cssText = 'color: #4ade80; text-decoration: none;';
                    contentDiv.appendChild(link);
                } 
                // Check if line contains a URL within text
                else if (/https?:\/\/[^\s]+/i.test(trimmed)) {
                    // Replace URLs in text with links, but skip if it's an image URL
                    const parts = trimmed.split(/(https?:\/\/[^\s]+)/gi);
                    parts.forEach(part => {
                        if (/^https?:\/\//i.test(part)) {
                            // Skip if it's an image URL (already handled above)
                            if (!/\.(jpg|jpeg|png|gif|webp)$/i.test(part)) {
                                const link = document.createElement('a');
                                link.href = part;
                                link.target = '_blank';
                                link.textContent = part;
                                link.style.cssText = 'color: #4ade80; text-decoration: none;';
                                contentDiv.appendChild(link);
                            }
                        } else if (part.trim()) {
                            contentDiv.appendChild(document.createTextNode(part));
                        }
                    });
                } 
                // Regular text
                else if (trimmed) {
                    contentDiv.appendChild(document.createTextNode(line));
                }
                
                if (i < lines.length - 1) contentDiv.appendChild(document.createElement('br'));
            });
            
            // Add delete button if this is the user's own reply
            if (userPubkey && event.pubkey === userPubkey) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-button';
                deleteBtn.textContent = 'üóëÔ∏è Supprimer';
                deleteBtn.onclick = () => deleteMessage(event.id);
                
                actionsDiv.appendChild(deleteBtn);
                item.appendChild(actionsDiv);
            }
            
            item.appendChild(authorP);
            item.appendChild(contentDiv);
            list.appendChild(item);
        }

        async function fetchNostrProfile(hex) {
            try {
                const relay = NostrTools.relayInit(DEFAULT_RELAYS[0]);
                await relay.connect();
                
                const profileEvent = await new Promise((resolve, reject) => {
                    const sub = relay.sub([{ kinds: [0], authors: [hex], limit: 1 }]);
                    let timeout = setTimeout(() => {
                        sub.unsub();
                        relay.close();
                        reject(new Error('Profile fetch timeout'));
                    }, 5000);

                    sub.on('event', (event) => {
                        clearTimeout(timeout);
                        sub.unsub();
                        relay.close();
                        resolve(event);
                    });

                    sub.on('eose', () => {
                        clearTimeout(timeout);
                        sub.unsub();
                        relay.close();
                        resolve(null);
                    });
                });

                if (profileEvent && profileEvent.content) {
                    return JSON.parse(profileEvent.content);
                }
                return null;
            } catch (error) {
                console.error('Error fetching profile:', error);
                throw error;
            }
        }

        function displayProfileData(profileData) {
            const profileInfo = document.getElementById('profile-info');
            
            if (!profileData) {
                profileInfo.innerHTML = '<div style="color: #7f8c8d;">Aucun profil trouv√©</div>';
                return;
            }

            const name = profileData.name || profileData.display_name || 'Utilisateur';
            const about = profileData.about || '';
            const picture = profileData.picture || '';

            let profileHTML = '';
            
            if (picture) {
                profileHTML += `<img src="${picture}" alt="Profile Picture" class="profile-picture" onerror="this.style.display='none'">`;
            }
            
            profileHTML += `
                <div class="profile-details">
                    <h3>${name}</h3>
                    <p>${about || 'Aucune description disponible'}</p>
                </div>
            `;

            profileInfo.innerHTML = profileHTML;
        }

        function toggleProfileSection() {
            const profileContent = document.getElementById('profile-content');
            const profileToggle = document.querySelector('.profile-toggle');
            
            if (profileContent.classList.contains('expanded')) {
                profileContent.classList.remove('expanded');
                profileToggle.classList.remove('expanded');
            } else {
                profileContent.classList.add('expanded');
                profileToggle.classList.add('expanded');
            }
        }

        // Map variables
        let miniMap;
        let miniMarker;
        let nearbyMarkers = [];

        // Photo and Geolocation Functions
        function handlePhotoUpload(event) {
            const file = event.target.files[0];
            if (file) {
                selectedPhoto = file;
                const reader = new FileReader();
                reader.onload = function(e) {
                    const preview = document.getElementById('photoPreview');
                    const uploadText = document.getElementById('photoUploadText');
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    uploadText.style.display = 'none';
                };
                reader.readAsDataURL(file);
                
                // Get current location when photo is selected
                getCurrentLocation();
                
                // Upload photo to IPFS and analyze with PlantNet
                uploadPhotoToIPFS(file);
            }
        }

        // IPFS Upload and PlantNet Analysis
        async function uploadPhotoToIPFS(file) {
            const plantnetResult = document.getElementById('plantnetResult');
            const plantnetText = document.getElementById('plantnetText');
            
            plantnetResult.style.display = 'block';
            plantnetText.textContent = 'üì§ Upload en cours...';
            
            try {
                // Upload photo to IPFS via uSPOT API
                const formData = new FormData();
                formData.append('file', file);
                
                // Add npub if connected to NOSTR (following generate_ipfs_structure.sh pattern)
                console.log('DEBUG photo upload - isNostrConnected:', isNostrConnected, 'userPubkey:', userPubkey ? 'pr√©sente' : 'absente');
                
                if ((isNostrConnected && userPubkey) || userPubkey) {
                    // Use the key if available, even if isNostrConnected might be false
                    if (userPubkey.length === 64) {
                        console.log('Ajout de la cl√© publique √† l\'upload photo:', userPubkey);
                        formData.append('npub', userPubkey);
                    } else {
                        console.log('Cl√© publique invalide pour l\'upload:', userPubkey);
                    }
                } else {
                    console.log('Aucune cl√© publique disponible pour l\'upload');
                }
                
                const uploadUrl = `${getAPIBaseUrl()}/api/fileupload`;
                console.log(`Uploading to uSPOT API: ${uploadUrl}`);
                
                const uploadResponse = await fetch(uploadUrl, {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    let errorMessage = `Upload failed: ${uploadResponse.status}`;
                    
                    try {
                        const errorData = await uploadResponse.json();
                        console.error('Upload error details:', errorData);
                        
                        // Handle specific error codes
                        if (uploadResponse.status === 403) {
                            errorMessage = 'üîê Authentification NOSTR requise\n\n' +
                                         'Veuillez vous reconnecter avec votre extension NOSTR.\n' +
                                         'L\'√©v√©nement d\'authentification (NIP-42) doit √™tre r√©cent (< 24h).\n\n' +
                                         'D√©tails: ' + (errorData.detail || 'Auth failed');
                            plantnetResult.style.background = '#fff3cd';
                            
                            // Suggestion de reconnexion
                            console.log('üîÑ Suggestion: Rafra√Æchissez la page et reconnectez-vous avec NOSTR');
                        } else if (uploadResponse.status === 429) {
                            errorMessage = '‚è±Ô∏è Trop de requ√™tes - Attendez quelques instants';
                            plantnetResult.style.background = '#fff3cd';
                        } else {
                            errorMessage = `‚ùå Erreur ${uploadResponse.status} - ${errorData.detail || 'R√©essayez plus tard'}`;
                            plantnetResult.style.background = '#f8d7da';
                        }
                    } catch (e) {
                        // Si la r√©ponse n'est pas du JSON
                        const errorText = await uploadResponse.text();
                        console.error('Upload error (text):', errorText);
                        
                        if (uploadResponse.status === 403) {
                            errorMessage = 'üîê Authentification NOSTR requise - Reconnectez-vous avec votre extension NOSTR';
                            plantnetResult.style.background = '#fff3cd';
                        }
                    }
                    
                    throw new Error(errorMessage);
                }
                
                const uploadResult = await uploadResponse.json();
                console.log('Upload API response:', uploadResult);
                
                // Construire l'URL IPFS √† partir des donn√©es du script upload2ipfs.sh
                let imageUrl = null;
                
                if (uploadResult.success && uploadResult.new_cid && uploadResult.file_path) {
                    // Construction de l'URL IPFS compl√®te depuis le script upload2ipfs.sh
                    const gateway = window.location.origin.includes('127.0.0.1') 
                        ? 'http://127.0.0.1:8080' 
                        : window.location.origin.replace('ipfs.', 'ipfs.');
                    
                    // Extraire le nom de fichier du chemin complet
                    const fileName = uploadResult.file_path.split('/').pop();
                    imageUrl = `${gateway}/ipfs/${uploadResult.new_cid}/${fileName}`;
                    console.log('‚úÖ Image URL construite depuis upload2ipfs.sh:', imageUrl);
                } else if (uploadResult.nip94_event && uploadResult.nip94_event.tags) {
                    // Fallback: chercher l'URL dans les tags NIP-94
                    const urlTag = uploadResult.nip94_event.tags.find(tag => tag[0] === 'url');
                    if (urlTag && urlTag[1]) {
                        imageUrl = urlTag[1];
                        console.log('‚úÖ Image URL depuis NIP-94 tags:', imageUrl);
                    }
                } else if (uploadResult.url) {
                    // Fallback sur url si pr√©sente
                    imageUrl = uploadResult.url;
                    console.log('‚úÖ Image URL depuis response.url:', imageUrl);
                } else if (uploadResult.ipfs_url) {
                    // Fallback sur ipfs_url si pr√©sente
                    imageUrl = uploadResult.ipfs_url;
                    console.log('‚úÖ Image URL depuis response.ipfs_url:', imageUrl);
                }
                
                if (!imageUrl) {
                    console.error('Response compl√®te:', uploadResult);
                    throw new Error('‚ùå Impossible de construire l\'URL IPFS\n\n' +
                                  'CID: ' + (uploadResult.new_cid || 'manquant') + '\n' +
                                  'Path: ' + (uploadResult.file_path || 'manquant') + '\n' +
                                  'Status: ' + (uploadResult.status || 'inconnu'));
                }
                
                console.log('‚úÖ Photo uploaded to IPFS:', imageUrl);
                
                // Store the IPFS URL for later use in the message
                selectedPhoto.ipfsUrl = imageUrl;
                
                // Extract filename from file_path
                const aiGeneratedName = uploadResult.file_path ? uploadResult.file_path.split('/').pop() : null;
                
                // Update UI to show upload success with AI-generated filename
                plantnetResult.style.background = '#d4edda';
                if (aiGeneratedName && aiGeneratedName !== file.name) {
                    // Show AI-generated name if it's different from original
                    plantnetText.innerHTML = `‚úÖ Photo upload√©e vers IPFS<br>üìù Nom IA: <strong>${aiGeneratedName}</strong>`;
                } else {
                    plantnetText.textContent = '‚úÖ Photo upload√©e vers IPFS - Cliquez sur Partager...';
                }
                
                // Log successful upload details
                console.log('‚úÖ Photo upload successful - IPFS URL:', imageUrl);
                console.log('‚úÖ CID:', uploadResult.new_cid);
                console.log('‚úÖ File type:', uploadResult.file_type);
                console.log('‚úÖ AI-generated filename:', aiGeneratedName);
                
                // The actual PlantNet analysis will be handled by the Nostr relay
                // when the message is sent with #plantnet tag
                
            } catch (error) {
                console.error('IPFS upload error:', error);
                plantnetResult.style.background = '#f8d7da';
                plantnetText.innerHTML = error.message || '‚ùå Erreur d\'upload - R√©essayez plus tard';
            }
        }


        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        currentLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy
                        };
                        updateLocationDisplay();
                        // Update map display inputs
                        document.getElementById('lat-display').value = currentLocation.latitude.toFixed(2);
                        document.getElementById('lon-display').value = currentLocation.longitude.toFixed(2);
                    },
                    error => {
                        console.error('Error getting location:', error);
                        alert('Impossible d\'obtenir votre position. Vous pouvez toujours partager sans g√©olocalisation.');
                    }
                );
            } else {
                alert('La g√©olocalisation n\'est pas support√©e par votre navigateur.');
            }
        }

        function updateLocationDisplay() {
            if (currentLocation) {
                const locationText = document.getElementById('locationText');
                const locationInfo = document.getElementById('locationInfo');
                
                // Display with 2 decimal precision (0.01¬∞)
                const lat = currentLocation.latitude.toFixed(2);
                const lon = currentLocation.longitude.toFixed(2);
                
                // Add accuracy info if available (from GPS), otherwise show manual selection
                const accuracyText = currentLocation.accuracy 
                    ? ` (¬±${Math.round(currentLocation.accuracy)}m)` 
                    : ' (position manuelle)';
                
                locationText.textContent = `${lat}, ${lon}${accuracyText}`;
                locationInfo.style.display = 'block';
            }
        }

        // Message Sending Function
        async function sendGeolocatedMessage() {
            if (!userPubkey) {
                alert("Vous devez √™tre connect√© avec Nostr pour envoyer un message.");
                return;
            }

            if (!nostrRelay || !isNostrConnected) {
                alert("Connexion au relay Nostr requise. Veuillez r√©essayer.");
                return;
            }

            const messageText = document.getElementById('messageText').value.trim();
            const sendBtn = document.getElementById('sendMessageBtn');
            
            sendBtn.disabled = true;
            sendBtn.textContent = "Envoi en cours...";

            try {
                // Get location from map display or current location
                const adjustedLocation = currentLocation || {
                    latitude: parseFloat(document.getElementById('lat-display').value) || 0,
                    longitude: parseFloat(document.getElementById('lon-display').value) || 0
                };
                
                // Prepare message content with tags
                let content = messageText || "üå± Observation";
                if (adjustedLocation) {
                    // Display with 2 decimal precision (0.01¬∞)
                    content += `\nüìç Position: ${adjustedLocation.latitude.toFixed(2)}, ${adjustedLocation.longitude.toFixed(2)}`;
                }
                
                // Add IPFS image URL if available (following generate_ipfs_structure.sh pattern)
                if (selectedPhoto && selectedPhoto.ipfsUrl) {
                    content += `\nüì∏ Photo: ${selectedPhoto.ipfsUrl}`;
                    console.log('Adding IPFS image URL to message:', selectedPhoto.ipfsUrl);
                }
                
                content += "\n#BRO #plantnet";

                // Create the Nostr event
                const eventTemplate = {
                    kind: 1, // Text note
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ["t", "BRO"],
                        ["t", "plantnet"]
                    ],
                    content: content
                };

                // Add location tags if available
                if (adjustedLocation) {
                    eventTemplate.tags.push(["g", `${adjustedLocation.latitude},${adjustedLocation.longitude}`]);
                }

                // Sign the event
                let signedEvent;
                if (window.nostr && typeof window.nostr.signEvent === 'function') {
                    signedEvent = await window.nostr.signEvent(eventTemplate);
                } else {
                    throw new Error("No Nostr extension found for signing.");
                }

                // Publish the event
                console.log("Publishing event to relay:", signedEvent);
                const publishPromise = nostrRelay.publish(signedEvent);

                // Add timeout
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Publish timeout')), 10000);
                });

                await Promise.race([publishPromise, timeoutPromise]);

                console.log("Message publi√© avec succ√®s:", signedEvent);
                alert("üå± Message partag√© avec succ√®s !");
                
                // Log successful upload details (following generate_ipfs_structure.sh pattern)
                if (selectedPhoto && selectedPhoto.ipfsUrl) {
                    console.log('‚úÖ Photo upload successful - IPFS URL:', selectedPhoto.ipfsUrl);
                }
                
                // Reset form
                document.getElementById('messageText').value = '';
                document.getElementById('photoInput').value = '';
                document.getElementById('photoPreview').style.display = 'none';
                document.getElementById('photoUploadText').style.display = 'block';
                document.getElementById('locationInfo').style.display = 'none';
                document.getElementById('plantnetResult').style.display = 'none';
                selectedPhoto = null;
                currentLocation = null;

            } catch (error) {
                alert(`Erreur lors de l'envoi du message: ${error.message}`);
                console.error("Erreur d'envoi Nostr:", error);
            } finally {
                sendBtn.disabled = false;
                sendBtn.textContent = "üå± Partager avec #BRO #plant";
            }
        }

        // Moon calculation functions
        function calculateLunarCalendar() {
            // Get coordinates from map display or use defaults
            const latitude = parseFloat(document.getElementById('lat-display').value) || 48.8566;
            const longitude = parseFloat(document.getElementById('lon-display').value) || 2.3522;
            const currentYear = new Date().getFullYear();
            
            document.getElementById('current-year').textContent = currentYear;
            
            let calendarData = [];
            let currentDate = new Date(currentYear, 0, 1);
            const endDate = new Date(currentYear, 11, 31);
            
            let lastDeclination = null;
            let currentPeriod = '';
            
            while (currentDate <= endDate) {
                const declination = calculateMoonDeclination(currentDate);
                const period = determineLunarPeriod(declination, lastDeclination);
                
                if (period !== currentPeriod) {
                    calendarData.push({
                        startDate: new Date(currentDate),
                        period: period,
                        declination: declination
                    });
                    currentPeriod = period;
                }
                
                lastDeclination = declination;
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            displayCalendarTable(calendarData);
        }

        function calculateMoonDeclination(date) {
            // Simplified moon declination calculation
            // In a real implementation, you would use a more precise astronomical algorithm
            const daysSinceJ2000 = (date - new Date('2000-01-01T12:00:00Z')) / (1000 * 60 * 60 * 24);
            const moonOrbitInclination = 5.145; // degrees
            const lunarCycle = 27.321582; // days
            
            // Simplified calculation - real implementation would be more complex
            const moonLongitude = (360 * daysSinceJ2000 / lunarCycle) % 360;
            const declination = Math.asin(Math.sin(moonLongitude * Math.PI / 180) * Math.sin(moonOrbitInclination * Math.PI / 180)) * 180 / Math.PI;
            
            return declination;
        }

        function determineLunarPeriod(currentDeclination, lastDeclination) {
            if (lastDeclination === null) return 'montante';
            
            if (currentDeclination > lastDeclination) {
                return 'montante';
            } else {
                return 'descendante';
            }
        }

        function displayCalendarTable(calendarData) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Trouver la phase actuelle et la suivante
            let currentPeriod = null;
            let nextPeriod = null;
            let currentIndex = -1;
            
            for (let i = 0; i < calendarData.length; i++) {
                const period = calendarData[i];
                const endDate = i < calendarData.length - 1 ? 
                    new Date(calendarData[i + 1].startDate) : 
                    new Date(period.startDate.getFullYear(), 11, 31);
                
                if (today >= period.startDate && today < endDate) {
                    currentPeriod = period;
                    currentIndex = i;
                    break;
                }
            }
            
            // Si pas de phase actuelle trouv√©e, prendre la premi√®re
            if (!currentPeriod && calendarData.length > 0) {
                currentPeriod = calendarData[0];
                currentIndex = 0;
            }
            
            // Trouver la phase suivante
            if (currentIndex >= 0 && currentIndex < calendarData.length - 1) {
                nextPeriod = calendarData[currentIndex + 1];
            }
            
            let tableHTML = `
                <table class="calendar-table">
                    <thead>
                        <tr>
                            <th>P√©riode Lunaire</th>
                            <th>Date de D√©but</th>
                            <th>Conseils de Jardinage</th>
                            <th>Dur√©e</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Afficher la phase actuelle
            if (currentPeriod) {
                const endDate = currentIndex < calendarData.length - 1 ? 
                    new Date(calendarData[currentIndex + 1].startDate) : 
                    new Date(currentPeriod.startDate.getFullYear(), 11, 31);
                
                const duration = Math.round((endDate - currentPeriod.startDate) / (1000 * 60 * 60 * 24));
                const gardeningTips = currentPeriod.period === 'montante' ? 
                    'Semis, greffes, r√©colte fruits/l√©gumes-fruits' : 
                    'Plantation, taille, bouturage, travail sol';
                
                tableHTML += `
                    <tr class="${currentPeriod.period}-row current-period">
                        <td><strong>üåô Lune ${currentPeriod.period === 'montante' ? 'üå± Montante' : 'üçÇ Descendante'} (ACTUELLE)</strong></td>
                        <td>${formatDate(currentPeriod.startDate)}</td>
                        <td>${gardeningTips}</td>
                        <td>${duration} jours</td>
                    </tr>
                `;
            }
            
            // Afficher la phase suivante
            if (nextPeriod) {
                const nextEndDate = currentIndex + 1 < calendarData.length - 1 ? 
                    new Date(calendarData[currentIndex + 2].startDate) : 
                    new Date(nextPeriod.startDate.getFullYear(), 11, 31);
                
                const nextDuration = Math.round((nextEndDate - nextPeriod.startDate) / (1000 * 60 * 60 * 24));
                const nextGardeningTips = nextPeriod.period === 'montante' ? 
                    'Semis, greffes, r√©colte fruits/l√©gumes-fruits' : 
                    'Plantation, taille, bouturage, travail sol';
                
                tableHTML += `
                    <tr class="${nextPeriod.period}-row">
                        <td>üåô Lune ${nextPeriod.period === 'montante' ? 'üå± Montante' : 'üçÇ Descendante'} (SUIVANTE)</td>
                        <td>${formatDate(nextPeriod.startDate)}</td>
                        <td>${nextGardeningTips}</td>
                        <td>${nextDuration} jours</td>
                    </tr>
                `;
            }
            
            tableHTML += `</tbody></table>`;
            document.getElementById('calendar-table-container').innerHTML = tableHTML;
        }

        function generateICalFile() {
            const currentYear = new Date().getFullYear();
            let icalContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Jardin Lunaire//FR
CALSCALE:GREGORIAN
METHOD:PUBLISH
`;

            // Regenerate calendar data for iCal
            let calendarData = [];
            let currentDate = new Date(currentYear, 0, 1);
            const endDate = new Date(currentYear, 11, 31);
            let lastDeclination = null;
            let currentPeriod = '';
            
            while (currentDate <= endDate) {
                const declination = calculateMoonDeclination(currentDate);
                const period = determineLunarPeriod(declination, lastDeclination);
                
                if (period !== currentPeriod) {
                    calendarData.push({
                        startDate: new Date(currentDate),
                        period: period
                    });
                    currentPeriod = period;
                }
                
                lastDeclination = declination;
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Add events to iCal
            for (let i = 0; i < calendarData.length; i++) {
                const period = calendarData[i];
                const endDate = i < calendarData.length - 1 ? 
                    new Date(calendarData[i + 1].startDate) : 
                    new Date(period.startDate.getFullYear(), 11, 31);
                
                const summary = period.period === 'montante' ? 
                    'üå± Lune Montante - Semis et greffes' : 
                    'üçÇ Lune Descendante - Plantation et taille';
                
                const description = period.period === 'montante' ? 
                    'La s√®ve monte: favorable pour semis, greffes et r√©colte des fruits' : 
                    'La s√®ve descend: favorable pour plantation, taille et travail du sol';
                
                icalContent += `BEGIN:VEVENT
SUMMARY:${summary}
DESCRIPTION:${description}
DTSTART:${formatICalDate(period.startDate)}
DTEND:${formatICalDate(endDate)}
TRANSP:TRANSPARENT
END:VEVENT
`;
            }

            icalContent += 'END:VCALENDAR';

            // Download the file
            const blob = new Blob([icalContent], { type: 'text/calendar' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `calendrier-lunaire-${currentYear}.ics`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        // Utility functions
        function formatDate(date) {
            return date.toLocaleDateString('fr-FR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
            });
        }

        function formatICalDate(date) {
            return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
        }

        // Map functions
        function initializeMiniMap(lat = 0, lon = 0) {
            console.log('Initializing map with coordinates:', lat, lon);
            
            if (miniMap) {
                miniMap.remove();
            }
            
            // Check if Leaflet is loaded
            if (typeof L === 'undefined') {
                console.error('Leaflet library not loaded');
                return;
            }
            
            // Ensure the map container exists and is visible
            const mapContainer = document.getElementById('mini-map');
            if (!mapContainer) {
                console.error('Map container not found');
                return;
            }
            
            console.log('Map container found:', mapContainer);
            
            try {
                console.log('Creating Leaflet map...');
                miniMap = L.map('mini-map').setView([lat, lon], 10);
                console.log('Map created:', miniMap);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(miniMap);

                miniMarker = L.marker([lat, lon], {
                    draggable: true
                }).addTo(miniMap);

                miniMap.on('click', function(e) {
                    // Pass raw coordinates, rounding will be done in updateCoordinatesFromMap
                    updateCoordinatesFromMap(e.latlng.lat, e.latlng.lng);
                });

                miniMarker.on('dragend', function(e) {
                    // Pass raw coordinates, rounding will be done in updateCoordinatesFromMap
                    updateCoordinatesFromMap(e.target.getLatLng().lat, e.target.getLatLng().lng);
                });
                
                // Invalidate size after a short delay to ensure proper rendering
                setTimeout(() => {
                    if (miniMap) {
                        miniMap.invalidateSize();
                        console.log('Map size invalidated');
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error initializing map:', error);
            }
        }

        function updateCoordinatesFromMap(lat, lon) {
            // Round to 0.01¬∞ precision (2 decimal places)
            const roundedLat = Math.round(lat * 100) / 100;
            const roundedLon = Math.round(lon * 100) / 100;

            console.log(`Updating coordinates: ${roundedLat.toFixed(2)}, ${roundedLon.toFixed(2)}`);

            // Update input fields
            document.getElementById('lat-display').value = roundedLat.toFixed(2);
            document.getElementById('lon-display').value = roundedLon.toFixed(2);

            // Update marker position on map
            if (miniMarker) {
                miniMarker.setLatLng([roundedLat, roundedLon]);
            }

            // Update current location (used for message sending)
            currentLocation = { latitude: roundedLat, longitude: roundedLon };
            
            // Update location display if visible
            updateLocationDisplay();
        }

        function toggleMapAccordion() {
            const accordionContent = document.querySelector('.map-accordion-content');
            const mapToggle = document.querySelector('.map-toggle');
            const isClosed = accordionContent.classList.contains('closed');
            
            if (isClosed) {
                accordionContent.classList.remove('closed');
                mapToggle.classList.add('expanded');
                // Reinitialize map when accordion opens
                setTimeout(() => {
                    const lat = currentLocation ? currentLocation.latitude : (parseFloat(document.getElementById('lat-display').value) || 48.86);
                    const lon = currentLocation ? currentLocation.longitude : (parseFloat(document.getElementById('lon-display').value) || 2.35);
                    console.log('Reinitializing map when accordion opens:', lat, lon);
                    initializeMiniMap(lat, lon);
                }, 100);
            } else {
                accordionContent.classList.add('closed');
                mapToggle.classList.remove('expanded');
            }
        }

        function getCurrentLocationForMap() {
            if (navigator.geolocation) {
                const btn = document.getElementById('get-location');
                btn.textContent = 'Localisation...';
                btn.disabled = true;
                
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        const lat = Math.round(position.coords.latitude * 100) / 100;
                        const lon = Math.round(position.coords.longitude * 100) / 100;

                        updateCoordinatesFromMap(lat, lon);
                        if (miniMap) {
                            miniMap.setView([lat, lon], 13);
                        }
                        
                        btn.textContent = 'Ma position';
                        btn.disabled = false;
                    },
                    function(error) {
                        let errorMessage;
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage = "G√©olocalisation refus√©e.";
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage = "Position indisponible.";
                                break;
                            case error.TIMEOUT:
                                errorMessage = "D√©lai d√©pass√©.";
                                break;
                            default:
                                errorMessage = "Erreur g√©olocalisation.";
                        }
                        console.error(`Geolocation error: ${errorMessage}`);
                        btn.textContent = 'Ma position';
                        btn.disabled = false;
                    }
                );
            } else {
                console.error("Geolocation not supported by browser");
            }
        }

        // Nearby Messages Functions
        async function loadNearbyMessages() {
            const btn = document.getElementById('load-nearby');
            const lat = parseFloat(document.getElementById('lat-display').value) || 48.86;
            const lon = parseFloat(document.getElementById('lon-display').value) || 2.35;
            
            btn.textContent = '‚è≥ Chargement...';
            btn.disabled = true;
            
            console.log(`Loading nearby messages for coordinates: ${lat}, ${lon}`);
            
            try {
                // Clear existing nearby markers
                clearNearbyMarkers();
                
                // Fetch geolinks from API
                const apiUrl = `${getAPIBaseUrl()}/api/umap/geolinks?lat=${lat}&lon=${lon}`;
                console.log('Fetching geolinks from:', apiUrl);
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const geolinkData = await response.json();
                console.log('Geolinks received:', geolinkData);
                
                if (!geolinkData.success) {
                    throw new Error(geolinkData.message || 'Failed to fetch geolinks');
                }
                
                // Extract all hex keys from umaps, sectors, and regions
                const allHexKeys = new Set();
                
                // Add UMAPs
                if (geolinkData.umaps) {
                    Object.values(geolinkData.umaps).forEach(key => allHexKeys.add(key));
                    console.log(`Found ${Object.keys(geolinkData.umaps).length} UMAP hex keys`);
                }
                
                // Add SECTORs
                if (geolinkData.sectors) {
                    Object.values(geolinkData.sectors).forEach(key => allHexKeys.add(key));
                    console.log(`Found ${Object.keys(geolinkData.sectors).length} SECTOR hex keys`);
                }
                
                // Add REGIONs
                if (geolinkData.regions) {
                    Object.values(geolinkData.regions).forEach(key => allHexKeys.add(key));
                    console.log(`Found ${Object.keys(geolinkData.regions).length} REGION hex keys`);
                }
                
                console.log(`Total unique hex keys to query: ${allHexKeys.size}`);
                
                // Fetch messages directly from GeoClefs (UMAPs, SECTORS, REGIONS)
                const allMessages = [];
                
                // Get messages directly from each GeoClef
                for (const hexKey of allHexKeys) {
                    try {
                        const messages = await fetchMessagesFromHex(hexKey);
                        console.log(`Fetched ${messages.length} messages from GeoClef ${hexKey.substring(0, 10)}...`);
                        allMessages.push(...messages);
                    } catch (error) {
                        console.error(`Error fetching messages from GeoClef ${hexKey}:`, error);
                    }
                }
                
                console.log(`Total messages fetched: ${allMessages.length}`);
                
                // Debug: Log sample messages to understand structure
                if (allMessages.length > 0) {
                    console.log('Sample message structure:', allMessages[0]);
                    console.log('Sample message tags:', allMessages[0].tags);
                }
                
                // Show ALL messages from GeoClefs - no filtering
                const relevantMessages = allMessages;
                
                console.log(`Total messages to display: ${relevantMessages.length}`);
                
                // Display messages on map (using UMAP coordinates as proxy for message location)
                displayNearbyMessagesOnMap(relevantMessages, geolinkData);
                
                btn.textContent = `üåç Messages environs (${relevantMessages.length} trouv√©s)`;
                btn.disabled = false;
                
            } catch (error) {
                console.error('Error loading nearby messages:', error);
                alert(`Erreur: ${error.message}`);
                btn.textContent = 'üåç Messages environs';
                btn.disabled = false;
            }
        }
        

        async function fetchMessagesFromHex(hexKey) {
            return new Promise(async (resolve, reject) => {
                try {
                    const relay = NostrTools.relayInit(DEFAULT_RELAYS[0]);
                    await relay.connect();
                    
                    // Query the 5 most recent messages from this author without tag filtering
                    const sub = relay.sub([{ 
                        kinds: [1], 
                        authors: [hexKey],
                        limit: 5 
                    }]);
                    
                    const messages = [];
                    let timeout = setTimeout(() => {
                        sub.unsub();
                        relay.close();
                        resolve(messages);
                    }, 5000);
                    
                    sub.on('event', (event) => {
                        messages.push(event);
                    });
                    
                    sub.on('eose', () => {
                        clearTimeout(timeout);
                        sub.unsub();
                        relay.close();
                        resolve(messages);
                    });
                    
                } catch (error) {
                    console.error(`Failed to fetch from ${hexKey}:`, error);
                    resolve([]);
                }
            });
        }
        
        function displayNearbyMessagesOnMap(messages, geolinkData) {
            if (!miniMap) {
                console.error('Map not initialized');
                return;
            }
            
            console.log(`displayNearbyMessagesOnMap called with ${messages.length} messages`);
            console.log('GeolinkData:', geolinkData);
            
            clearNearbyMarkers();
            
            // Create a map of GeoClef hex to coordinates
            const geoclefToCoords = new Map();
            
            console.log('Building coordinate mapping...');
            console.log('UMAPs:', geolinkData.umaps);
            console.log('SECTORS:', geolinkData.sectors);
            console.log('REGIONS:', geolinkData.regions);
            
            // Debug: show the structure of the data
            if (geolinkData.umaps) {
                console.log('UMAP entries:', Object.entries(geolinkData.umaps));
            }
            if (geolinkData.sectors) {
                console.log('SECTOR entries:', Object.entries(geolinkData.sectors));
            }
            if (geolinkData.regions) {
                console.log('REGION entries:', Object.entries(geolinkData.regions));
            }
            
            // Map UMAPs to their coordinates
            if (geolinkData.umaps) {
                Object.entries(geolinkData.umaps).forEach(([direction, hexKey]) => {
                    console.log(`Processing UMAP direction: "${direction}" for hex ${hexKey.substring(0, 10)}...`);
                    
                    // Calculate coordinates based on direction from center point
                    const centerLat = geolinkData.umap_coordinates.lat;
                    const centerLon = geolinkData.umap_coordinates.lon;
                    let lat = centerLat;
                    let lon = centerLon;
                    
                    // Adjust coordinates based on direction
                    switch(direction) {
                        case 'north':
                            lat = centerLat + 0.01;
                            break;
                        case 'south':
                            lat = centerLat - 0.01;
                            break;
                        case 'east':
                            lon = centerLon + 0.01;
                            break;
                        case 'west':
                            lon = centerLon - 0.01;
                            break;
                        case 'northeast':
                            lat = centerLat + 0.01;
                            lon = centerLon + 0.01;
                            break;
                        case 'northwest':
                            lat = centerLat + 0.01;
                            lon = centerLon - 0.01;
                            break;
                        case 'southeast':
                            lat = centerLat - 0.01;
                            lon = centerLon + 0.01;
                            break;
                        case 'southwest':
                            lat = centerLat - 0.01;
                            lon = centerLon - 0.01;
                            break;
                        case 'here':
                            // Use center coordinates
                            break;
                    }
                    
                    console.log(`Calculated coordinates: ${lat}, ${lon}`);
                    geoclefToCoords.set(hexKey, { lat, lon });
                    console.log(`Mapped UMAP ${hexKey.substring(0, 10)}... to ${lat}, ${lon}`);
                });
            }
            
            // Map SECTORS to their coordinates (same logic as UMAPs)
            if (geolinkData.sectors) {
                Object.entries(geolinkData.sectors).forEach(([direction, hexKey]) => {
                    console.log(`Processing SECTOR direction: "${direction}" for hex ${hexKey.substring(0, 10)}...`);
                    
                    // Calculate coordinates based on direction from center point
                    const centerLat = geolinkData.umap_coordinates.lat;
                    const centerLon = geolinkData.umap_coordinates.lon;
                    let lat = centerLat;
                    let lon = centerLon;
                    
                    // Adjust coordinates based on direction (same as UMAPs)
                    switch(direction) {
                        case 'north':
                            lat = centerLat + 0.01;
                            break;
                        case 'south':
                            lat = centerLat - 0.01;
                            break;
                        case 'east':
                            lon = centerLon + 0.01;
                            break;
                        case 'west':
                            lon = centerLon - 0.01;
                            break;
                        case 'northeast':
                            lat = centerLat + 0.01;
                            lon = centerLon + 0.01;
                            break;
                        case 'northwest':
                            lat = centerLat + 0.01;
                            lon = centerLon - 0.01;
                            break;
                        case 'southeast':
                            lat = centerLat - 0.01;
                            lon = centerLon + 0.01;
                            break;
                        case 'southwest':
                            lat = centerLat - 0.01;
                            lon = centerLon - 0.01;
                            break;
                        case 'here':
                            // Use center coordinates
                            break;
                    }
                    
                    console.log(`Calculated SECTOR coordinates: ${lat}, ${lon}`);
                    geoclefToCoords.set(hexKey, { lat, lon });
                    console.log(`Mapped SECTOR ${hexKey.substring(0, 10)}... to ${lat}, ${lon}`);
                });
            }
            
            // Map REGIONS to their coordinates (same logic as UMAPs)
            if (geolinkData.regions) {
                Object.entries(geolinkData.regions).forEach(([direction, hexKey]) => {
                    console.log(`Processing REGION direction: "${direction}" for hex ${hexKey.substring(0, 10)}...`);
                    
                    // Calculate coordinates based on direction from center point
                    const centerLat = geolinkData.umap_coordinates.lat;
                    const centerLon = geolinkData.umap_coordinates.lon;
                    let lat = centerLat;
                    let lon = centerLon;
                    
                    // Adjust coordinates based on direction (same as UMAPs)
                    switch(direction) {
                        case 'north':
                            lat = centerLat + 0.01;
                            break;
                        case 'south':
                            lat = centerLat - 0.01;
                            break;
                        case 'east':
                            lon = centerLon + 0.01;
                            break;
                        case 'west':
                            lon = centerLon - 0.01;
                            break;
                        case 'northeast':
                            lat = centerLat + 0.01;
                            lon = centerLon + 0.01;
                            break;
                        case 'northwest':
                            lat = centerLat + 0.01;
                            lon = centerLon - 0.01;
                            break;
                        case 'southeast':
                            lat = centerLat - 0.01;
                            lon = centerLon + 0.01;
                            break;
                        case 'southwest':
                            lat = centerLat - 0.01;
                            lon = centerLon - 0.01;
                            break;
                        case 'here':
                            // Use center coordinates
                            break;
                    }
                    
                    console.log(`Calculated REGION coordinates: ${lat}, ${lon}`);
                    geoclefToCoords.set(hexKey, { lat, lon });
                    console.log(`Mapped REGION ${hexKey.substring(0, 10)}... to ${lat}, ${lon}`);
                });
            }
            
            console.log('Total mapped coordinates:', geoclefToCoords.size);
            console.log('Available hex keys:', Array.from(geoclefToCoords.keys()).map(k => k.substring(0, 10)));
            
            console.log(`Processing ${messages.length} messages for map display`);
            console.log('Available GeoClef coordinates:', geoclefToCoords.size);
            
            messages.forEach((message, index) => {
                try {
                    console.log(`Processing message ${index + 1}/${messages.length}: ${message.id.substring(0, 10)}... from ${message.pubkey.substring(0, 10)}...`);
                    console.log(`Full pubkey: ${message.pubkey}`);
                    
                    // Get coordinates for this GeoClef
                    const coords = geoclefToCoords.get(message.pubkey);
                    console.log(`Looking for coordinates for ${message.pubkey.substring(0, 10)}...`);
                    console.log(`Coords found:`, coords);
                    
                    if (!coords) {
                        console.log(`No coordinates found for GeoClef ${message.pubkey.substring(0, 10)}...`);
                        console.log('Available GeoClefs:', Array.from(geoclefToCoords.keys()).map(k => k.substring(0, 10)));
                        console.log('Full available hex keys:', Array.from(geoclefToCoords.keys()));
                        return;
                    }
                    
                    let msgLat = coords.lat;
                    let msgLon = coords.lon;
                    
                    console.log(`Found coordinates for message: ${msgLat}, ${msgLon}`);
                    
                    // Add offset based on GeoClef type to spread messages appropriately
                    let offset = 0.005; // Default ~500m for UMAPs
                    
                    // Determine offset based on GeoClef type
                    if (geolinkData.umaps && Object.values(geolinkData.umaps).includes(message.pubkey)) {
                        offset = 0.005; // ~500m for UMAPs (local level)
                    } else if (geolinkData.sectors && Object.values(geolinkData.sectors).includes(message.pubkey)) {
                        offset = 0.1; // ~10km for SECTORS (sector level)
                    } else if (geolinkData.regions && Object.values(geolinkData.regions).includes(message.pubkey)) {
                        offset = 1.0; // ~100km for REGIONS (regional level)
                    }
                    
                    msgLat += (Math.random() - 0.5) * offset;
                    msgLon += (Math.random() - 0.5) * offset;
                    
                    console.log(`Final coordinates: ${msgLat.toFixed(4)}, ${msgLon.toFixed(4)} (offset: ${offset}¬∞)`);
                    
                    // Determine marker color based on GeoClef type
                    let markerColor = '#f59e0b'; // Default orange
                    let markerClass = 'nearby-message-marker';
                    
                    // Check if this is a UMAP, SECTOR, or REGION
                    if (geolinkData.umaps && Object.values(geolinkData.umaps).includes(message.pubkey)) {
                        markerColor = '#4ade80'; // Green for UMAPs
                        markerClass = 'nearby-message-marker umap-marker';
                    } else if (geolinkData.sectors && Object.values(geolinkData.sectors).includes(message.pubkey)) {
                        markerColor = '#3b82f6'; // Blue for SECTORS
                        markerClass = 'nearby-message-marker sector-marker';
                    } else if (geolinkData.regions && Object.values(geolinkData.regions).includes(message.pubkey)) {
                        markerColor = '#ef4444'; // Red for REGIONS
                        markerClass = 'nearby-message-marker region-marker';
                    }
                    
                    // Create custom marker icon with appropriate color
                    const markerIcon = L.divIcon({
                        className: markerClass,
                        iconSize: [12, 12],
                        html: `<div style="background-color: ${markerColor}; border: 2px solid white; border-radius: 50%; width: 12px; height: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`
                    });
                    
                    // Create marker
                    const marker = L.marker([msgLat, msgLon], { icon: markerIcon }).addTo(miniMap);
                    
                    // Create popup content
                    const popupContent = createPopupContent(message, geolinkData);
                    marker.bindPopup(popupContent);
                    
                    nearbyMarkers.push(marker);
                    
                } catch (error) {
                    console.error('Error displaying message on map:', error);
                }
            });
            
            console.log(`Added ${nearbyMarkers.length} markers to map`);
        }
        
        function createPopupContent(message, geolinkData) {
            const div = document.createElement('div');
            div.className = 'nearby-popup-content';
            
            // Determine GeoClef type
            let geoclefType = 'Unknown';
            let typeIcon = 'üìç';
            if (geolinkData.umaps && Object.values(geolinkData.umaps).includes(message.pubkey)) {
                geoclefType = 'UMAP';
                typeIcon = 'üü¢';
            } else if (geolinkData.sectors && Object.values(geolinkData.sectors).includes(message.pubkey)) {
                geoclefType = 'SECTOR';
                typeIcon = 'üîµ';
            } else if (geolinkData.regions && Object.values(geolinkData.regions).includes(message.pubkey)) {
                geoclefType = 'REGION';
                typeIcon = 'üî¥';
            }
            
            // GeoClef type indicator
            const typeDiv = document.createElement('div');
            typeDiv.className = 'geoclef-type';
            typeDiv.style.cssText = 'font-size: 0.8em; color: #666; margin-bottom: 5px; font-weight: bold;';
            typeDiv.textContent = `${typeIcon} ${geoclefType}`;
            div.appendChild(typeDiv);
            
            // Author link
            const authorDiv = document.createElement('div');
            authorDiv.className = 'nearby-popup-author';
            authorDiv.textContent = `üë§ ${message.pubkey.substring(0, 8)}...`;
            authorDiv.onclick = () => {
                window.open(`/ipns/copylaradio.com/nostr_profile_viewer.html?hex=${message.pubkey}`, '_blank');
            };
            div.appendChild(authorDiv);
            
            // Extract and display content
            const lines = message.content.split('\n');
            let textContent = '';
            let imageUrl = null;
            
            lines.forEach(line => {
                const trimmed = line.trim();
                
                // Check for image URL
                const imageUrlMatch = trimmed.match(/(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/i);
                if (imageUrlMatch && !imageUrl) {
                    imageUrl = imageUrlMatch[1];
                } else if (!trimmed.startsWith('http') && !trimmed.startsWith('#') && !trimmed.startsWith('üìç')) {
                    textContent += line + '\n';
                }
            });
            
            // Display text (limit length)
            if (textContent.trim()) {
                const textDiv = document.createElement('div');
                textDiv.className = 'nearby-popup-text';
                textDiv.textContent = textContent.trim().substring(0, 150) + (textContent.length > 150 ? '...' : '');
                div.appendChild(textDiv);
            }
            
            // Display image
            if (imageUrl) {
                const img = document.createElement('img');
                img.className = 'nearby-popup-image';
                img.src = imageUrl;
                img.onerror = () => { img.style.display = 'none'; };
                div.appendChild(img);
            }
            
            // Metadata
            const metaDiv = document.createElement('div');
            metaDiv.className = 'nearby-popup-meta';
            metaDiv.textContent = new Date(message.created_at * 1000).toLocaleString('fr-FR');
            div.appendChild(metaDiv);
            
            return div;
        }
        
        function clearNearbyMarkers() {
            nearbyMarkers.forEach(marker => {
                if (miniMap) {
                    miniMap.removeLayer(marker);
                }
            });
            nearbyMarkers = [];
        }

        // Delete Message Function
        async function deleteMessage(eventId) {
            if (!userPubkey) {
                alert("Vous devez √™tre connect√© pour supprimer un message.");
                return;
            }

            if (!nostrRelay || !isNostrConnected) {
                alert("Connexion au relay Nostr requise pour supprimer un message.");
                return;
            }

            // Confirmation dialog
            if (!confirm("√ätes-vous s√ªr de vouloir supprimer ce message ? Cette action est irr√©versible.")) {
                return;
            }

            try {
                console.log(`Deleting message: ${eventId}`);
                
                // Create deletion event (kind 5)
                const deletionEvent = {
                    kind: 5, // Deletion event
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ["e", eventId] // Reference to the event being deleted
                    ],
                    content: "Message supprim√© par l'utilisateur"
                };

                // Sign the deletion event
                let signedDeletionEvent;
                if (window.nostr && typeof window.nostr.signEvent === 'function') {
                    signedDeletionEvent = await window.nostr.signEvent(deletionEvent);
                } else {
                    throw new Error("Extension Nostr requise pour signer l'√©v√©nement de suppression.");
                }

                // Publish the deletion event
                console.log("Publishing deletion event:", signedDeletionEvent);
                const publishPromise = nostrRelay.publish(signedDeletionEvent);

                // Add timeout
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout de publication')), 10000);
                });

                await Promise.race([publishPromise, timeoutPromise]);

                console.log("Message deletion event published successfully");
                alert("üóëÔ∏è Message marqu√© pour suppression !");
                
                // Refresh the messages to show the deletion
                if (userPubkey) {
                    await fetchAndDisplayMessages(userPubkey);
                }

            } catch (error) {
                alert(`Erreur lors de la suppression du message: ${error.message}`);
                console.error("Erreur de suppression:", error);
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('current-year').textContent = new Date().getFullYear();
            calculateLunarCalendar();
            
            // D√©tecter l'environnement et configurer les relais
            detectUSPOTAPI();
            
            // Initialize map accordion icon as expanded (since it's open by default)
            const mapToggle = document.querySelector('.map-toggle');
            if (mapToggle) {
                mapToggle.classList.add('expanded');
            }
            
            // Initialize map after DOM is fully loaded
            setTimeout(() => {
                console.log('Initializing map on page load...');
                const defaultLat = parseFloat(document.getElementById('lat-display').value) || 48.86;
                const defaultLon = parseFloat(document.getElementById('lon-display').value) || 2.35;
                initializeMiniMap(defaultLat, defaultLon);
            }, 500);
            
            // Map accordion is now handled by the header click
            
            // Setup map controls
            document.getElementById('update-map').addEventListener('click', function() {
                const lat = parseFloat(document.getElementById('lat-display').value) || 0;
                const lon = parseFloat(document.getElementById('lon-display').value) || 0;
                
                updateCoordinatesFromMap(lat, lon);
                if (miniMap) {
                    miniMap.setView([lat, lon], miniMap.getZoom());
                }
            });
            
            document.getElementById('get-location').addEventListener('click', getCurrentLocationForMap);
            
            // Load nearby messages button
            document.getElementById('load-nearby').addEventListener('click', loadNearbyMessages);
            
            // Sync display inputs with tumbler changes
            document.getElementById('lat-display').addEventListener('change', function() {
                const lat = parseFloat(this.value) || 0;
                const lon = parseFloat(document.getElementById('lon-display').value) || 0;
                
                if (miniMarker) {
                    miniMarker.setLatLng([lat, lon]);
                }
                if (miniMap) {
                    miniMap.setView([lat, lon], miniMap.getZoom());
                }
            });
            
            document.getElementById('lon-display').addEventListener('change', function() {
                const lat = parseFloat(document.getElementById('lat-display').value) || 0;
                const lon = parseFloat(this.value) || 0;
                
                if (miniMarker) {
                    miniMarker.setLatLng([lat, lon]);
                }
                if (miniMap) {
                    miniMap.setView([lat, lon], miniMap.getZoom());
                }
            });
            
            // Message navigation button listeners
            document.getElementById('refresh-button').addEventListener('click', () => {
                if (userPubkey) {
                    console.log('Refresh button clicked');
                    fetchAndDisplayMessages(userPubkey);
                } else {
                    console.log('Refresh clicked but no public key');
                }
            });

            document.getElementById('older-button').addEventListener('click', () => {
                console.log('Older button clicked');
                if (currentMessageIndex < fetchedMessages.length - 1) {
                    displayMessageAtIndex(currentMessageIndex + 1);
                } else {
                    console.log('Already at the oldest fetched message');
                }
            });

            document.getElementById('newer-button').addEventListener('click', () => {
                console.log('Newer button clicked');
                if (currentMessageIndex > 0) {
                    displayMessageAtIndex(currentMessageIndex - 1);
                } else {
                    console.log('Already at the newest fetched message');
                }
            });
            
            // Check Nostr extension availability with delay
            setTimeout(() => {
                const nostrLoginBtn = document.getElementById('nostrLoginBtn');
                if (typeof window.nostr === 'undefined' || typeof window.nostr.getPublicKey !== 'function') {
                    nostrLoginBtn.textContent = "Extension Nostr requise";
                    nostrLoginBtn.disabled = true;
                    nostrLoginBtn.style.background = '#95a5a6';
                    nostrLoginBtn.style.cursor = 'not-allowed';
                } else {
                    nostrLoginBtn.textContent = "Nostr Connect";
                    nostrLoginBtn.disabled = false;
                    nostrLoginBtn.style.background = '#3498db';
                    nostrLoginBtn.style.cursor = 'pointer';
                }
            }, 1000); // Delay to allow extensions to load
        });
    </script>
</body>
</html>