<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <title id="dynamic-title">UPlanet Enhanced - Welcome to U World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="leaflet.css" />
    <style>
        :root {
            --primary-color: #0074d9;
            --secondary-color: #2ecc71;
            --accent-color: #f39c12;
            --background-color: #ffffff;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --shadow-color: rgba(0,0,0,0.15);
            --surface-color: #f8fafd;
        }

        [data-theme="dark"] {
            --background-color: #1a1a2e;
            --text-color: #ecf0f1;
            --border-color: #34495e;
            --shadow-color: rgba(255,255,255,0.1);
            --surface-color: #16213e;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            background: var(--background-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        #map {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        /* ⚡ OPTIMIZED: Consolidated grid and clickable styles */
        .clickable-area {
            fill-opacity: 0.1;
            fill: var(--primary-color);
            stroke: var(--primary-color);
            stroke-width: 1;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .clickable-area:hover {
            fill-opacity: 0.3;
            stroke-width: 2;
        }

        .grid-number {
            background: rgba(0, 116, 217, 0.9);
            color: white;
            border-radius: 15px;
            padding: 6px 10px;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: pointer;
            backdrop-filter: blur(10px);
            user-select: none;
        }

        .grid-number:hover {
            background: rgba(0, 116, 217, 1);
            transform: scale(1.1);
        }

        /* Enhanced control buttons */
        .control-button {
            position: absolute;
            z-index: 1002;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 116, 217, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-button:hover {
            background: #0056b3;
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 116, 217, 0.4);
        }

        #back-button {
            top: 20px;
            left: 20px;
        }

        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            font-size: 20px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .theme-toggle {
            background: rgba(44, 62, 80, 0.9);
            color: white;
        }

        /* Enhanced rolling text container */
        .rolling-text-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, var(--surface-color), var(--background-color));
            color: var(--text-color);
            padding: 16px 20px;
            text-align: center;
            font-size: 16px;
            overflow: hidden;
            z-index: 999;
            box-shadow: 0 2px 8px var(--shadow-color);
            backdrop-filter: blur(15px);
            border-bottom: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .rolling-text-container a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .rolling-text-container a:hover {
            color: var(--accent-color);
            text-decoration: underline;
        }

        /* Enhanced summary box */
        .summary-box {
            position: absolute;
            top: 80px;
            right: 20px;
            background: var(--surface-color);
            border-radius: 12px;
            box-shadow: 0 4px 16px var(--shadow-color);
            padding: 16px 20px;
            z-index: 2000;
            transition: all 0.3s ease;
            cursor: pointer;
            min-width: 200px;
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
        }

        .summary-box:hover {
            background: var(--background-color);
            box-shadow: 0 6px 24px var(--shadow-color);
            transform: translateY(-2px);
        }

        .summary-box h3 {
            margin: 0 0 12px 0;
            color: var(--primary-color);
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .summary-box ul {
            margin: 0;
            padding-left: 20px;
            list-style: none;
        }

        .summary-box li {
            margin: 6px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .summary-box .summary-icon {
            width: 20px;
            text-align: center;
            font-size: 16px;
        }

        /* Enhanced popup styles */
        .custom-popup .leaflet-popup-content-wrapper {
            background: var(--surface-color) !important;
            color: var(--text-color) !important;
            border-radius: 12px !important;
            padding: 16px 18px 12px 18px !important;
            box-shadow: 0 8px 32px var(--shadow-color) !important;
            min-width: 220px !important;
            max-width: 350px !important;
            backdrop-filter: blur(15px) !important;
            border: 1px solid var(--border-color) !important;
        }

        .custom-popup .leaflet-popup-content h3 {
            margin: 0 0 8px 0 !important;
            font-size: 18px !important;
            color: var(--primary-color) !important;
            font-weight: bold !important;
        }

        .custom-popup .leaflet-popup-content h4 {
            margin: 12px 0 6px 0 !important;
            font-size: 14px !important;
            color: var(--secondary-color) !important;
            font-weight: 600 !important;
        }

        .custom-popup .leaflet-popup-content ul {
            margin: 0 0 8px 0 !important;
            padding-left: 20px !important;
        }

        .custom-popup .leaflet-popup-content li {
            margin-bottom: 4px !important;
            line-height: 1.4 !important;
        }

        .custom-popup .leaflet-popup-content a {
            color: var(--primary-color) !important;
            text-decoration: none !important;
            font-weight: 500 !important;
            transition: all 0.3s ease !important;
        }

        .custom-popup .leaflet-popup-content a:hover {
            color: var(--accent-color) !important;
            text-decoration: underline !important;
        }

        .custom-popup .leaflet-popup-tip {
            background: var(--surface-color) !important;
            border: 1px solid var(--border-color) !important;
            box-shadow: 0 2px 8px var(--shadow-color) !important;
        }

        /* Profile modal styles */
        .profile-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            animation: modalFadeIn 0.3s ease;
        }

        .profile-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .profile-modal-content {
            background: var(--background-color);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 95%;
            max-width: 1200px;
            height: 90%;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .profile-modal-content.fullscreen {
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            border-radius: 0;
            box-shadow: none;
        }

        .profile-modal.fullscreen {
            background: rgba(0, 0, 0, 1);
        }

        .profile-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--primary-color);
            color: white;
        }

        .profile-modal-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: bold;
        }

        .modal-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .profile-modal-close,
        .profile-modal-fullscreen {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.3s ease;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .profile-modal-close:hover,
        .profile-modal-fullscreen:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .profile-modal-fullscreen {
            font-size: 20px;
        }

        .profile-modal-fullscreen.active {
            background: rgba(255, 255, 255, 0.3);
        }

        .profile-iframe {
            flex: 1;
            border: none;
            width: 100%;
            background: white;
        }

        /* Loading states */
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        /* Notification system */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--secondary-color);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 9999;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: #e74c3c;
        }

        .notification.success {
            background: var(--secondary-color);
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .control-button {
                width: 44px;
                height: 44px;
                font-size: 18px;
            }

            #back-button {
                top: 15px;
                left: 15px;
            }

            .theme-toggle {
                top: 15px;
                right: 15px;
            }

            .rolling-text-container {
                padding: 12px 15px;
                font-size: 14px;
            }

            .summary-box {
                top: 70px;
                right: 15px;
                left: 15px;
                min-width: auto;
            }

            .grid-number {
                font-size: 12px;
                padding: 4px 8px;
            }

            .custom-popup .leaflet-popup-content-wrapper {
                min-width: 200px !important;
                max-width: 90vw !important;
            }

            .profile-modal-content {
                width: 95%;
                height: 90%;
                margin: 10px;
            }

            .profile-modal-content.fullscreen {
                margin: 0;
                width: 100vw;
                height: 100vh;
            }

            .modal-controls {
                gap: 6px;
            }

            .profile-modal-close,
            .profile-modal-fullscreen {
                width: 44px;
                height: 44px;
                font-size: 20px;
                touch-action: manipulation;
            }
        }

        /* Animations */
        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in-up {
            animation: fadeInUp 0.6s ease-out;
        }

        /* Enhanced tile transitions */
        .leaflet-tile {
            transition: opacity 0.3s ease;
        }

        /* Zoom control positioning */
        .leaflet-control-zoom {
            z-index: 1000;
            margin-left: 10px;
            margin-bottom: 10px;
        }

        /* Loading overlay */
        .page-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--background-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .page-loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            margin-top: 20px;
            font-size: 18px;
            color: var(--primary-color);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Page loading overlay -->
    <div id="page-loading" class="page-loading">
        <div class="loading-spinner">
            <div class="spinner"></div>
        </div>
        <div class="loading-text">🌍 Loading UPlanet World...</div>
    </div>

    <!-- Map container -->
    <div id="map">
        <button id="back-button" class="control-button" onclick="window.location.href='/ipns/copylaradio.com'" title="UPlanet Home">🌐</button>
        <button class="control-button theme-toggle" onclick="toggleTheme()" title="Mode clair + Vue carte">🗺️</button>
    </div>

    <!-- Rolling text -->
    <div id="rollingText" class="rolling-text-container"></div>

    <!-- Profile modal -->
    <div id="profile-modal" class="profile-modal">
        <div class="profile-modal-content">
            <div class="profile-modal-header">
                <h3 id="profile-modal-title">Profile</h3>
                <div class="modal-controls">
                    <button class="profile-modal-fullscreen" onclick="toggleFullscreenModal()" title="Fullscreen (F11)">⛶</button>
                    <button class="profile-modal-close" onclick="closeProfileModal()" title="Close (Esc)">✕</button>
                </div>
            </div>
            <iframe id="profile-iframe" class="profile-iframe" src="about:blank"></iframe>
        </div>
    </div>

    <script src="leaflet.js"></script>
    <script>
        // ⚡ PERFORMANCE: Constants and configuration
        const CONFIG = {
            CACHE_SIZE: 20,
            API_TIMEOUT: 15000,
            CACHE_DURATION: 600000, // 10 minutes
            DEBOUNCE_DELAY: 200,
            GRID_SIZE: 36,
            TILE_SIZE: 10,
            MOBILE_BREAKPOINT: 768,
            NOTIFICATION_DURATION: 4000,
            MODAL_TIMEOUT: 30000,
            HAPTIC_DURATION: 10
        };

        // ⚡ PERFORMANCE: DOM Cache System
        class DOMCache {
            constructor() {
                this.cache = new Map();
                this.observers = new Map();
            }

            get(selector, context = document) {
                const key = `${selector}:${context === document ? 'doc' : 'ctx'}`;
                if (!this.cache.has(key)) {
                    const element = context.querySelector(selector);
                    if (element) {
                        this.cache.set(key, element);
                        this.watchForRemoval(key, element);
                    }
                    return element;
                }
                return this.cache.get(key);
            }

            getAll(selector, context = document) {
                const key = `${selector}:all:${context === document ? 'doc' : 'ctx'}`;
                if (!this.cache.has(key)) {
                    const elements = Array.from(context.querySelectorAll(selector));
                    this.cache.set(key, elements);
                }
                return this.cache.get(key);
            }

            watchForRemoval(key, element) {
                if ('MutationObserver' in window && element.parentNode) {
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            mutation.removedNodes.forEach((node) => {
                                if (node === element || node.contains?.(element)) {
                                    this.cache.delete(key);
                                    observer.disconnect();
                                    this.observers.delete(key);
                                }
                            });
                        });
                    });
                    
                    observer.observe(document.body, { childList: true, subtree: true });
                    this.observers.set(key, observer);
                }
            }

            clear() {
                this.cache.clear();
                this.observers.forEach(observer => observer.disconnect());
                this.observers.clear();
            }

            invalidate(selector) {
                const keysToDelete = Array.from(this.cache.keys()).filter(key => key.startsWith(selector));
                keysToDelete.forEach(key => {
                    this.cache.delete(key);
                    if (this.observers.has(key)) {
                        this.observers.get(key).disconnect();
                        this.observers.delete(key);
                    }
                });
            }
        }

        // ⚡ PERFORMANCE: Utility functions
        const Utils = {
            debounce(func, wait, immediate = false) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        timeout = null;
                        if (!immediate) func.apply(this, args);
                    };
                    const callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) func.apply(this, args);
                };
            },

            throttle(func, limit) {
                let inThrottle;
                return function executedFunction(...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            createElement(tag, attributes = {}, textContent = '') {
                const element = document.createElement(tag);
                Object.entries(attributes).forEach(([key, value]) => {
                    if (key === 'className') {
                        element.className = value;
                    } else if (key === 'dataset') {
                        Object.entries(value).forEach(([dataKey, dataValue]) => {
                            element.dataset[dataKey] = dataValue;
                        });
                    } else if (key.startsWith('on')) {
                        const eventName = key.slice(2).toLowerCase();
                        element.addEventListener(eventName, value);
                    } else {
                        element.setAttribute(key, value);
                    }
                });
                if (textContent) {
                    element.textContent = textContent;
                }
                return element;
            },

            sanitizeHTML(str) {
                if (typeof str !== 'string') return String(str);
                const temp = document.createElement('div');
                temp.textContent = str;
                return temp.innerHTML;
            },

            isValidCoordinate(lat, lon) {
                return (
                    typeof lat === 'number' && typeof lon === 'number' &&
                    lat >= -90 && lat <= 90 &&
                    lon >= -180 && lon <= 180 &&
                    !isNaN(lat) && !isNaN(lon) &&
                    !(lat === 0 && lon === 0) // Exclude 0,0 as it usually means no geolocation
                );
            },

            getStorageItem(key, defaultValue = null) {
                try {
                    const item = localStorage.getItem(key);
                    return item !== null ? item : defaultValue;
                } catch (error) {
                    console.warn('localStorage access failed:', error);
                    return defaultValue;
                }
            },

            setStorageItem(key, value) {
                try {
                    localStorage.setItem(key, value);
                    return true;
                } catch (error) {
                    console.warn('localStorage write failed:', error);
                    return false;
                }
            },

            vibrate(pattern = CONFIG.HAPTIC_DURATION) {
                if (navigator.vibrate && window.innerWidth <= CONFIG.MOBILE_BREAKPOINT) {
                    navigator.vibrate(pattern);
                }
            },

            showNotification(message, type = 'success') {
                const notification = Utils.createElement('div', {
                    className: `notification ${type}`
                }, message);
                
                document.body.appendChild(notification);
                
                setTimeout(() => notification.classList.add('show'), 100);
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            document.body.removeChild(notification);
                        }
                    }, 300);
                }, CONFIG.NOTIFICATION_DURATION);
            }
        };

        // Global instances
        const domCache = new DOMCache();
        let map, tileLayer, rectangles = [], rectangleCounts = new Map();
        let currentModalTimeoutId = null;

        // Enhanced UPlanet Welcome implementation
        class EnhancedUPlanetWelcome {
            constructor() {
                this.dataCache = new Map();
                this.eventListeners = [];
                this.isDestroyed = false;
                this.init();
            }

            init() {
                console.log('🚀 UPlanet Enhanced Welcome - Initializing...');
                this.initMap();
                this.loadData();
            }

            initMap() {
                try {
                    // Create the map
                    map = L.map('map', {
                        zoomControl: false // Disable default zoom control
                    }).setView([0, 0], 1);
                    
                    // Add zoom control in bottom left
                    L.control.zoom({
                        position: 'bottomleft'
                    }).addTo(map);
                    
                    // Set initial tile layer based on theme
                    this.updateMapLayer();
                    
                    // Setup theme toggle
                    this.setupThemeToggle();
                    
                    // Create grid rectangles
                    this.createGridRectangles();
                    
                    console.log('✅ Map initialized successfully');
                } catch (error) {
                    console.error('❌ Failed to initialize map:', error);
                    Utils.showNotification('Erreur d\'initialisation de la carte', 'error');
                }
            }



            setTileLayer(mode) {
                try {
                    if (tileLayer) {
                        map.removeLayer(tileLayer);
                    }
                    
                    if (mode === 'SAT') {
                        tileLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                            attribution: 'UPlanet Enhanced | © Esri'
                        });
                    } else {
                        tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: 'UPlanet Enhanced | © OpenStreetMap contributors'
                        });
                    }
                    
                    tileLayer.addTo(map);
                } catch (error) {
                    console.error('Error setting tile layer:', error);
                }
            }

            updateMapLayer() {
                try {
                    const savedTheme = Utils.getStorageItem('uplanet-theme', 'light');
                    
                    // Automatically set map mode based on theme
                    // Light theme = MAP, Dark theme = SAT
                    if (savedTheme === 'dark') {
                        this.setTileLayer('SAT');
                        console.log('🌙 Dark theme → Satellite view');
                    } else {
                        this.setTileLayer('MAP');
                        console.log('☀️ Light theme → Map view');
                    }
                } catch (error) {
                    console.error('Error updating map layer:', error);
                }
            }

            setupThemeToggle() {
                const themeBtn = domCache.get('.theme-toggle');
                if (!themeBtn) return;

                const updateThemeButton = () => {
                    const theme = Utils.getStorageItem('uplanet-theme', 'light');
                    
                    const themeConfig = {
                        dark: { icon: '🛰️', title: 'Mode sombre + Vue satellite' },
                        light: { icon: '🗺️', title: 'Mode clair + Vue carte' }
                    };
                    
                    const config = themeConfig[theme] || themeConfig.light;
                    
                    themeBtn.textContent = config.icon;
                    themeBtn.title = config.title;
                };

                // Initialize button display
                updateThemeButton();
            }

            createGridRectangles() {
                try {
                    rectangles = [];
                    
                    for (let latIndex = 0; latIndex < CONFIG.GRID_SIZE; latIndex++) {
                        for (let lonIndex = 0; lonIndex < CONFIG.GRID_SIZE; lonIndex++) {
                            const lat = -180 + latIndex * CONFIG.TILE_SIZE;
                            const lon = -180 + lonIndex * CONFIG.TILE_SIZE;

                            const rectangle = L.rectangle(
                                [[lat, lon], [lat + CONFIG.TILE_SIZE, lon + CONFIG.TILE_SIZE]],
                                { 
                                    color: 'transparent', 
                                    weight: 1, 
                                    className: 'clickable-area',
                                    interactive: true
                                }
                            );

                            rectangle.on('click', () => {
                                try {
                                    // Always navigate to enhanced version (theme will be preserved)
                                    const url = `map_render.html?southWestLat=${lat}&southWestLon=${lon}&deg=${CONFIG.TILE_SIZE}`;
                                    
                                    Utils.vibrate();
                                    console.log('🗺️ Navigating to:', url);
                                    window.location.href = url;
                                } catch (error) {
                                    console.error('Navigation error:', error);
                                    Utils.showNotification('Erreur de navigation', 'error');
                                }
                            });

                            rectangle.addTo(map);
                            rectangles.push(rectangle);
                        }
                    }
                    
                    console.log(`✅ Created ${rectangles.length} grid rectangles`);
                } catch (error) {
                    console.error('Error creating grid rectangles:', error);
                }
            }

            async loadData() {
                try {
                    // Hide page loading
                    const pageLoading = domCache.get('#page-loading');
                    if (pageLoading) {
                        pageLoading.classList.add('hidden');
                    }

                    // Build API URLs
                    const urls = this.buildAPIUrls();
                    
                    // 🚀 Load UPlanet data immediately (priority)
                    this.loadUPlanetData(urls.uPlanetAPI_URL)
                        .then(uplanetData => {
                            if (uplanetData) {
                                this.processUPlanetData(uplanetData);
                                console.log('✅ UPlanet data loaded and processed successfully');
                                Utils.showNotification('🌍 UPlanet data loaded!', 'success');
                            }
                        })
                        .catch(err => {
                            console.warn('UPlanet data loading failed:', err);
                            Utils.showNotification('Erreur de chargement UPlanet', 'error');
                        });

                    // 🐉 Load DRAGONS data in background (optional)
                    this.loadDRAGONS(urls.zoneURL)
                        .then(dragonsData => {
                            if (dragonsData && dragonsData.length > 0) {
                                this.processDragonsData(dragonsData);
                                console.log('✅ DRAGONS data loaded and processed successfully');
                                Utils.showNotification('🐉 DRAGONS data loaded!', 'success');
                            } else {
                                console.log('⚠️ No DRAGONS data received');
                            }
                        })
                        .catch(err => {
                            console.warn('🐉 DRAGONS loading failed (optional):', err);
                            // Don't show error notification for DRAGONS as it's optional
                        });

                    console.log('✅ Data loading initiated (UPlanet priority, DRAGONS background)');

                } catch (error) {
                    console.error('❌ Error loading data:', error);
                    Utils.showNotification('Erreur de chargement des données', 'error');
                }
            }

            buildAPIUrls() {
                const currentURL = new URL(window.location.href);
                const hostname = currentURL.hostname;
                const protocol = currentURL.protocol.split(":")[0];

                // Dragons URL
                let zPort = currentURL.port;
                if (zPort === "8080") zPort = "1234";
                const zHost = hostname.replace("ipfs", "astroport");
                const station = `${protocol}://${zHost}${zPort ? ":" + zPort : ""}`;
                const zoneURL = `${station}/?dragons=one`;

                // UPlanet API URL
                let uPort = currentURL.port;
                if (uPort === "8080") uPort = "54321";
                const uHost = hostname.replace("ipfs", "u");
                const uPlanetStation = `${protocol}://${uHost}${uPort ? ":" + uPort : ""}`;
                const uPlanetAPI_URL = `${uPlanetStation}/`;

                console.log('🔗 API URLs:', { zoneURL, uPlanetAPI_URL });
                return { zoneURL, uPlanetAPI_URL };
            }

            async loadDRAGONS(myURL) {
                try {
                    console.log('📡 Fetching DRAGONS data from:', myURL);
                    const data = await this.fetchAstroport(myURL);
                    console.log('✅ DRAGONS data loaded:', data?.length || 0, 'items');
                    return data?.filter(({ lat, lon }) => 
                        Utils.isValidCoordinate(lat, lon)
                    ) || [];
                } catch (error) {
                    console.error('❌ Error loading DRAGONS:', error);
                    return [];
                }
            }

            async loadUPlanetData(myURL) {
                try {
                    console.log('📡 Fetching UPlanet data from:', myURL);
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), CONFIG.API_TIMEOUT);
                    
                    const response = await fetch(myURL, { 
                        signal: controller.signal,
                        headers: {
                            'Cache-Control': 'max-age=600' // 10 minutes cache
                        }
                    });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log('✅ UPlanet data loaded successfully');
                    return data;
                } catch (error) {
                    console.error('❌ Error loading UPlanet data:', error);
                    return null;
                }
            }

            async fetchAstroport(myURL, retryCount = 3) {
                try {
                    const one = await fetch(myURL);
                    const doc = await one.text();
                    const regex = /url='([^']+)/i;
                    const match = doc.match(regex);
                    
                    if (!match || !match[1]) {
                        throw new Error('No redirect URL found in response');
                    }
                    
                    const redirectURL = match[1];

                    return new Promise(async (resolve, reject) => {
                        let retry = 0;

                        const fetchData = async () => {
                            try {
                                const two = await fetch(redirectURL);
                                if (!two.ok) {
                                    throw new Error(`HTTP ${two.status}: ${two.statusText}`);
                                }
                                const data = await two.json();
                                resolve(data);
                            } catch (error) {
                                if (retry < retryCount) {
                                    console.log(`🔄 Retry ${retry + 1}/${retryCount} after 4000ms...`);
                                    retry++;
                                    setTimeout(fetchData, 4000);
                                } else {
                                    console.log('❌ Max retries reached. Fetch error:', error);
                                    reject(error);
                                }
                            }
                        };

                        setTimeout(fetchData, 3000);
                    });
                } catch (err) {
                    console.log('❌ Fetch error:', err);
                    return Promise.reject(err);
                }
            }

            processDragonsData(dragons) {
                if (!Array.isArray(dragons) || dragons.length === 0) {
                    console.log('⚠️ No DRAGONS data to process');
                    return;
                }

                try {
                    this.displayRollingText(dragons);
                    this.overlayDragonsCount(dragons);
                    console.log(`✅ Processed ${dragons.length} DRAGONS`);
                } catch (error) {
                    console.error('Error processing DRAGONS data:', error);
                }
            }

            displayRollingText(dragons) {
                const rollingTextContainer = domCache.get('#rollingText');
                if (!rollingTextContainer || dragons.length === 0) return;

                let currentIndex = 0;

                const updateText = () => {
                    const dragon = dragons[currentIndex];
                    if (dragon) {
                        const title = Utils.sanitizeHTML(dragon.title || 'Unnamed');
                        const lat = Utils.sanitizeHTML(dragon.lat || '0');
                        const lon = Utils.sanitizeHTML(dragon.lon || '0');
                        const tags = Utils.sanitizeHTML(dragon.tags || '');
                        const ipfsnodeid = Utils.sanitizeHTML(dragon.ipfsnodeid || '');
                        
                        rollingTextContainer.innerHTML = `
                            [${currentIndex + 1}/${dragons.length}] :: ${title} :: 
                            _${lat}_${lon} 
                            <a href="/ipns/${ipfsnodeid}" title="${tags}" target="12345">
                                (U) [♥️BOX] (U)
                            </a>
                        `;
                    }
                    currentIndex = (currentIndex + 1) % dragons.length;
                };

                // Update immediately and then every 5 seconds
                updateText();
                setInterval(updateText, 5000);
            }

            overlayDragonsCount(dragons) {
                const dragonRectanglesMap = new Map();

                dragons.forEach(({ lat, lon }) => {
                    if (!Utils.isValidCoordinate(lat, lon)) return;

                    const latLng = L.latLng(lat, lon);
                    const matchingRectangle = rectangles.find(rectangle =>
                        rectangle.getBounds().contains(latLng)
                    );

                    if (matchingRectangle) {
                        const count = dragonRectanglesMap.get(matchingRectangle) || 0;
                        dragonRectanglesMap.set(matchingRectangle, count + 1);
                    }
                });

                // Overlay grid numbers
                dragonRectanglesMap.forEach((count, rectangle) => {
                    this.overlayGridNumbers(rectangle, count);
                });

                console.log(`✅ Overlaid ${dragonRectanglesMap.size} grid numbers`);
            }

            overlayGridNumbers(rectangle, count) {
                try {
                    const latLng = rectangle.getBounds().getCenter();
                    const containerPoint = map.latLngToContainerPoint(latLng);

                    const numberElement = Utils.createElement('div', {
                        className: 'grid-number',
                        style: `
                            position: absolute;
                            z-index: 1000;
                            top: ${containerPoint.y}px;
                            left: ${containerPoint.x}px;
                            transform: translate(-50%, -50%);
                        `
                    }, String(count));

                    domCache.get('#map').appendChild(numberElement);

                    // Update position on map move
                    const updatePosition = () => {
                        const newPoint = map.latLngToContainerPoint(latLng);
                        numberElement.style.top = `${newPoint.y}px`;
                        numberElement.style.left = `${newPoint.x}px`;
                    };

                    map.on('zoomend moveend', updatePosition);
                } catch (error) {
                    console.warn('Error overlaying grid number:', error);
                }
            }

            processUPlanetData(uPlanetData) {
                if (!uPlanetData) {
                    console.log('⚠️ No UPlanet data to process');
                    return;
                }

                try {
                    this.createLocationMarkers(uPlanetData);
                    this.createSummaryBox(uPlanetData);
                    console.log('✅ UPlanet data processed successfully');
                } catch (error) {
                    console.error('Error processing UPlanet data:', error);
                }
            }

            createLocationMarkers(uPlanetData) {
                const locationEntities = {};

                // Helper function to check for valid values (including string "null")
                const isValid = (val) => val !== null && val !== undefined && val !== '' && val !== 'null' && val !== 'NULL';

                console.log('🔍 Processing UPlanet data for markers:', {
                    NOSTR: uPlanetData.NOSTR?.length || 0,
                    PLAYERs: uPlanetData.PLAYERs?.length || 0,
                    UMAPs: uPlanetData.UMAPs?.length || 0
                });

                // Group NOSTR users by location
                if (Array.isArray(uPlanetData.NOSTR)) {
                    console.log('📡 Processing NOSTR data:', uPlanetData.NOSTR);
                    uPlanetData.NOSTR.forEach((nostr, index) => {
                        console.log(`📡 NOSTR[${index}]:`, { EMAIL: nostr.EMAIL, HEX: nostr.HEX, LAT: nostr.LAT, LON: nostr.LON });
                        
                        if (nostr.LAT && nostr.LON && isValid(nostr.HEX) && nostr.EMAIL) {
                            const locationKey = `${nostr.LAT},${nostr.LON}`;
                            if (!locationEntities[locationKey]) {
                                locationEntities[locationKey] = { PLAYERS: [], UMAPS: [], NOSTR: [] };
                            }
                            if (!locationEntities[locationKey].NOSTR) {
                                locationEntities[locationKey].NOSTR = [];
                            }
                            locationEntities[locationKey].NOSTR.push({
                                hex: nostr.HEX,
                                email: nostr.EMAIL,
                                zen: nostr.ZEN,
                                g1pub: nostr.G1PUBNOSTR
                            });
                            console.log(`✅ Added NOSTR user ${nostr.EMAIL} at ${locationKey}`);
                        } else {
                            console.log(`❌ Skipped NOSTR user:`, {
                                EMAIL: nostr.EMAIL,
                                hasLAT: !!nostr.LAT,
                                hasLON: !!nostr.LON,
                                HEX: nostr.HEX,
                                validHEX: isValid(nostr.HEX)
                            });
                        }
                    });
                }

                // Group PLAYERS by location
                if (Array.isArray(uPlanetData.PLAYERs)) {
                    console.log('🎮 Processing PLAYERs data:', uPlanetData.PLAYERs);
                    uPlanetData.PLAYERs.forEach((player, index) => {
                        console.log(`🎮 PLAYER[${index}]:`, { ASTROMAIL: player.ASTROMAIL, HEX: player.HEX, LAT: player.LAT, LON: player.LON });
                        
                        // Accept players even without valid HEX (ZEN Card only)
                        if (player.LAT && player.LON && player.ASTROMAIL) {
                            const locationKey = `${player.LAT},${player.LON}`;
                            if (!locationEntities[locationKey]) {
                                locationEntities[locationKey] = { PLAYERS: [], UMAPS: [], NOSTR: [] };
                            }
                            locationEntities[locationKey].PLAYERS.push({
                                hex: isValid(player.HEX) ? player.HEX : null,
                                astromail: player.ASTROMAIL,
                                zen: player.ZEN,
                                astroport: player.ASTROPORT,
                                astrotw: player.ASTROTW,
                                astrofeed: player.ASTROFEED
                            });
                            console.log(`✅ Added PLAYER ${player.ASTROMAIL} at ${locationKey}`);
                        } else {
                            console.log(`❌ Skipped PLAYER:`, {
                                ASTROMAIL: player.ASTROMAIL,
                                hasLAT: !!player.LAT,
                                hasLON: !!player.LON,
                                HEX: player.HEX
                            });
                        }
                    });
                }

                // Group UMAPs by location
                if (Array.isArray(uPlanetData.UMAPs)) {
                    console.log('🧩 Processing UMAPs data:', uPlanetData.UMAPs);
                    uPlanetData.UMAPs.forEach((umap, index) => {
                        console.log(`🧩 UMAP[${index}]:`, { LAT: umap.LAT, LON: umap.LON, UMAPHEX: umap.UMAPHEX });
                        
                        if (umap.LAT && umap.LON && umap.UMAPHEX) {
                            const locationKey = `${umap.LAT},${umap.LON}`;
                            if (!locationEntities[locationKey]) {
                                locationEntities[locationKey] = { PLAYERS: [], UMAPS: [], NOSTR: [] };
                            }
                            locationEntities[locationKey].UMAPS.push({
                                hex: umap.UMAPHEX,
                                umapipfs: umap.UMAPROOT,
                                lat: umap.LAT,
                                lon: umap.LON,
                                ...umap
                            });
                            console.log(`✅ Added UMAP at ${locationKey}`);
                        } else {
                            console.log(`❌ Skipped UMAP:`, {
                                hasLAT: !!umap.LAT,
                                hasLON: !!umap.LON,
                                UMAPHEX: umap.UMAPHEX
                            });
                        }
                    });
                }

                // Create markers for each location
                console.log('🗺️ Creating markers for locations:', Object.keys(locationEntities));
                Object.entries(locationEntities).forEach(([locationKey, entities]) => {
                    const [lat, lon] = locationKey.split(',').map(parseFloat);
                    
                    console.log(`📍 Processing location ${locationKey}:`, {
                        lat, lon,
                        validCoords: Utils.isValidCoordinate(lat, lon),
                        NOSTR: entities.NOSTR?.length || 0,
                        PLAYERS: entities.PLAYERS?.length || 0,
                        UMAPS: entities.UMAPS?.length || 0
                    });
                    
                    if (!Utils.isValidCoordinate(lat, lon)) {
                        console.log(`❌ Invalid coordinates for ${locationKey}: ${lat}, ${lon}`);
                        return;
                    }

                    let popupContent = '';
                    let iconUrl = null;

                    // Priority: UMAP > NOSTR > PLAYERS
                    if (entities.UMAPS && entities.UMAPS.length > 0) {
                        iconUrl = 'umap-icon.png';
                        popupContent = this.createUMAPPopupContent(entities.UMAPS[0], entities.PLAYERS, entities.NOSTR, isValid);
                        console.log(`🧩 Creating UMAP marker at ${locationKey}`);
                    } else if (entities.NOSTR && entities.NOSTR.length > 0) {
                        iconUrl = 'player-icon.png'; // Use player icon for NOSTR
                        popupContent = this.createNOSTRPopupContent(entities.NOSTR, entities.PLAYERS, isValid);
                        console.log(`📡 Creating NOSTR marker at ${locationKey}`);
                    } else if (entities.PLAYERS && entities.PLAYERS.length > 0) {
                        iconUrl = 'player-icon.png';
                        popupContent = this.createPlayersPopupContent(entities.PLAYERS, isValid);
                        console.log(`🎮 Creating PLAYER marker at ${locationKey}`);
                    }

                    if (iconUrl && popupContent) {
                        try {
                            const icon = L.icon({
                                iconUrl: iconUrl,
                                iconSize: [32, 32],
                                iconAnchor: [16, 32],
                                popupAnchor: [0, -32]
                            });

                            L.marker([lat, lon], { icon })
                                .bindPopup(popupContent, { className: 'custom-popup' })
                                .addTo(map);
                                
                            console.log(`✅ Marker created successfully at ${locationKey}`);
                        } catch (markerError) {
                            console.error(`❌ Error creating marker at ${locationKey}:`, markerError);
                        }
                    } else {
                        console.log(`⚠️ No valid content for marker at ${locationKey}:`, { iconUrl, hasContent: !!popupContent });
                    }
                });
                
                console.log('📊 Marker creation summary:', {
                    totalLocations: Object.keys(locationEntities).length,
                    locationsWithMarkers: Object.entries(locationEntities).filter(([key, entities]) => {
                        const [lat, lon] = key.split(',').map(parseFloat);
                        return Utils.isValidCoordinate(lat, lon) && 
                               ((entities.UMAPS && entities.UMAPS.length > 0) ||
                                (entities.NOSTR && entities.NOSTR.length > 0) ||
                                (entities.PLAYERS && entities.PLAYERS.length > 0));
                    }).length
                });
            }

            createUMAPPopupContent(umap, players, nostrUsers, isValid) {
                let content = `<div class='umap-popup' style='min-width:260px;max-width:350px;'>`;
                content += `<h3>🧩 UMAP</h3>`;
                
                if (isValid(umap.lat) && isValid(umap.lon)) {
                    content += `<div><b>Lat:</b> ${umap.lat} <b>Lon:</b> ${umap.lon}</div>`;
                }
                
                content += `<ul style='margin:8px 0;padding-left:18px;'>`;
                
                if (isValid(umap.hex)) {
                    content += `<li><a href="#" onclick="openProfileModal('nostr_profile_viewer.html?hex=${umap.hex}', 'UMAP Profile')" title="Open Nostr profile">🧑‍🚀 UMAP Nostr</a></li>`;
                }
                
                if (isValid(umap.umapipfs)) {
                    content += `<li><a href="/ipfs/${umap.umapipfs}" target="_blank" title="Open IPFS Drive">📁 IPFS Drive</a></li>`;
                }
                
                content += `</ul>`;

                // Show NOSTR users first (MULTIPASS)
                if (nostrUsers && nostrUsers.length > 0) {
                    content += `<section><h4>🚀 Utilisateurs (MULTIPASS)</h4><ul style='padding-left:18px;'>`;
                    const selectedNostr = nostrUsers.slice(0, Math.min(10, nostrUsers.length));
                    selectedNostr.forEach(nostr => {
                        if (isValid(nostr.hex) && isValid(nostr.email)) {
                            const zenInfo = nostr.zen ? ` (${nostr.zen} Ẑen)` : '';
                            content += `<li><a href="#" onclick="openProfileModal('nostr_profile_viewer.html?hex=${nostr.hex}', '${Utils.sanitizeHTML(nostr.email)}')">${Utils.sanitizeHTML(nostr.email)}${zenInfo}</a></li>`;
                        }
                    });
                    content += `</ul></section>`;
                }

                // Show PLAYERS (ZEN Card)
                if (players && players.length > 0) {
                    content += `<section><h4>👤 Sociétaires (ZEN Card)</h4><ul style='padding-left:18px;'>`;
                    const selectedPlayers = players.slice(0, Math.min(10, players.length));
                    selectedPlayers.forEach(player => {
                        if (isValid(player.astromail)) {
                            const zenInfo = player.zen ? ` (${player.zen} Ẑen)` : '';
                            if (isValid(player.hex)) {
                                content += `<li><a href="#" onclick="openProfileModal('nostr_profile_viewer.html?hex=${player.hex}', '${Utils.sanitizeHTML(player.astromail)}')">${Utils.sanitizeHTML(player.astromail)}${zenInfo}</a></li>`;
                            } else {
                                content += `<li>${Utils.sanitizeHTML(player.astromail)}${zenInfo} (ZEN only)</li>`;
                            }
                        }
                    });
                    content += `</ul></section>`;
                }
                
                content += `</div>`;
                return content;
            }

            createNOSTRPopupContent(nostrUsers, players, isValid) {
                let content = `<div class='umap-popup' style='min-width:260px;max-width:350px;'>`;
                content += `<h3>🚀 Utilisateurs (MULTIPASS)</h3>`;
                
                if (nostrUsers && nostrUsers.length > 0) {
                    content += `<ul style='margin:8px 0;padding-left:18px;'>`;
                    const selectedNostr = nostrUsers.slice(0, Math.min(10, nostrUsers.length));
                    selectedNostr.forEach(nostr => {
                        if (isValid(nostr.hex) && isValid(nostr.email)) {
                            const zenInfo = nostr.zen ? ` (${nostr.zen} Ẑen)` : '';
                            content += `<li><a href="#" onclick="openProfileModal('nostr_profile_viewer.html?hex=${nostr.hex}', '${Utils.sanitizeHTML(nostr.email)}')">${Utils.sanitizeHTML(nostr.email)}${zenInfo}</a></li>`;
                        }
                    });
                    content += `</ul>`;
                }

                // Show additional PLAYERS if any at same location
                if (players && players.length > 0) {
                    content += `<section><h4>👤 Sociétaires (ZEN Card)</h4><ul style='padding-left:18px;'>`;
                    const selectedPlayers = players.slice(0, Math.min(5, players.length));
                    selectedPlayers.forEach(player => {
                        if (isValid(player.astromail)) {
                            const zenInfo = player.zen ? ` (${player.zen} Ẑen)` : '';
                            if (isValid(player.hex)) {
                                content += `<li><a href="#" onclick="openProfileModal('nostr_profile_viewer.html?hex=${player.hex}', '${Utils.sanitizeHTML(player.astromail)}')">${Utils.sanitizeHTML(player.astromail)}${zenInfo}</a></li>`;
                            } else {
                                content += `<li>${Utils.sanitizeHTML(player.astromail)}${zenInfo} (ZEN only)</li>`;
                            }
                        }
                    });
                    content += `</ul></section>`;
                }
                
                content += `</div>`;
                return content;
            }

            createPlayersPopupContent(players, isValid) {
                let content = `<div class='umap-popup' style='min-width:220px;max-width:320px;'>`;
                content += `<h3>👤 Sociétaires (ZEN Card)</h3><ul style='padding-left:18px;'>`;
                
                players.forEach(player => {
                    if (isValid(player.astromail)) {
                        const zenInfo = player.zen ? ` (${player.zen} Ẑen)` : '';
                        if (isValid(player.hex)) {
                            content += `<li><a href="#" onclick="openProfileModal('nostr_profile_viewer.html?hex=${player.hex}', '${Utils.sanitizeHTML(player.astromail)}')">${Utils.sanitizeHTML(player.astromail)}${zenInfo}</a></li>`;
                        } else {
                            content += `<li>${Utils.sanitizeHTML(player.astromail)}${zenInfo} (ZEN only)</li>`;
                        }
                    }
                });
                
                content += `</ul></div>`;
                return content;
            }

            createSummaryBox(uPlanetData) {
                const isValid = (val) => val !== null && val !== undefined && val !== '' && val !== 'null';
                
                let regionCount = 0, sectorCount = 0, umapCount = 0, playerCount = 0, nostrCount = 0;
                
                if (Array.isArray(uPlanetData.UMAPs)) umapCount = uPlanetData.UMAPs.length;
                if (Array.isArray(uPlanetData.PLAYERs)) playerCount = uPlanetData.PLAYERs.length;
                if (Array.isArray(uPlanetData.NOSTR)) nostrCount = uPlanetData.NOSTR.length;
                
                const regionSet = new Set(), sectorSet = new Set();
                if (Array.isArray(uPlanetData.UMAPs)) {
                    uPlanetData.UMAPs.forEach(umap => {
                        if (isValid(umap.REGIONHEX)) regionSet.add(umap.REGIONHEX);
                        if (isValid(umap.SECTORHEX)) sectorSet.add(umap.SECTORHEX);
                    });
                }
                regionCount = regionSet.size;
                sectorCount = sectorSet.size;

                if (regionCount > 0 || sectorCount > 0 || umapCount > 0 || playerCount > 0 || nostrCount > 0) {
                    const summaryBox = Utils.createElement('div', {
                        className: 'summary-box fade-in-up',
                        id: 'summary-box'
                    });

                    const summaryContent = Utils.createElement('div', { id: 'summary-content' });
                    
                    let contentHTML = `<h3>🌍 UPlanet Summary</h3><ul>`;
                    if (regionCount > 0) contentHTML += `<li><span class="summary-icon">🗺️</span><b>${regionCount}</b> Regions</li>`;
                    if (sectorCount > 0) contentHTML += `<li><span class="summary-icon">🗂️</span><b>${sectorCount}</b> Sectors</li>`;
                    if (umapCount > 0) contentHTML += `<li><span class="summary-icon">🧩</span><b>${umapCount}</b> UMAPs</li>`;
                    if (playerCount > 0) contentHTML += `<li><span class="summary-icon">🧑‍💼</span><b>${playerCount}</b> ZEN Card</li>`;
                    if (nostrCount > 0) contentHTML += `<li><span class="summary-icon">👤</span><b>${nostrCount}</b> MULTIPASS</li>`;
                    contentHTML += `</ul>`;
                    
                    summaryContent.innerHTML = contentHTML;
                    summaryBox.appendChild(summaryContent);
                    document.body.appendChild(summaryBox);

                    // Add accordion functionality
                    let isCollapsed = false;
                    summaryBox.addEventListener('click', function() {
                        const content = domCache.get('#summary-content');
                        if (content) {
                            if (isCollapsed) {
                                content.style.display = 'block';
                                summaryBox.style.padding = '16px 20px';
                                summaryBox.style.minWidth = '200px';
                                isCollapsed = false;
                            } else {
                                content.style.display = 'none';
                                summaryBox.style.padding = '8px 12px';
                                summaryBox.style.minWidth = 'auto';
                                isCollapsed = true;
                            }
                        }
                        Utils.vibrate();
                    });
                }
            }

            destroy() {
                this.isDestroyed = true;
                this.eventListeners.forEach(({ element, event, handler }) => {
                    element.removeEventListener(event, handler);
                });
                this.eventListeners = [];
                this.dataCache.clear();
                domCache.clear();
            }
        }

        // Theme toggle management (simple: light=MAP, dark=SAT)
        function toggleTheme() {
            try {
                const currentTheme = document.body.dataset.theme || 'light';
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                // Validate theme value
                if (!['light', 'dark'].includes(newTheme)) {
                    console.warn('Invalid theme value, defaulting to light');
                    newTheme = 'light';
                }
                
                // Apply theme
                document.body.dataset.theme = newTheme;
                Utils.setStorageItem('uplanet-theme', newTheme);
                
                // Update toggle icon and title with cached element
                const toggle = domCache.get('.theme-toggle');
                if (toggle) {
                    const themeConfig = {
                        dark: { icon: '🛰️', title: 'Mode sombre + Vue satellite' },
                        light: { icon: '🗺️', title: 'Mode clair + Vue carte' }
                    };
                    
                    const config = themeConfig[newTheme];
                    toggle.textContent = config.icon;
                    toggle.title = config.title;
                }
                
                // Update map layer automatically based on theme
                if (window.uplanetWelcome && window.uplanetWelcome.updateMapLayer) {
                    window.uplanetWelcome.updateMapLayer();
                }
                
                Utils.vibrate();
                console.log(`🎨 Theme switched to: ${newTheme}`);
                
                // Show notification to user
                const themeLabels = {
                    'light': '☀️ Mode clair + Carte',
                    'dark': '🌙 Mode sombre + Satellite'
                };
                const label = themeLabels[newTheme] || 'Unknown Theme';
                Utils.showNotification(label, 'success');
                
                // Dispatch custom event for theme change
                window.dispatchEvent(new CustomEvent('themeChanged', { 
                    detail: { theme: newTheme } 
                }));
                
            } catch (error) {
                console.error('Error toggling theme:', error);
                Utils.showNotification('Erreur de changement de thème', 'error');
            }
        }

        // Profile modal functions
        function openProfileModal(url, title = 'Profile') {
            try {
                const modal = domCache.get('#profile-modal');
                const iframe = domCache.get('#profile-iframe');
                const titleEl = domCache.get('#profile-modal-title');
                
                if (!modal || !iframe || !titleEl || !url) {
                    console.error('Modal elements not found or invalid URL');
                    return;
                }
                
                titleEl.textContent = Utils.sanitizeHTML(title);
                modal.classList.add('show');
                iframe.src = url;
                
                Utils.vibrate();
                console.log('📱 Profile modal opened:', url);
                
            } catch (error) {
                console.error('Error opening profile modal:', error);
                Utils.showNotification('Erreur d\'ouverture du profil', 'error');
            }
        }

        function closeProfileModal() {
            try {
                const modal = domCache.get('#profile-modal');
                const iframe = domCache.get('#profile-iframe');
                
                if (modal && iframe) {
                    resetFullscreenModal();
                    modal.classList.remove('show');
                    setTimeout(() => {
                        iframe.src = 'about:blank';
                    }, 300);
                }
                
                Utils.vibrate();
                console.log('📱 Profile modal closed');
                
            } catch (error) {
                console.error('Error closing profile modal:', error);
            }
        }

        function toggleFullscreenModal() {
            try {
                const modal = domCache.get('#profile-modal');
                const modalContent = domCache.get('.profile-modal-content');
                const fullscreenBtn = domCache.get('.profile-modal-fullscreen');
                
                if (!modal || !modalContent || !fullscreenBtn) return;
                
                const isFullscreen = modalContent.classList.contains('fullscreen');
                
                if (isFullscreen) {
                    modal.classList.remove('fullscreen');
                    modalContent.classList.remove('fullscreen');
                    fullscreenBtn.classList.remove('active');
                    fullscreenBtn.textContent = '⛶';
                    fullscreenBtn.title = 'Fullscreen (F11)';
                } else {
                    modal.classList.add('fullscreen');
                    modalContent.classList.add('fullscreen');
                    fullscreenBtn.classList.add('active');
                    fullscreenBtn.textContent = '🗗';
                    fullscreenBtn.title = 'Exit fullscreen (F11)';
                }
                
                Utils.vibrate([10, 20]);
                console.log(`📱 Modal fullscreen: ${!isFullscreen ? 'ON' : 'OFF'}`);
                
            } catch (error) {
                console.error('Error toggling modal fullscreen:', error);
            }
        }

        function resetFullscreenModal() {
            try {
                const modal = domCache.get('#profile-modal');
                const modalContent = domCache.get('.profile-modal-content');
                const fullscreenBtn = domCache.get('.profile-modal-fullscreen');
                
                if (modal && modalContent && fullscreenBtn) {
                    modal.classList.remove('fullscreen');
                    modalContent.classList.remove('fullscreen');
                    fullscreenBtn.classList.remove('active');
                    fullscreenBtn.textContent = '⛶';
                    fullscreenBtn.title = 'Fullscreen (F11)';
                }
            } catch (error) {
                console.warn('Error resetting fullscreen modal:', error);
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            const modal = domCache.get('#profile-modal');
            if (modal && modal.classList.contains('show')) {
                if (e.key === 'Escape') {
                    closeProfileModal();
                } else if (e.key === 'F11') {
                    e.preventDefault();
                    toggleFullscreenModal();
                }
            }
        });

        // Enhanced initialization
        document.addEventListener('DOMContentLoaded', () => {
            const startTime = performance.now();
            
            try {
                console.log('🚀 UPlanet Enhanced Welcome - Starting initialization...');
                
                // Load and apply saved theme
                const savedTheme = Utils.getStorageItem('uplanet-theme', 'light');
                document.body.dataset.theme = savedTheme;
                
                // Update theme toggle button immediately
                const toggle = domCache.get('.theme-toggle');
                if (toggle) {
                    const themeConfig = {
                        dark: { icon: '🛰️', title: 'Mode sombre + Vue satellite' },
                        light: { icon: '🗺️', title: 'Mode clair + Vue carte' }
                    };
                    const config = themeConfig[savedTheme] || themeConfig.light;
                    toggle.textContent = config.icon;
                    toggle.title = config.title;
                }
                
                // Initialize main application
                window.uplanetWelcome = new EnhancedUPlanetWelcome();
                
                // Log initial state
                console.log(`🎨🗺️ Initial state: ${savedTheme} theme (auto view)`);
                
                // Performance monitoring
                const endTime = performance.now();
                console.log(`✅ UPlanet Enhanced Welcome initialized in ${(endTime - startTime).toFixed(2)}ms`);
                
            } catch (error) {
                console.error('❌ Failed to initialize UPlanet Enhanced Welcome:', error);
                Utils.showNotification('Erreur d\'initialisation', 'error');
                
                // Hide loading overlay even on error
                const pageLoading = domCache.get('#page-loading');
                if (pageLoading) {
                    pageLoading.classList.add('hidden');
                }
            }
        });

        // Enhanced error handler
        window.addEventListener('error', function(event) {
            if (event.message?.includes('UPlanet') || event.filename?.includes('welcome')) {
                console.error('🚨 UPlanet Welcome Error:', {
                    message: event.message,
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    stack: event.error?.stack
                });
            }
            return false;
        });

        // Cleanup on unload
        window.addEventListener('beforeunload', function() {
            try {
                domCache.clear();
                if (window.uplanetWelcome?.destroy) {
                    window.uplanetWelcome.destroy();
                }
                console.log('🧹 UPlanet Welcome cleanup completed');
            } catch (error) {
                console.warn('Cleanup error:', error);
            }
        });

    </script>
</body>
</html> 